## 快速笔记

+ ws://192.169.7.32:9999/websocket
+ 远程以root用户通过vscode连接到机械臂的方法：
  + `source bash-workspace/arm-shell-env.sh`
  + 使用remote插件，远程连接

### demo_webserver.exe 帮助

+ 参数：
  + `--listen-address=0.0.0.0:9999` 设置服务器监听地址，默认为`0.0.0.0:9999`
  + `--abs-webroot-path=/home/user/zhangjunyi/arwen/webroot/dist/` 设置服务器托管前端代码目录的绝对路径，默认为`/home/user/zhangjunyi/arwen/webroot/dist/`

### 工程编译

+ 现在头文件和源文件都在 `arwen/src/webserver/`下面，而`arwen/include/webserver`下面的头文件只是在编写代码的时候用到，编译的时候还是只有在源代码下面的目录下存放头文件才可以，这个与CMakeLists.txt的编写有关，后面再解决
+ 目前的方法：
  + 将编写好的头文件和源文件都放在`arwen/src/webserver`下面，然后再将头文件拷贝到`arwen/include/webserver`下

## 机器人理论知识

+ 机器人有诸多的运动方式，如直线运动、关节角运动等。轨迹（点）作为机器人的运动路径，自然也有不同的运动指令类型，主要有MoveL, MoveJ, MoveAbsj, MoveC这四种。

### moveJ(Move-Joint)

+ 机器人以最快捷的方式运动至目标点，机器人运动状态不完全可控,机器人关节怎么舒服怎么走,完全按照机器人自己的意愿执行路径,但运动路径保持唯一，常用于机器人在空间大范围移动。

### moveL(Move-Line)

+ 机器人以线性方式运动至目标点，当前点与目标点两点决定一条严格直线，机器人运动状态可控，运动路径保持唯一。
+ 可能出现死点，常用于机器人在工作状态移动。示教的两个点之间的路径完全按照直线运动，奇异点和死机的可能性更大。

+ arwen工程代码中
  + 首先，使用moveJ指令走到一个初始位置（这个初始位置是moveL所规划的直线的起始点，也可以用moveL，但是其输入的坐标是笛卡尔空间坐标，需要再正解求出，比较麻烦）
  + 其次，调用moveL指令接收一个笛卡尔空间坐标作为终点，并在起始点和终点规划出一个直线路径，

+ 两个点选择的注意事项：
  + 奇异点：Base-坐标知识--机器人运动学 奇异点的概念
  + 规划的这两个点的中间有奇异点，一般来说，选择点的时候要避开奇异点

### moveAbsj(Move-Absjoint)

+ 绝对运动指令，机器人按照角度指令来移动。机器人运动状态可控。

### moveC(Move-Circle)

+ 圆弧运动指令，机器人通过中间点以圆弧移动方式运动至目标点，当前点、中间点与目标点三点决定一段圆弧，机器人运动状态可控，运动路径保持唯一。

## ethercat

### 1.1 启动，设置

+ ethercat都是在root用户下执行命令

+ 设置从站
  + ethercat alias -p 2 0:2

+ 启动ethercat
  + `/etc/init.d/ethercat start`

+ 查看状态
  + `ethercat slv`

### 1.2 调试命令

+ 查看从站状态码
  + `ethercat upload -t int16 -p 0 0x603f 00`
  + 

### 1.2 demo_webserver.c 分析

### 数据结构

#### `ec_pdo_entry_info_t`

+ 简介：PDO条目配置信息。这是`ec_pdo_info_t`中的`entries`字段的数据类型
+ 声明：
  ```
    typedef struct {
      uint16_t index;      /**< PDO entry index. */
      uint8_t  subindex;   /**< PDO entry subindex. */
      uint8_t  bit_length; /**< Size of the PDO entry in bit. */
    } ec_pdo_entry_info_t;
  ``` 

#### `ec_pdo_info_t`

+ 简介：PDO配置信息。这是`ec_sync_info_t`中的`pdos`字段的数据类型
+ 声明：
  ```
    typedef struct {
      uint16_t index;              /**< PDO index. */
      unsigned int n_entries;      /**< 要映射的entries PDO条目数 (0表示使用默认映射，这只能在从服务器处于总线配置时完成)*/
      ec_pdo_entry_info_t *entries;/**< 要映射的PDO项数组。可以是NULL，或者必须包含至少n_entries个值*/
    } ec_pdo_info_t;
  ``` 

#### `ec_sync_info_t`

+ 简介：同步管理器配置信息。这可以用于配置多个同步管理器，包括PDO分配和PDO映射。它被作为`ecrt_slave_config_pdos()`函数的输入参数使用
+ 声明：
  ```
    typedef struct {
      uint8_t index;  /**< 同步管理器索引。Sync manager index.Must be less than #EC_MAX_SYNC_MANAGERS for a valid sync manager,but can also be \a 0xff to mark the end of the list. */
      ec_direction_t dir;  /**<同步管理器方向 */
      unsigned int   n_pdos;  /**< PDOs在pdos结构体数组中的数量 */
      ec_pdo_info_t  *pdos;  /**<带有要分配的pdo的数组。所包含的PDOs必须不少于n_pdos
      ec_watchdog_mode_t watchdog_mode;  /**< 看门狗模式 */
    } ec_sync_info_t;
  ``` 

#### `ec_master_t`

+ 简介：主站

#### `ecrt_master_state_t`

+ 简介：主站状态，这个是用于函数`ecrt_master_state()`函数的输出参数
+ 声明：
  ```
    typedef struct {
      unsigned int slaves_responding;  // 所有Ethernet设备响应从站的总和
      unsigned int al_states : 4;      // 所有从站的应用层状态。状态被编码在较低的4位。如果设置了一个比特位，就意味着至少有一个从站在主线上响应：Bit 0: \a INIT；Bit 1: \a PREOP；Bit 2: \a SAFEOP；Bit 3: \a OP */
      unsigned int link_up : 1;        // true，如果至少有一个 Ethernet link是在线的，则为true
    } ec_master_state_t;
  ``` 

#### `ec_slave_config_t`

+ 简介：从站配置

#### `ec_slave_config_state_t`

+ 简介：从站配置状态。它用于函数`ecrt_slave_config_state()`的输出参数
+ 声明：
  ```
    typedef struct {
      unsigned int online : 1;      // 这个从站是在线的
      unsigned int operational : 1; // 这个从站通过指定配置进入OP状态
      unsigned int al_state : 4;    // 应用层的从站状态：1: \a INIT；2: \a PREOP；4: \a SAFEOP；8: \a OP
    } ec_slave_config_state_t;
  ``` 

#### `ec_domain_t`

+ 简介：域

#### `ec_wc_state_t`

+ 简介：域工作计数器状态说明。这个是在`ec_domain_state_t`中使用
+ 声明：
  ```
    typedef enum {
      EC_WC_ZERO = 0,   // 没有交换注册的过程数据
      EC_WC_INCOMPLETE, // 交换了一些已注册的过程数据(部分过程数据)
      EC_WC_COMPLETE    // 交换了所有已注册的过程数据
    } ec_wc_state_t;
  ``` 

#### `ec_domain_state_t`

+ 简介：域状态。它被作为函数`ecrt_domain_state()`的输出参数使用
+ 声明：
  ```
    typedef struct {
      unsigned int working_counter;   // 最后一个工作计数器的值
      ec_wc_state_t ws_state;         // 工作计数器状态说明
      unsigned int redundancy_active; // 冗余链路正在使用
    } ec_domain_state_t;
  ``` 

#### `ec_pdo_entry_reg_t`

+ 简介：列出PDO条目批量注册的记录类型。此类型用于`ecrt_domain_reg_pdo_entry_list()`的数组参数。
+ 声明：
  ```
    typedef struct {
      uint16_t alias;             // 从站别名地址
      uint16_t position;          // 从站位置
      uint32_t vendor_id;         // 从站供销商ID
      uint32_t product_code;      // 从站产品码
      uint16_t index;             // PDO条目索引
      uint8_t  subindex;          // PDO条目子索引
      unsigned int *offset;       // 指向在进程数据中存储PDO条目(字节-)偏移量的变量的指针。
      unsigned int *bit_position; // 指向一个变量的指针，用于在\a偏移量内存储位位置(0-7)。可以为NULL，在这种情况下，如果PDO条目不字节对齐会引发错误
    } ec_pdo_entry_reg_t;
  ``` 

### API

#### `ecrt_master_create_domain`

+ 简介：创建一个新的过程数据域。对于流程数据交换，至少需要一个流程数据域。这个方法创建一个新的过程数据域，并返回一个指向新域对象的指针。这个对象能够在循环操作中用于注册PDOs和交换PDOs
+ 声明：`ec_domain_t *ecrt_master_create_domain( ec_master_t *master);`

#### `ecrt_request_master`

+ 简介：请求EtherCAT主机进行实时操作。
  + 在应用程序可以访问EtherCAT主机之前，它必须预留一个专用的主机。
  + 在用户空间，这是`ecrt_open_master()`和`ecrt_master_reserve()`的方便函数。
  + 这个函数必须是应用程序使用EtherCAT时必须调用的第一个函数
  + 该函数以master的索引作为参数。第一个主节点的索引为0，第n个主节点的索引为n- 1。
  + 在加载master时，必须指定master的数量。
+ 声明：`ec_master_t *ecrt_request_master(unsigned int master_index);`

#### `ecrt_master_sdo_upload`

+ 简介：执行SDO上传请求从从站读取数据。
  + 此请求由主状态机处理。
  + 他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。
+ 声明：`int ecrt_master_sdo_upload(ec_master_t *master, uint16_t slave_position, uint16_t index, uint8_t subindex, uint8_t *target, size_t target_size, size_t *result_size, uint32_t *abort_code);`
+ 参数：
  + `master`          --  EtherCAT主站
  + `slave_position`  --  从站位置
  + `index`           --  SDO索引
  + `subindex`        --  SDO的子索引
  + `target`          --  上传的目标缓冲区。
  + `target_size`     --  目标缓冲区的大小
  + `result_size`     --  已经上传的数据大小
  + `abort_code`      --  SDO上传的中止代码。
+ 返回值：
  + 成功 --  0
  + 失败 --  < 0

#### `ecrt_master_sdo_download`

+ 简介：执行SDO下载请求，将数据写入从站。
  + 此请求由主状态机处理。
  + 他的方法会阻塞，直到请求被处理，并且不能在实时上下文中调用。
+ 声明：`int ecrt_master_sdo_download(ec_master_t *master, uint16_t slave_position, uint16_t index, uint8_t subindex, uint8_t *data, size_t data_size, uint32_t *abort_code);`
+ 参数：
  + `master`          --  EtherCAT主站
  + `slave_position`  --  从站位置
  + `index`           --  SDO索引
  + `subindex`        --  SDO的子索引
  + `data`            --  要下载的数据缓冲区
  + `data_size`       --  数据缓冲区大小
  + `abort_code`      --  SDO上传的中止代码。
+ 返回值：
  + 成功 --  0
  + 失败 --  < 0

#### `ecrt_domain_reg_pdo_entry_list`

+ 简介：为一个域注册一堆PDO条目。此方法必须在`ecrt_master_activate()`之前在非实时上下文中调用。
+ 声明：`int ecrt_domain_reg_pdo_entry_list(ec_domain_t *domain, const ec_pdo_entry_reg_t *pdo_entry_regs);`
+ 参数：
  + `domain`  -- 域
  + `pdo_entry_regs`  -- PDO注册数组。注册数组必须以一个空结构体结束，或者将\a索引字段设置为0 !
+ 返回值：
  + 成功  -- 0
  + 失败  -- 其他

#### `ecrt_master_activate`

+ 简介：完成配置阶段并为循环操作做准备。
  + 这个函数告诉主机配置阶段已经完成，将开始实时操作。
  + 该函数为域分配内部内存，并为域成员计算逻辑FMMU地址。
  + 它告诉主状态机现在要应用总线配置。
  + 调用此函数后，实时应用程序负责循环调用`ecrt_master_send()`和`ecrt_master_receive()`以确保总线通信。
  + 在调用这个函数之前，由主线程负责，所以这些函数可能不会被调用!
  + 该方法本身分配内存，不应该在实时上下文中调用。
+ 声明：`int ecrt_master_activate(ec_master_t *master);`
+ 参数：
  + `master`  --  EtherCAT 主站
+ 返回值：
  + 成功  -- 0
  + 失败  -- < 0

#### `ecrt_domain_data`

+ 简介：返回域的过程数据。
  + 在内核上下文中:
    + 如果使用`ecrt_domain_external_memory()`提供外部内存，则返回的指针将包含该内存的地址。
    + 否则它将指向内部分配的内存。
    + 在后一种情况下，在`ecrt_master_activate()`之前不能调用此方法。
  + 在用户空间上下文中:
    + 必须在`ecrt_master_activate()`之后调用此方法以获取映射的域进程数据内存。
+ 声明：`uint8_t *ecrt_domain_data(ec_domain_t *domain);`
+ 参数：
  + `domain`  --  域
+ 返回值：
  + 返回指向过程数据内存区域的指针

#### `ecrt_master_select_reference_clock`

+ 简介：为分布式时钟选择参考时钟。如果这个方法没有被某个主时钟调用，或者从时钟配置指针为NULL，那么第一个具有DC功能的从时钟将提供参考时钟。
+ 声明：`int ecrt_master_select_reference_clock(ec_master_t *master, ec_slave_config_t *sc);`
+ 参数：
  + `master`  --  EtherCAT 主站
  + `sc`      --  Slave的Slave配置要引用的Slave(或NULL)。
+ 返回值：
  + 成功  -- 0
  + 失败  --  负数，错误码

#### `ecrt_master_application_time`

+ 简介：设置应用时间。在使用分布式时钟操作从服务器时，主服务器必须知道应用程序的时间。主程序本身不会增加时间，因此必须循环调用此方法。
  + 传递给该方法的时间用于计算从服务器的SYNC0/1中断的阶段。它应该经常在实时周期的同一点被调用。因此，建议在计算开始时调用它，以避免由于执行时间的变化而导致的偏差。
  + 该时间用于设置从机的系统时间偏移和循环操作开始时间寄存器，以及通过ecrt_master_sync_reference_clock()将DC参考时钟同步到应用程序时间。
  + 时间定义为从2000-01-01 00:00开始的纳秒。可以使用EC_TIMEVAL2NANO()宏来转换epoch时间，但这不是必需的，因为绝对值无关紧要
+ 声明：`void ecrt_master_application_time(ec_master_t *master, uint64_t app_time);`
+ 参数：
  + `master`  --  EtherCAT 主站
  + `app_time`  --  应用时间

#### `ecrt_master_sync_reference_clock`

+ 简介：将DC参考时钟漂移补偿数据报排队发送。参考时钟将被同步到由最后一次调用取消ecrt_master_application_time()提供的应用程序时间。
+ 声明：`void ecrt_master_sync_reference_clock(ec_master_t *master);`
+ 参数：
  + `master`  --  EtherCAT 主站

#### `ecrt_master_sync_slave_clocks`

+ 简介：将DC时钟漂移补偿数据报排队发送。所有从时钟同步到参考时钟。
+ 声明：`void ecrt_master_sync_slave_clocks(ec_master_t *master);`
+ 参数：
  + `master`  --  EtherCAT 主站

#### `ecrt_release_master`

+ 简介：释放一个请求的EtherCAT主机。
  + 在使用后，必须释放master，以便其他应用程序可以使用它。
  + 此方法释放所有已创建的数据结构。它不应该在实时上下文中调用。
  + 如果主站被激活，则内部调用`ecrt_master_deactivate()`。
+ 声明：`void ecrt_release_master(ec_master_t *master);`
+ 参数：
  + `master`  --  EtherCAT 主站

#### `ecrt_master_receive`

+ 简介：从硬件中获取接收到的帧并处理数据报。
  + 通过调用中断服务例程查询网络设备接收的帧。
  + 提取接收到的数据报，并将结果分派到队列中的数据报对象。
  + 接收到的数据报和超时的数据报将被标记，并退出队列
  + 必须在`ecrt_master_activate()`返回后由实时应用程序循环调用。
+ 声明：`void ecrt_master_receive(ec_master_t *master);`

#### `ecrt_domain_process`

+ 简介：确定域的数据报的状态。
  + 计算接收到的数据报的工作计数器，并在必要时输出统计信息。
  + 这必须在`ecrt_master_receive()`接收域数据报之后调用，以便使`ecrt_domain_state()`返回最后一次进程数据交换的结果。
+ 声明：`void ecrt_domain_process(ec_domain_t *domain);`

#### `ecrt_domain_queue`

+ 简介：(Re-)将所有域数据报放在主数据报队列中。调用此函数来标记域的数据报，以便在下一次调用`ecrt_master_send()`时进行交换
+ 声明：`void ecrt_domain_queue(ec_domain_t *domain);`

#### `ecrt_master_send`

+ 简介：发送队列中的所有数据报。
  + 该方法获取所有已排队等待传输的数据报，将它们放入帧中，并将它们传递给以太网设备进行发送。
  + 必须在`ecrt_master_activate()`返回后由应用程序循环调用。
+ 声明：`void ecrt_master_send(ec_master_t *master);`

#### `ecrt_domain_state`

+ 简介：读取域的状态。
  + 在给定的\a状态结构中存储域状态。
  + 利用该方法，可以实时监控过程数据交换情况。
+ 声明：`void ecrt_domain_state(const ec_domain_t *domain, ec_domain_state_t *state);`
+ 参数：
  + `domain`  --  域
  + `state`   --  指向用于存储信息的状态对象的指针。

#### `ecrt_master_state`

+ 简介：读取当前主站的状态。
  + 在给定的\a状态结构中存储主站状态。
  + 此方法返回一个全局状态。对于冗余总线拓扑中特定于链路的状态，请使用`ecrt_master_link_state()`方法。
+ 声明：`void ecrt_master_state(const ec_master_t *master, ec_master_state_t *state);`
+ 参数：
  + `master`  --  主站
  + `state`   --  指向用于存储信息的状态对象的指针

#### `ecrt_slave_config_state`

+ 简介：输出从站配置的状态。
  + 在给定的\a状态结构中存储状态信息。状态信息由主状态机更新，因此可能需要几个周期，直到它发生变化。
  + 如果需要实时监控进程数据交换的状态，则应该使用`ecrt_domain_state()`。
+ 声明：`void ecrt_slave_config_state(const ec_slave_config_t *sc, ec_slave_config_state_t *state);`
+ 参数：
  + `sc`  --  从站配置
  + `state`  --  需要写入的状态对象

##  公式

+ 编码器增量 enc 转换 关节位置 rad （弧度）
  + `rad = (double) (enc - offset) / (double) (gear_ratio * enc_size) * (2 * PI)`

+ 关节位置 rad （弧度） 转换 编码器增量 enc
  + `enc = (int) (rad) / (2.0 * PI) * (gear_ratio * enc_size) + offset`

+ 弧度 rad 和 角度 deg 的变换
  + `deg = rad * (180 / PI)`

+ 角度 deg 和 弧度 rad 的变换
  + `rad = deg * (PI / 180)`

## 日志代码位置

+ `----status_word_:0x0,control_word:0x0---`
  + 输出的代码位置：
    + `arwen/include/ecat/ecat_taike.h` 39行

+ `Taike_POS: 5 , Taike_STATE: Fault` 
  + 输出代码位置：
    + `arwen/include/ecat/ecat_taike.h` 100行

+ `Domain: WC 7` 319行
  + 输出代码位置：
    + `arwen/src/Ecat/Ecat_Master.cpp` 319行

+ `I20230130 11:40:28.236125  5564 planning.cpp:504] No new point in buffer!` 
  + 输出代码位置：
    + `arwen/src/planning/planning.cpp` 504行

+ `Command joint position lower overrun` 
  + 输出代码位置：
    + `arwen/src/planning/security_module.cpp` 32行
  + 简介：指挥联合位置下超限

+ `Joint num : 3 Command joint position upper overrun!` 
  + 输出代码位置
    + `arwen/src/planning/security_module.cpp` 26行
  + 原因：安全模块检测到了下发的指令超出了约束
  + 解决办法：
    + 在文件：`arwen/src/protocol/configuration/manipulator.cpp` 中，把除以2的去掉就是关键可以转动正负180度

+ `The velocity is a negtive value:0` 
  + 输出代码位置：
    + `arwen/src/planning/curves/double_s_stop.cpp` 76行
  + 简介：速度是一个负值:0

+ `delta_pos.norm : 0.194793` 
  + 输出代码位置：
    + `arwen/src/planning/planner/move_line.cpp` 74行

+ `KDL error: The gradient of E towards the joints is to small`
  + 输出代码位置：
    + `arwen/src/solver/ik_solver_pos_lma.cpp` 55行
  + 简介：E向关节方向的梯度太小

+ `KDL error: The joint position increments are to small` 
  + 输出代码位置：
    + `arwen/src/dynamics/solver/ik_solver_pos_lma.cpp` 55行
  + 简介：关节位置增量太小

+ `singular point! please choose another point!` 
  + 输出代码位置：
    + `arwen/src/planning/planning.cpp`  682行
  + 简介：奇异点!请选择另一个点!

+ `Domain: State 0`
  + 输出代码位置：
    + `arwen/src/ecat/ecat_master.cpp` 313行

+ `Taike_POS: 5 , Taike_STATE: Switch on Disabled`
  + 输出代码位置：
    + `arwen/include/ecat/ecat_taike.h` 100行

---

## demo_webserver.cc 代码分析

### 读取从站信息

+ 每个从站，使用一个类`EcatTaike`的对象描述，六个从站放到一个存放数据类型为类`EcatTaike`类型的数组

+ planner 应该有获取机械臂当前状态信息的接口

### Planning

+ class Planning
+ 成员函数：
  + `Init()`
  + `ProcessFrame()`
  + `IsRunning()`
  + `MoveJ()`
  + `MoveL()`
  + `Stop()`
  + `SpeedJ()`
  + `SpeedL()`
  + `StopRelease()`
  + `getStopFlag()`
  + `SetVirtualWall()`

+ `const bool planner.IsRunning()` ： 判断机械臂是否在运行，
  + 如果在运行，就返回 true，这个时候就不能执行其他指令；
  + 如果不在运行，就返回 false，这个时候才可以执行其他指令

+ `const bool planner.getStopFlag()` ： 获取结束标志
  + 如果设置了结束标志，则返回 true，这个时候就表示机械臂已经停止工作，不能再执行其他指令
  + 如果没有设置结束标志，则返回 false，这个时候就表示机械臂还在工作，可以执行其他指令

+ `void setStopFlag(bool flag)` ： 设置结束标志
  + 如果传入的flag为true，表示设置了结束标志
  + 如果传入的flag为false，表示没有

---

### FkSolverPosKdl

+ `class arwen::dynamics::solver::FkSolverPosKdl`
+ 成员函数：
  + `Init()`
  + `JntToCart()`
    + 计算 机械臂从关节空间坐标到笛卡尔空间坐标的正运动学

### FkSolverPosRecursive

+ `class arwen::dynamices::solver::FkSolverPosRecursive`
+ 简介：计算一般运动链(arwen::dynamics::chain:: chain)从关节空间到笛卡尔空间位置变换的递归正向位置运动学算法。

+ 初始化solvers，示例：
  ```
    std::shared_ptr<arwen::dynamics::chain::Chain> chain = 
         std::make_shared<arwen::dynamics::chain::Chain>(Manipulator());
    FkSolverPosRecursive fk_solver_pos;
    fk_solver_pos.Init(chain);
    IkSolverPosLma ik_solver_pos_lma;
    ik_solver_pos_lma.Init(chain);
  ``` 

### Pose

+ `class arwen::dynamics::common::Pose`
+ 简介：姿态是框架的另一种表达方式。旋转部分表示为矢量，方向与旋转轴对齐，范数为旋转角度。

+ Pose， 里面有 p 和 rot， 分别对应位置和姿态

+ 示例代码：
  ```
    Frame frame_init;
    Pose pose_init;
    fk_solver_pos.JntToCart(q_init, frmae_init);
    pose_init = frame_init.ToPose();
    std::cout << "q: " << q_init.data.transpose() << std::endl;
    std::cout << "pose: " << Pose2Vec(pose_init).transpose() << std::endl;
  ``` 

### Frame

+ `class arwen::dynamics::common::Frame`
+ 该类表示相对于 {Ref} 的笛卡尔坐标 {Obj}。
+ 换句话说，它表示从 {Ref} 到 {Obj} 的齐次转换。齐次矩阵形式的帧为 frame {Ref} {Obj} = [旋转 {Ref} {Obj}， p{Ref} {Obj};0, 1]

### Rotation

+ `class arwen::dynamics::common::Rotation`
+ 该类表示笛卡尔空间中的旋转。
+ 旋转矩阵 rotate {Rel} {Obj} (我们称之为从 {Ref} 到 {Obj} 的旋转)表示 {Obj} 相对于 {Rel} 的方向。
+ 换句话说，它表示从 {Obj} 到 {Ref} 的旋转。具有以下属性:`旋转{A}{B} =旋转逆{B}{A} =旋转转置{B}{A}旋转{A}{C} =旋转{A}{B}*旋转{B}{C} p{A} = 旋转{A}{B}*p{B}`

### Vector

+ `class arwen::dynamics::common::Vector`
+ 简介：笛卡尔空间中常见的三维向量。
+ 向量 p{Ref}{Obj} 表示指向 {Ref} 中 {Obj} 原点的向量。两个向量的叉乘可以表示为第一个向量和第二个向量的斜对称矩阵的点积。

### ik_solver_pos_lma.h

#### CartToJnt()

+ 简介：计算逆位置运动学，从直角坐标（笛卡尔空间坐标）到关节坐标。
+ 声明：`bool CartToJnt(const JointVector &q_init, const Frame& p_in, JointVector& q_out) final;`
+ 参数：
  + `q_init`  --  关节坐标的初始猜测。
  + `p_in`    --  输入的笛卡尔空间坐标
  + `q_out`   --  输出的关节空间坐标引用
+ 返回值：
  + 成功  --  true
  + 失败  --  false

### ik_solver_vel_pinv_givens.h

+ 简介：一种基于广义伪逆的速度逆运动学求解方法，用于计算一般链的速度从笛卡尔空间到关节空间的变换。它使用基于户主轮换的svd计算。
+ 声明：`class IkSolverVelPinvGivens final : public IkSolverVel `

### ik_solver_vel_pinv_nso.h

+ 简介：一种基于广义伪逆的速度逆运动学求解方法，用于计算一般链的速度从笛卡尔空间到关节空间的变换。它使用基于户主轮换的svd计算。
+ 声明：`class IkSolverVelPinvNso final : public IkSolverVel`

### ik_solver_vel_pinv.h

+ 简介：一种基于广义伪逆的速度逆运动学求解方法，用于计算一般链的速度从笛卡尔空间到关节空间的变换。它使用基于户主轮换的svd计算。
+ 声明：`class IkSolverVelPinv final : public IkSolverVel`

### ik_solver_vel_wdls.h

+ 简介：一种基于加权伪逆和阻尼最小二乘的速度逆运动学求解方法，用于计算一般链的速度从笛卡尔空间到关节空间的变换。它使用基于户主轮换的svd计算。
+ 声明：`class IkSolverVelWdls final : public IkSolverVel `

### manipulator.h

+ 简介：所有关于机器人硬件配置的协议
+ 通过定义宏来分别操控不同的机械臂，目前有的宏定义为：
  + `#define TAIKE_10KG`
  + `#define TAIKE_3KG`
  + `#define New_arm_10kg`

+ 函数：
  + `Chain Manipulator();`

+ 10kg机械臂需要配置约束参数，也就是在每个关节下面增加如下一行代码：
  + `joint_constraints = dynamics::components::Joint::Constraints(M_PI / 2.0, -M_PI / 2.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 2.0, -2.0);`
  + 如果不加，则安全模块会抛出异常：`Joint num : 0 Command joint position lower overrun!`

## WebServer

### 1.1 架构设计

+ 功能 | 业务

+ 分层 | 分模块

+ 现在的设计思路：
  + 事件处理函数，事件监听函数都封装在了一个类中

+ 新的设计思路：
  + 暂时不封装成类，而是将使用到的函数都分开在不同的源文件中实现，统一在demo中调用

+ 启动服务，监听事件的发生
  + 输入：
    + 监听地址
    + struct mg_mgr
    + struct mg_connection
+ 事件处理函数
  + 处理的事件有：
    + WebSocket连接建立时
      + 创建一个实时线程`rt_task_create`，定时向客户端发送机械臂的状态信息
    + WebSocket连接断开时
      + 销毁该连接建立时创建的实时线程`rt_task_delete`
    + 接收到一个HTTP消息时
      + 当请求是`/websocket`时，升级该HTTP连接到WebSocket连接
      + 当请求是`/api/*`时，针对相应的接口，调用相应的函数处理请求

### 1.2 前后端通信

+ 前端发送一个ping
+ 后端接收，判断消息为ping之后，发向前端发送 flag = true，表示可以发送机械臂信息
+ 前端接收flag消息，如果为true，就发送一个目标点位置，
+ 后端接收的消息如果为目标点位置，就执行如下动作
  + 首先，启动一个线程，定时发送机械臂状态信息
  + 其次，调用moveJ使机械臂运动到目标点位置
  + 最后，如果运行完成，退出定时发送状态信息的线程，并发送flag = false

### 1.3 libjsoncpp 第三方库的使用

+ 在test目录下的demo文件的使用方法：
  + 首先，添加一行代码：`link_directories(/home/user/zhangjunyi/arwen/third_party/lib/jsoncpp)`
  + 然后，在for循环中，添加一行：`target_link_libraries($(example) jsoncpp)`

### 1.3 模块

#### 1.3.1 手动控制(点动界面)

+ HTTP通信

+ 接口:`/api/control/manual/jointPosition/movj`
+ 发送的数据为：`{"movj":[10, 20, 30, 40, 50, 60]}`

+ 接口：`/api/control/manual/tcpPosition/movj`
+ 发送的数据为：`{"movj":[0.5, 0.7, 0.9, 10, 10, 10]}`

#### 1.3.2 精确控制

+ WebSocket通信，发送的数据为
  + `{"jointSpace":[10, 20, 30, 40, 50, 60]}   // {"jointSpace":[joint_rad1, joint_rad2, joint_rad3, joint_rad4, joint_rad5, joint_rad6]}`  
  + `{"tcpSpace":[0.5, 0.9, 0.7, 10, 10, 10]}  // {"tcpSpace":[x, y, z, Rx, Ry, Rz]}`


#### 1.3.3 定时同步

+ ~~旧的WebSocket通信，发送的数据为~~
  + ~~`{"JointInfo":[10.0, 20.0, 30.0, 40.0, 50.0, 60.0]}`~~

+ 新的数据格式：关节空间位置信息 + 笛卡尔空间位姿信息 + 机械臂工作状态
  ``` 
  "Info":
    {
      "Running": True | False，
      "JointInfo":[joint1, joint2, joint3, joint4, joint5, joint6],
      "CartInfo":[x, y, z, Rx, Ry, Rz],
    }
  ``` 