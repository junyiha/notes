## 段错误:`Segmentation fault`

+ 段错误是什么？
  + 段错误是指访问的内存超出了系统给这个程序所设定的内存空间。

+ 段错误产生的原因
  1. 访问不存在的内存地址
  2. 访问系统保护的内存地址
  3. 访问制度的内存地址
  4. 栈溢出
  5. delete使用错误

## 内存问题

+ 内存问题始终是C++程序员需要去面对的问题，这也是C++语言门槛高的原因之一

+ 常见的内存问题：
  1. 内存重复释放，出现`double free`时，通常是由于这种情况导致的
  2. 内存泄漏，分配的内存忘记释放
  3. 内存越界使用，使用了不该使用的内存
  4. 使用了无效指针
  5. 空指针，对一个空指针进行操作 

+ 内存越界，引起的问题有极大的不确定性，有时大，有时小，有时可能不会对程序的运行产生影响，正是这种不易复现的错误，才是最致命的。
+ 内存越界，通常可能会造成如下几种情况：
  1. 破坏了堆中的内存分配信息数据，特别是动态分配的内存块的内存信息数据。因为操作系统在分配和释放内存块时需要访问该数据，一旦该数据被破坏，可能会出现一下几种情况：
        ```
        *** glibcdetected *** free(): invalid pointer:
        *** glibcdetected *** malloc(): memory corruption:
        *** glibcdetected *** double free or corruption (out): 0x00000000005c18a0 ***
        *** glibcdetected *** corrupted double-linked list: 0x00000000005ab150***
        ```    
  2. 破坏了程序自己的其他对象的内存空间，这种破坏会影响程序执行的不正确性，当然也会诱发`coredump`，如破坏了指针数据
  3. 破坏了空闲内存块
  4. 通常，代码错误被激发是偶然的，也就是说之前的程序一切正常，可能由于为类增加了两个成员变量，或者改变了某一部分代码，`coredump`就频繁发生，而增加的代码绝不会有任何问题，这时应该考虑**是否是某些内存被破坏了**。

+ 注意事项：
  1. **出现段错误时**，首先应该想到段错误的定义，从它出发考虑引发错误的原因
  2. **在使用指针时**，定义了指针后记得初始化指针，在使用的时候记得判断是否为NULL
  3. **在使用数组时**，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等
  4. **在访问变量时**，注意变量所占地址空间是否已经被程序释放
  5. **在处理变量时**，注意变量的格式控制是否合理等

## 核心转储:`core dumped`

+ 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的**内存状态**记录下来，保存在一个文件中，这种行为就叫做`Core Dump`（中文有的翻译成 核心转储）
+ 可以认为`core dump`是内存快照，但实际上，除了内存信息之外，还有一些关键的程序运行状态也会同时`dump`下来，例如寄存器信息（包括程序指针，栈指针），内存管理信息，其他处理器和操作系统状态和信息。
+ `Segmentation fault (core dumped)`通常是内存未正常操作造成。空指针，野指针的读写操作，数组越界访问，破坏常量等。

+ 打开`core dump`功能
  1. 在终端输入命令`ulimit -c`，输出结果为0，表示关闭`core dump`，即当程序异常终止时，也不会生成`core dump`文件
  2. 可以使用命令`ulimit -c unlimited`来开启`core dump`功能，并且不限制`core dump`文件的大小；如果需要限制文件的大小，将`unlimited`换成想生成文件的存储上限，单位为blocks(KB)
  3. 用上面命令只会对当前终端环境有效，如果想要永久生效，需要设置文件`/etc/security/limits.conf`文件
  4. 默认生成的`core`文件保存在可执行文件所在的目录下，文件名就为`core`
  5. 修改文件`/proc/sys/kernel/core_uses_pid`文件可以让生成`core`文件名自动加上pid号
  6. 修改文件`/proc/sys/kernel/core_pattern`控制生成`core`文件保存的位置以及文件名格式