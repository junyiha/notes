---
category: OpenCV
date: 2024-05-22 09:00:00 +0800
layout: post
title: opencv_3_02_常用函数
tag: OpenCV
---
## 简介

+ OpenCV 常用的函数

## OpenCV cv::samples::findFile() 详解

`cv::samples::findFile()` 是 OpenCV 中的一个实用函数，用于查找示例文件或数据文件的路径。在进行示例代码编写或加载数据文件时，经常需要使用这个函数来确保程序能够正确地找到所需的文件。

以下是对 `cv::samples::findFile()` 的解释：

```cpp
std::string findFile(const std::string& filename, bool required = true, bool silentMode = true);
```

- `filename` 参数是要查找的文件名或文件路径。
- `required` 参数指示是否将文件视为必需。如果为 true，则函数在找不到文件时会抛出一个异常；如果为 false，则函数会返回空字符串。
- `silentMode` 参数指示是否在查找文件时静默模式。如果为 true，则函数在找不到文件时不会输出警告消息；如果为 false，则会输出警告消息。

函数返回一个字符串，代表找到的文件的路径。如果文件找不到并且 `required` 参数为 false，则返回一个空字符串。

`cv::samples::findFile()` 函数通常用于示例代码中，以确保示例文件或数据文件能够在不同的开发环境中正确地加载。例如，在图像处理示例中，可以使用 `cv::samples::findFile()` 函数来加载示例图像文件。

以下是一个示例用法：

```cpp
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <iostream>

int main() {
    std::string filename = cv::samples::findFile("lena.jpg");
    if (filename.empty()) {
        std::cerr << "Failed to find the file 'lena.jpg'" << std::endl;
        return -1;
    }

    cv::Mat image = cv::imread(filename);
    if (image.empty()) {
        std::cerr << "Failed to load the image" << std::endl;
        return -1;
    }

    cv::imshow("Image", image);
    cv::waitKey(0);

    return 0;
}
```

这段代码首先使用 `cv::samples::findFile()` 函数查找名为 "lena.jpg" 的图像文件，然后加载并显示它。

## OpenCV cv::merge() 函数 详解

`cv::merge()` 函数是 OpenCV 库中的一个函数，用于将多个单通道图像合并为一个多通道图像。例如，将三个单通道的图像（比如分别代表 RGB 三个通道的图像）合并成一个三通道的彩色图像。下面是对 `cv::merge()` 函数的详解：

### 函数原型
```cpp
void cv::merge(
    InputArrayOfArrays mv,
    OutputArray dst
)
```

### 参数说明
- `mv`：包含多个单通道图像的数组。每个单通道图像都会被合并到输出的多通道图像中。
- `dst`：输出的多通道图像。

### 功能
`cv::merge()` 函数用于将多个单通道图像合并成一个多通道图像。例如，如果输入是三个单通道的图像，则函数将会生成一个三通道的彩色图像，其中每个通道分别对应输入数组中的一个单通道图像。

### 注意事项
- 输入数组 `mv` 中的每个单通道图像的尺寸和数据类型必须相同。
- 输出的多通道图像 `dst` 的通道数将与输入数组 `mv` 的长度相同。
- 输出的多通道图像 `dst` 的尺寸与输入数组 `mv` 中的单通道图像的尺寸相同。

### 示例
```cpp
cv::Mat blueChannel = cv::imread("blue_channel.jpg", cv::IMREAD_GRAYSCALE);
cv::Mat greenChannel = cv::imread("green_channel.jpg", cv::IMREAD_GRAYSCALE);
cv::Mat redChannel = cv::imread("red_channel.jpg", cv::IMREAD_GRAYSCALE);

std::vector<cv::Mat> channels = {blueChannel, greenChannel, redChannel};

cv::Mat mergedImage;
cv::merge(channels, mergedImage);
```

在这个示例中，`blueChannel`、`greenChannel` 和 `redChannel` 是三个单通道的图像，分别代表了蓝色通道、绿色通道和红色通道。通过 `cv::merge()` 函数将这三个单通道图像合并成一个三通道的彩色图像 `mergedImage`。

`cv::merge()` 函数是 OpenCV 中用于合并单通道图像的常用函数之一，它为图像处理提供了便利性和灵活性，可以方便地将单通道图像合并成多通道图像。

## OpenCV cv::split() 函数 详解

`cv::split()` 函数是 OpenCV 库中的一个函数，用于将多通道图像分离为各个单通道图像。例如，将一个三通道的彩色图像分离成三个单通道的图像。下面是对 `cv::split()` 函数的详解：

### 函数原型
```cpp
void cv::split(
    InputArray src,
    OutputArrayOfArrays mv
)
```

### 参数说明
- `src`：输入的多通道图像。
- `mv`：包含输出图像的数组。每个单通道图像都会被存储在这个数组中。

### 功能
`cv::split()` 函数用于将多通道图像分离成各个单通道图像。例如，如果输入是一个三通道的彩色图像，则函数将会生成三个单通道的图像，每个通道分别存储在输出数组中。

### 注意事项
- 输入图像可以是多通道的，例如 RGB 彩色图像或者 HSV 图像。
- 输出数组 `mv` 中的每个单通道图像的尺寸与输入图像的尺寸相同。
- 输出数组 `mv` 中的每个单通道图像的数据类型与输入图像的数据类型相同。
- 输出数组 `mv` 中的每个单通道图像可以单独访问，进行后续的处理或显示。

### 示例
```cpp
cv::Mat src = cv::imread("input.jpg", cv::IMREAD_COLOR);
std::vector<cv::Mat> channels;
cv::split(src, channels);

cv::Mat blueChannel = channels[0];  // 蓝色通道
cv::Mat greenChannel = channels[1]; // 绿色通道
cv::Mat redChannel = channels[2];   // 红色通道
```

在这个示例中，`src` 是一个输入的彩色图像，通过 `cv::split()` 函数将其分离为三个单通道图像，分别存储在 `channels` 中。然后，可以通过数组索引来访问各个通道，例如 `channels[0]` 表示蓝色通道。

`cv::split()` 函数是 OpenCV 中用于分离多通道图像的常用函数之一，它为图像处理提供了灵活性和便利性，可以方便地对各个通道进行单独处理。

## OpenCV cvtColor() 函数 详解

`cvtColor()` 是 OpenCV 库中的一个函数，用于执行图像颜色空间转换。它可以将一种颜色空间的图像转换为另一种颜色空间，例如将 RGB 图像转换为灰度图像或将 BGR 图像转换为 HSV 图像。下面是对 `cvtColor()` 函数的详解：

### 函数原型
```cpp
void cv::cvtColor(
    InputArray src,
    OutputArray dst,
    int code,
    int dstCn = 0
)
```

### 参数说明
- `src`：输入图像。
- `dst`：输出图像，转换后的结果将存储在这里。
- `code`：指定要执行的颜色空间转换类型的整数编码。例如，`cv::COLOR_BGR2GRAY` 表示从 BGR 到灰度图像的转换，`cv::COLOR_BGR2HSV` 表示从 BGR 到 HSV 的转换，以此类推。完整的转换类型列表可以在 OpenCV 文档中找到。
- `dstCn`：可选参数，指定输出图像的通道数，通常为0（默认值），表示与输入图像的通道数相同。

### 功能
`cvtColor()` 函数用于将图像从一个颜色空间转换为另一个颜色空间。它可以执行各种标准的颜色空间转换，例如 RGB 到灰度、RGB 到 HSV、BGR 到 Lab 等等。

### 注意事项
- 在执行颜色空间转换时，像素值可能会超出目标图像类型的范围。因此，输出图像通常需要使用适当的数据类型来存储转换后的像素值。
- `cvtColor()` 函数对输入图像和输出图像的尺寸没有限制，但是输入图像和输出图像的通道数需要匹配转换的类型。

### 示例
```cpp
cv::Mat src = cv::imread("input.jpg", cv::IMREAD_COLOR);
cv::Mat dst;
cv::cvtColor(src, dst, cv::COLOR_BGR2GRAY); // 将BGR图像转换为灰度图像
```

在这个示例中，`src` 是一个输入的彩色图像，它会被转换为灰度图像，并将结果存储在 `dst` 中。

`cvtColor()` 函数是 OpenCV 中执行图像颜色空间转换的常用函数之一，它为图像处理提供了强大的功能，包括颜色分析、特征提取和目标识别等方面的应用。

## OpenCV convertTo() 函数 详解

`convertTo()` 是 OpenCV 库中的一个函数，用于执行图像数据类型的转换。它可以将一种图像数据类型转换为另一种，例如从一个单精度浮点数类型转换为无符号8位整型类型。下面是对 `convertTo()` 函数的详解：

### 函数原型
```cpp
void cv::Mat::convertTo(
    OutputArray m,
    int rtype,
    double alpha = 1,
    double beta = 0
) const
```

### 参数说明
- `m`：输出图像，转换后的结果将存储在这里。
- `rtype`：输出图像的数据类型，例如 `CV_8U`、`CV_32F` 等，可以通过 `CV_8U` 表示8位无符号整数，`CV_32F` 表示32位单精度浮点数，以此类推。
- `alpha`：可选参数，是乘法因子，用于缩放转换后的像素值。
- `beta`：可选参数，是加法因子，用于平移转换后的像素值。

### 功能
`convertTo()` 函数用于将一个 `Mat` 对象中的像素值类型转换为指定的数据类型。该函数执行的操作可以表达为以下公式：

\[ \text{dst}(x,y) = \text{saturate\_cast} \left( \alpha \cdot \text{src}(x,y) + \beta \right) \]

其中，\(\text{dst}(x,y)\) 是输出图像中位置 \((x,y)\) 处的像素值，\(\text{src}(x,y)\) 是输入图像中位置 \((x,y)\) 处的像素值。\(\alpha\) 和 \(\beta\) 是函数的参数，用于缩放和平移像素值。`saturate_cast` 是一个函数，用于确保结果在特定数据类型的有效范围内。 

### 注意事项
- 转换后的像素值可能会超出目标数据类型的有效范围，因此需要进行适当的饱和处理，`convertTo()` 函数会自动执行这个操作。
- 可以通过 `alpha` 和 `beta` 参数来控制转换的线性缩放和平移操作，如果不需要，可以将它们设置为默认值。

### 示例
```cpp
cv::Mat src = cv::imread("input.jpg", cv::IMREAD_COLOR);
cv::Mat dst;
src.convertTo(dst, CV_32F); // 转换为32位浮点型图像
```

在这个示例中，`src` 是一个输入的图像，它会被转换为32位浮点型图像，结果存储在 `dst` 中。

`convertTo()` 函数是 OpenCV 中用于数据类型转换的重要工具，可以方便地处理不同数据类型之间的图像操作。

## OpenCV cv::putText()  函数 详解

`cv::putText()` 是 OpenCV 中用于在图像上绘制文本的函数。该函数可以在图像上添加指定的字符串，以及指定的字体、颜色、大小和其他样式。下面是该函数的详细说明：

```cpp
void cv::putText(
    cv::InputOutputArray img, // 输入/输出图像
    const String& text, // 要绘制的文本字符串
    cv::Point org, // 文本起始位置的坐标（左下角）
    int fontFace, // 字体类型，例如：cv::FONT_HERSHEY_SIMPLEX、cv::FONT_HERSHEY_PLAIN 等
    double fontScale, // 字体大小的缩放系数
    cv::Scalar color, // 文本颜色，如 cv::Scalar(255, 0, 0) 表示蓝色
    int thickness = 1, // 文本的粗细，默认为 1
    int lineType = LINE_8, // 文本的线条类型，默认为 8 连通线条
    bool bottomLeftOrigin = false // 如果为 true，则表示坐标 org 是文本左下角的位置，否则是左上角的位置，默认为 false
);
```

参数说明：

- `img`：输入/输出图像，通常是 `cv::Mat` 类型，表示要在其上绘制文本的图像。
- `text`：要绘制的文本字符串。
- `org`：文本起始位置的坐标，即文本左下角的位置。如果 `bottomLeftOrigin` 参数为 false，则表示文本左上角的位置。
- `fontFace`：字体类型，可以是预定义的字体类型，如 `cv::FONT_HERSHEY_SIMPLEX`、`cv::FONT_HERSHEY_PLAIN` 等。
- `fontScale`：字体大小的缩放系数。
- `color`：文本颜色，通常使用 `cv::Scalar` 类型表示，如 `cv::Scalar(255, 0, 0)` 表示蓝色。
- `thickness`：文本的线条粗细，默认为 1。
- `lineType`：文本的线条类型，默认为 8 连通线条。
- `bottomLeftOrigin`：如果为 true，则表示坐标 `org` 是文本左下角的位置，否则是左上角的位置，默认为 false。

注意：在使用 `putText()` 函数之前，确保图像类型支持文本绘制操作，即图像的深度必须为 `CV_8U` 或 `CV_32F` 类型，而通道数必须为 1 或 3。

## OpenCV cv::imdecode() 函数 详解 中文

`cv::imdecode()` 是 OpenCV 库中的一个函数，用于将图像数据解码为 OpenCV 中的 `cv::Mat` 对象。该函数通常用于从内存中读取图像数据，而不是从文件中读取。

以下是 `cv::imdecode()` 函数的一些关键参数及其解释：

- **参数1 (`buf`)：** 这是一个包含图像数据的缓冲区。通常情况下，这是一个 `uchar` 类型的数组，存储着图像的原始数据。

- **参数2 (`flags`)：** 这是一个整数参数，用于指定如何解码图像。常用的标志包括 `cv::IMREAD_COLOR`（默认值，将图像以BGR颜色格式加载）、`cv::IMREAD_GRAYSCALE`（将图像以灰度格式加载）和 `cv::IMREAD_UNCHANGED`（加载图像的所有通道，包括 Alpha 通道）。

- **返回值：** 函数返回一个 `cv::Mat` 对象，该对象包含解码后的图像数据。

`cv::imdecode()` 函数的调用示例：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    // 读取图像数据到内存中
    std::vector<uchar> data; // 图像数据的缓冲区
    // 假设 data 被填充了图像数据

    // 解码图像数据
    cv::Mat image = cv::imdecode(data, cv::IMREAD_COLOR);

    // 检查图像是否成功解码
    if (!image.empty()) {
        // 成功加载图像，进行进一步的处理
        cv::imshow("Decoded Image", image);
        cv::waitKey(0);
    } else {
        // 加载失败
        std::cerr << "Failed to decode image." << std::endl;
    }

    return 0;
}
```

这个例子演示了如何使用 `cv::imdecode()` 函数将图像数据解码为 `cv::Mat` 对象，并在图像成功加载时显示它。

## OpenCV cv::imencode() 详解

`cv::imencode()` 函数是 OpenCV 库中用于将图像编码为特定格式（如JPEG、PNG等）的函数。它可以将 `cv::Mat` 中存储的图像数据编码为指定格式的图像，并将编码后的图像数据存储到内存缓冲区中。

该函数的原型为：

```cpp
bool imencode(const String& ext, InputArray img, std::vector<uchar>& buf, const std::vector<int>& params = std::vector<int>());
```

其中参数含义如下：

- `ext`：字符串参数，用于指定输出图像的格式，例如 `".jpg"`、`".png"` 等。
- `img`：`cv::Mat` 对象，包含待编码的图像数据。
- `buf`：`std::vector<uchar>` 类型的输出参数，用于存储编码后的图像数据。
- `params`（可选）：一个可选的参数向量，用于指定图像编码的参数，如 JPEG 质量、PNG 压缩级别等。具体参数因图像格式而异。

下面是一些示例代码，展示了如何使用 `cv::imencode()` 函数将图像编码为 JPEG 格式并存储到内存中的 `std::vector<uchar>` 中：

```cpp
#include <opencv2/opencv.hpp>
#include <vector>

int main() {
    cv::Mat image = cv::imread("path_to_your_image.jpg");

    if (image.empty()) {
        std::cout << "无法读取图像文件\n";
        return -1;
    }

    std::vector<uchar> buffer;
    std::vector<int> params;
    params.push_back(cv::IMWRITE_JPEG_QUALITY); // 设置 JPG 质量
    params.push_back(95); // 设置 JPG 图像质量，可根据需要调整

    // 将图像编码为 JPG 格式并保存到内存
    bool success = cv::imencode(".jpg", image, buffer, params);

    if (success) {
        // buffer 中现在存储了编码后的 JPG 数据，可以进行保存或其他处理
        // 例如，将内存中的 JPG 数据保存到文件
        FILE *file = fopen("saved_image.jpg", "wb");
        if (file != NULL) {
            fwrite(buffer.data(), sizeof(uchar), buffer.size(), file);
            fclose(file);
            std::cout << "图像保存成功\n";
        } else {
            std::cout << "无法保存图像\n";
            return -1;
        }
    } else {
        std::cout << "图像编码失败\n";
        return -1;
    }

    return 0;
}
```

在示例中，`cv::imencode()` 将 `cv::Mat` 中的图像数据编码为 JPG 格式，并将编码后的数据存储在 `buffer` 中。之后，将 `buffer` 中的数据写入文件 `"saved_image.jpg"`。

要注意，在使用 `cv::imencode()` 函数之前，需要确保已经正确读取了图像数据并存储在 `cv::Mat` 对象中。