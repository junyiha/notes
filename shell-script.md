### `#!` : 
+ 它是一个约定的标记,告诉系统这个脚本需要什么解释器来执行,即使用哪一种shell

### Shell变量:
+ 变量名和等号之间不能有空格
+ 变量的命名只能使用英文字母,数字和下划线,首个字符不能以数字开头
+ 中间不能有空格,可以使用下划线
+ 不能使用标点符号
+ 不能使用bash里的关键字(可用help命令查看保留关键字)
+ 只有在使用变量的时候才加美元符,且推荐给所有变量加上花括号

只读变量:使用`readonly`命令可以讲变量定义为只读变量,只读变量的值不能被更改
删除变量:使用`unset`命令可以删除变量,变量被删除后不能再次使用,unset命令不能删除只读变量

### 变量类型:运行shell时,会同时存在三种变量:
1. **局部变量**:局部变量在脚本或命令中定义,仅在当前shell实力中有效,其他shell启动的程序不能访问局部变量
2. **环境变量**:所有的程序,包括shell启动的程序,都能访问环境变量,有些程序需要环境变量来保证其正常运行,必要的时候shell脚本也可以来定义环境变量
3. **shell变量**:shell变量由shell程序设置的特殊变量.shell变量中有一部分是环境变量,有一部分是局部变量,这些变量保证了shell的正常运行.

### Shell字符串

字符串可以用单引号,也可以用双引号,也可以不用引号
+ 单引号
      1. 单引号里的任何字符都会原样输出,**单引号字符串中的变量是无效的**;
      2. 单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行),但可成对出现,作为字符串拼接使用
+ 双引号
      1. 双引号里可以有变量
      2. 双引号里可以出现转义字符

+ 获取字符串长度:`string="abcd"; echo ${#string}`
+ 提取子字符串:`string="runoob"; echo ${string:1:4}  # 输出 unoo`
+ 查找子字符串:```string="runoob is a great site"; echo `expr index "$string" io```

### Shell数组

+ bash支持一维数组,不支持多维数组,并且没有限定数组的大小
+ 类似于C语言,数组元素的下标由0开始编号.获取数组中的元素要利用下标,下标可以使整数或算数表达式,其值应该大于或等于0
+ 定义数组:在shell中,用括号来表示数组,数组元素用"空格"符号分割开,定义数组的一般形式为:`数组名=(值1 值2 ... 值n)`
+ 读取数组:一般格式为`${数组名[下标]}`, 使用`@`符号可以获取数组中所有的元素
+ 获取数组的长度:
      + `length=${#array_name[@]} or length=${#array_name[*]} # 取得数组元素的个数` 
      + `lengthn=${#array_name[n]}  # 取得数组单个元素的长度`

### Shell注释

+ 以`#`开头的行就是注释,会被解释器忽略
+ 通过每一行加一个`#`号来设置多行注释
+ 如果在开发过程中,遇到大段的代码需要临时注释起来,调用的时候取消注释,其解决办法是:把这一段要注释的代码用一对花括号括起来,定义成一个函数,没有地方调用这个函数,这块代码就不会执行,达到了和注释一样的效果
+ 多行注释:
      ```
        :<<EOF
        注释内容...
        注释内容...
        注释内容...
        EOF(注:EOF也可以使用其他的符号,例如!)
      ```
    
+ 输出结果 : hello world
  ```
  cat << EOF

  hello world

  EOF
  ```


### 最常使用的文件描述符(file descriptor, FD):
1. 0 : 是一个文件描述符,表示标准输入(stdin)
2. 1 : 是一个文件描述符,表示标准输出(stdout)
3. 2 : 是一个文件描述符,表示标准错误(stderr)

在标准情况下,这些文件描述符分别与如下设备关联:
1. stdin(0):keyboard 键盘输入,并返回在前端
2. stdout(1):monitor 正确返回值,输出到前端
3. stderr(2):monitor 错误返回值,输出到前端

**>**
+ `>`是重定向符,就是把前面输出的内容重定向到后面指定的位置
+ `>`前可以加数字来说明把什么内容重定向到文件中,默认是把标准输出重定向到文件中
  
**&**
+ `&`是一个描述符,如果1或2前不加`&`,会被当成一个普通文件
+ 1>&2 : 意思是把标准输出重定向到标准错误
+ 2>&1 : 意思是把标准错误输出重定向到标准输出
+ &>filename :　意思是把标准输出和标准错误输出都重定向到文件`filename`中

### Shell传递参数

+ 在执行Shell脚本时,向脚本传递参数,脚本内获取参数的格式为:`$n`
+ `n`代表一个数字,1为执行脚本的第一个参数;2为执行脚本的第二个参数,以此类推...

**处理参数的特殊字符**:
+ `@#` 传递到脚本的参数个数
+ `$*` 以一个单字符串显示所有向脚本传递的参数
+ `$$` 脚本运行的当前进程的ID号
+ `$!` 后台运行的最后一个进程的ID号
+ `$@` 与`$*`相同,但是使用时加引号,并在引号中返回每个参数
+ `$-` 显示Shell使用的当前选项,与**set命令**功能相同
+ `$?` 显示最后命令的退出状态:0 表示没有错误,其他任何值表示有错误

**关系运算符**
+ 关系运算符只支持数字,不支持字符串,除非字符串的值是数字
+ 常用的关系运算符(a为10, b为20):
  + `-eq`, 检测两个数是否**相等**,相等返回true. 例如:`$a -eq $b`,返回false
  + `-ne`, 检测两个数是否**不相等**,不相等返回true. 例如:`$a -ne $b`,返回ture
  + `-gt`, 检测左边的数是否**大于**右边的,如果是,则返回ture. 例如`$a -gt $b`, 返回false
  + `-le`, 检测左边的数是否**小于**等于右边的,如果是,则返回true. 例如`$a -le $b`,返回true
  + `-lt`, 检测左边的数是否**小于**右边的,如果是,则返回true. 例如`$a -lt $b`,返回ture
  + `-ge`, 检测左边的数是否**大于**等于右边的,如果是,则返回true. 例如`$a -ge $b`,返回false

**-x**
+ `#!/bin/bash -x`, `-x`选项可用来跟踪脚本的执行,是调试shell脚本的强有力工具
+ `-x`选项使shell在执行脚本的过程中把它实际执行的每一个命令行显示出来,并且在行首显示一个`+`号,`+`号后面显示的是经过了变量替换之后的命令行的内容,有助于分析实际执行的是什么命令
+ shell的执行选项除了可以在启动shell时指定外,还可以在脚本中用set命令指定.
  + `set -参数`, 表示启用某选项
  + `set +参数`, 表示关闭某选项

**shell内置的环境变量**
+ `$LINENO`, 代表shell脚本的当前行号,类似于C语言中的内置红`__LINE__`
+ `$FUNCNAME`, 函数的名字,类似于C语言中的内置宏`__func__`,但宏`__func__`只能代表当前所在的函数名,而`$FUNCNAME`的功能更强大,它是一个**数组变量**,其中包含了整个**调用链上所有的函数的名字,所以变量`${FUNCNAME[0]}`代表shell脚本当前正在执行的函数的名字,而变量`${FUNCNAME[1]}`则代表调用函数`${FUNCNAME[0]}`的函数的名字,以此类推
+ `$PS4`,主提示符变量`$PS1`和第二级提示符变量`$PS2`
  + PS(Prompt Sign), 是指命令提示符,
  + 在Linux环境下`$PS1`是终端提示符,我们可以用预设的一些特殊符号来改变`$PS1`变量.
    + PS1变量中各项提示符的含义:
      + `\d`:日期
      + `\H`:完整的主机名称
      + `\h`:仅取主机的第一个名字
      + `\t`:显示时间为24小时格式,如 HH:MM:SS
      + `\T`:显示时间为12小时格式
      + `\A`:显示时间为24小时格式,如 HH:MM
      + `\u`:当前用户的账号名称
      + `\v`:BASH的版本信息
      + `\w`:完整的工作路径名
      + `\W`:最后一个路径名
      + `\$`:提示字符,root用户为#, 普通用户为$

**变量**
+ 变量是一个用来存储数据的实体,由一个变量名和值组成.在Shell中有两种不同类型的变量,分别是Shell变量和环境变量,也被称为局部变量和全局变量
+ 在Bash中只允许创建局部变量,也就是说每个新变量都会自动设置成局部变量.如果希望某个变量成为环境变量,必须使用export命令将局部变量修改为"局部+全局"变量,这可以成为将变量导出到环境中
+ 在Linux中启动一个shell会创建一个进程,修改环境变量后只会对该进程及子进程有效,不会传递到父进程中.要是环境变量对所有的Shell起作用需要修改配置文件.
+ Shell环境中包含很多变量,虽然shell环境变量根据发行版本的不同而不同,但是一般都会包含一下环境变量:
  + `SHELL` : Shell程序的名字
  + `HOME`  : 用户的家目录
  + `LANG`  : 系统语言及字符集
  + `PAGER` : 页输出程序的名字,这经常设置为`/usr/bin/less`
  + `PATH`  : 系统查找命令的路径(由冒号分开的目录列表)
  + `PS1`   : Shell提示符
  + `PWD`   : 当前工作目录
  + `TERM`  : 终端类型
  + `USER`  : 当前用户名
+ 可以使用`printenv`和`env`命令查看Shell中的环境变量

**元字符**
+ 元字符(Meta Character)是指在Shell中具有特殊含义的字符,因为元字符是被Shell解释的,所以不同的Shell环境中元字符不一定完全相同
+ 简单的讲:元字符就是一些定义为特殊意义的字符.最常用的元字符如:
  + `~` :表示home目录
  + `&` :在后台运行程序
  + `\\`:转义字符

**历史列表**
+ 在输入命令时,Shell会将每条命令保存到历史列表中,可以使用不同的方式访问历史列表,调取历史命令或者对历史命令进行二次修改执行
+ 在历史列表中,每一条命令称为一个事件,而每一个事件都有一个内部编号,称为事件编号.历史列表的功能就是它可以基于事件编号调取命令.例如: `!24`重新执行编号为24的命令

+ `$0`, 表示要执行的shell脚本名称
+ `$1`, `$2` 用来表示传入到脚本中对应位置的参数

**/dev/null**
+ `/dev/null`, 是一个特殊的设备文件,它丢弃一切写入其中的数据,可以将它视为一个黑洞,它等效于只写文件,写入其中的所有内容都会消失,尝试从中读取或输出不会有任何结果
+ 用途:`/dev/null`,通常被用于丢弃不需要的输出流,或作为用于输出流的空文件,这些操作通常由重定向完成,任何你想丢弃的数据都可以写入其中
+ 清空文件内容:`cat /dev/null > flag.txt`

**在后台运行脚本**
+ `/etc/init.d/test.sh &` : 直接在后台运行脚本
+ `jobs` : 查看当前shell环境中已经启动的任务情况
+ 直接在后台运行test.sh的方法,当遇到退出当前shell终端时,后台运行的test.sh也就结束了.这是因为直接在后台运行的方法使得test.sh在后台运行时,运行test.sh进程的父进程是当前shell终端进程,关闭当前shell终端时,父进程退出,发送hangup信号给所有子进程,子进程收到hangup以后也会退出.
+ 所以想要退出当前shell终端时test.sh继续运行,则需要**使用nohup忽略hangup信号**.
+ 在后台不中断的运行test.sh,可以使用`nohup`忽略hangup信号,或者使用setid将其父进程改为init进程(进程号为1)
  + `nohup /etc/init.d/test.sh &` : 不中断的在后台运行test.sh,test.sh的打印信息会输出到当前目录下的nohup.out中
  + `setsid /etc/init.d/test.sh &` : 不中断的在后台运行test.sh