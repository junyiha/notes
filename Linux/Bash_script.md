## 常用的bash脚本

+ `https://gitbook.curiouser.top/origin/bash-scirpts.html`
  - 判断curl返回状态码
  - 读取文件中的配置到变量中
  - 根据console输入条件执行
  - 将指定输出内容写入文件
  - 判断变量是否存在或为空
  - 换算秒为分钟、小时
  - 脚本命令行参数的传递与判断
  - 检测docker 容器的启动状态
  - 检查常见系统命令是否安装
  - 检查系统网络
  - 发送钉钉通知
  - 清理保持备份个数

## `#!` : 

+ 它是一个约定的标记,告诉系统这个脚本需要什么解释器来执行,即使用哪一种`shell`

## 运行shell脚本两种方法

+ 作为可执行程序：
  + `./test.sh`，与其他二进制的程序一样，如果直接输入`test.sh`，linux系统回去`PATH`里寻找`test.sh`，
  + 而只有`/bin, /sbin, /usr/bin, /usr/sbin`等在`PATH`里。当前目录通常不在`PATH`里，所以写成`test.sh`是会找不到命令的。`./test.sh`表示在当前目录

+ 作为解释器参数：
  + 这种运行方式是直接运行解释器，其参数就是`shell`脚本的文件名`/bin/bash test.sh`，这种方式运行的脚本，不需要在第一行指定解释器信息

## Shell变量:

+ **变量名和等号之间不能有空格**
+ 变量的命名只能使用英文字母,数字和下划线,首个字符不能以数字开头
+ 中间不能有空格,可以使用下划线
+ 不能使用标点符号
+ 不能使用`bash`里的关键字(可用`help`命令查看保留关键字)
+ 只有在使用变量的时候才加美元符,且推荐给所有变量加上花括号

+ 只读变量:使用`readonly`命令可以讲变量定义为只读变量,只读变量的值不能被更改
+ 删除变量:使用`unset`命令可以删除变量,变量被删除后不能再次使用,`unset`命令不能删除只读变量

## read 接收用户输入

+ `read -p "input number >>> " number`
  + 等待用户输入，并将输入保存到变量`$number`

## 变量类型:运行shell时,会同时存在三种变量:

1. **局部变量**:局部变量在脚本或命令中定义,仅在当前`shell`实例中有效,其他`shell`启动的程序不能访问局部变量
2. **环境变量**:所有的程序,包括`shell`启动的程序,都能访问环境变量,有些程序需要环境变量来保证其正常运行,必要的时候`shell`脚本也可以来定义环境变量
3. **shell变量**:`shell`变量由`shell`程序设置的特殊变量.`shell`变量中有一部分是环境变量,有一部分是局部变量,这些变量保证了`shell`的正常运行.

## Shell字符串

字符串可以用单引号,也可以用双引号,也可以不用引号
+ 单引号
  1. 单引号里的任何字符都会原样输出,**单引号字符串中的变量是无效的**;
  2. 单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行),但可成对出现,作为字符串拼接使用
+ 双引号
  1. 双引号里可以有变量
  2. 双引号里可以出现转义字符

+ 获取字符串长度:`string="abcd"; echo ${#string}`
+ 提取子字符串:`string="runoob"; echo ${string:1:4}  # 输出 unoo`
+ 查找子字符串:```string="runoob is a great site"; echo `expr index "$string" io```

## Shell数组

+ `bash` 支持一维数组,不支持多维数组,并且没有限定数组的大小
+ 类似于C语言,数组元素的下标由`0`开始编号.获取数组中的元素要利用下标,下标可以使整数或算数表达式,其值应该大于或等于`0`
+ **定义数组**:在`shell`中,用括号来表示数组,数组元素用"空格"符号分割开,定义数组的一般形式为:`数组名=(值1 值2 ... 值n)`
+ 读取数组:一般格式为`${数组名[下标]}`, 使用`@`符号可以获取数组中所有的元素
+ 获取数组的长度:
  - `length=${#array_name[@]} or length=${#array_name[*]} # 取得数组元素的个数` 
  - `lengthn=${#array_name[n]}  # 取得数组单个元素的长度`

## Shell注释

+ 以`#`开头的行就是注释,会被解释器忽略
+ 通过每一行加一个`#`号来设置多行注释
+ 如果在开发过程中,遇到大段的代码需要临时注释起来,调用的时候取消注释,其解决办法是:把这一段要注释的代码用一对花括号括起来,定义成一个函数,没有地方调用这个函数,这块代码就不会执行,达到了和注释一样的效果
+ 多行注释:
      ```
        :<<EOF
        注释内容...
        注释内容...
        注释内容...
        EOF(注:EOF也可以使用其他的符号,例如!)
      ```
    
+ 输出结果 : hello world
  ```
  cat << EOF

  hello world

  EOF
  ```

## 最常使用的文件描述符(file descriptor, FD):

1. `0` : 是一个文件描述符,表示标准输入(`stdin`)
2. `1` : 是一个文件描述符,表示标准输出(`stdout`)
3. `2` : 是一个文件描述符,表示标准错误(`stderr`)

在标准情况下,这些文件描述符分别与如下设备关联:
1. `stdin(0):keyboard` 键盘输入,并返回在前端
2. `stdout(1):monitor` 正确返回值,输出到前端
3. `stderr(2):monitor` 错误返回值,输出到前端

## >

+ `>`是重定向符,就是把前面输出的内容重定向到后面指定的位置
+ `>`前可以加数字来说明把什么内容重定向到文件中,默认是把标准输出重定向到文件中
  
## &

+ `&`是一个描述符,如果1或2前不加`&`,会被当成一个普通文件
+ `1>&2` : 意思是把标准输出重定向到标准错误
+ `2>&1` : 意思是把标准错误输出重定向到标准输出
+ `&>filename` :　意思是把标准输出和标准错误输出都重定向到文件`filename`中

## Shell传递参数

+ 在执行`Shell`脚本时,向脚本传递参数,脚本内获取参数的格式为:`$n`
+ `n`代表一个数字,`1`为执行脚本的第一个参数;`2`为执行脚本的第二个参数,以此类推...

## 处理参数的特殊字符

+ `@#` 传递到脚本的参数个数
+ `$*` 以一个单字符串显示所有向脚本传递的参数
+ `$$` 脚本运行的当前进程的ID号
+ `$!` 后台运行的最后一个进程的ID号
+ `$@` 与`$*`相同,但是使用时加引号,并在引号中返回每个参数
+ `$-` 显示Shell使用的当前选项,与**set命令**功能相同
+ `$?` 显示最后命令的退出状态:0 表示没有错误,其他任何值表示有错误

## 关系运算符

+ 关系运算符只支持数字,不支持字符串,除非字符串的值是数字
+ 常用的关系运算符(a为10, b为20):
  + `-eq`, 检测两个数是否**相等**,相等返回true. 例如:`$a -eq $b`,返回false
  + `-ne`, 检测两个数是否**不相等**,不相等返回true. 例如:`$a -ne $b`,返回ture
  + `-gt`, 检测左边的数是否**大于**右边的,如果是,则返回ture. 例如`$a -gt $b`, 返回false
  + `-le`, 检测左边的数是否**小于**等于右边的,如果是,则返回true. 例如`$a -le $b`,返回true
  + `-lt`, 检测左边的数是否**小于**右边的,如果是,则返回true. 例如`$a -lt $b`,返回ture
  + `-ge`, 检测左边的数是否**大于**等于右边的,如果是,则返回true. 例如`$a -ge $b`,返回false

## 字符串测试

+ `=` -- 等于则为真
+ `!=` -- 不相等则为真
+ `-z 字符串`  -- 字符串的长度为零则为真
+ `-n 字符串`  -- 字符串的长度不为零则为真

## 文件测试

| 参数 | 说明 |
| ----| ---- |
|-e 文件名 | 如果文件存在，则为真 |
|-r 文件名 | 如果文件存在且可读， 则为真|
|-w 文件名 | 如果文件存在且可写， 则为真|
|-x 文件名 | 如果文件存在且可执行， 则为真|
|-s 文件名 | 如果文件存在且至少有一个字符， 则为真|
|-d 文件名 | 如果文件存在且为目录，则为真 |
|-f 文件名 | 如果文件存在且为普通文件，则为真 |
|-c 文件名 | 如果文件存在且为字符型特殊文件， 则为真 |
|-b 文件名 | 如果文件存在且为块特殊文件， 则为真 |
|-L 文件名 | 如果文件存在且为链接文件，则为真 |

## -x

+ `#!/bin/bash -x`, `-x`选项可用来跟踪脚本的执行,是调试`shell`脚本的强有力工具
+ `-x`选项使shell在执行脚本的过程中把它实际执行的每一个命令行显示出来,并且在行首显示一个`+`号,`+`号后面显示的是经过了变量替换之后的命令行的内容,有助于分析实际执行的是什么命令
+ `shell`的执行选项除了可以在启动`shell`时指定外,还可以在脚本中用`set`命令指定.
  + `set -参数`, 表示启用某选项
  + `set +参数`, 表示关闭某选项

## shell内置的环境变量

+ `$LINENO`, 代表`shell`脚本的当前行号,类似于C语言中的内置红`__LINE__`
+ `$FUNCNAME`, 函数的名字,类似于C语言中的内置宏`__func__`,但宏`__func__`只能代表当前所在的函数名,而`$FUNCNAME`的功能更强大,它是一个**数组变量**,其中包含了整个调用链上所有的函数的名字,
  - 所以变量`${FUNCNAME[0]}` 代表 `shell` 脚本当前正在执行的函数的名字,
  - 而变量`${FUNCNAME[1]}` 则代表调用函数 `${FUNCNAME[0]}` 的函数的名字,以此类推
+ `$PS4`,主提示符变量`$PS1`和第二级提示符变量`$PS2`
  + `PS(Prompt Sign)`, 是指命令提示符,
  + 在Linux环境下`$PS1`是终端提示符,我们可以用预设的一些特殊符号来改变`$PS1`变量.
    + PS1变量中各项提示符的含义:
      + `\d`:日期
      + `\H`:完整的主机名称
      + `\h`:仅取主机的第一个名字
      + `\t`:显示时间为24小时格式,如 HH:MM:SS
      + `\T`:显示时间为12小时格式
      + `\A`:显示时间为24小时格式,如 HH:MM
      + `\u`:当前用户的账号名称
      + `\v`:BASH的版本信息
      + `\w`:完整的工作路径名
      + `\W`:最后一个路径名
      + `\$`:提示字符,root用户为#, 普通用户为$

## 变量

+ 变量是一个用来存储数据的实体,由一个变量名和值组成.在`Shell`中有两种不同类型的变量,分别是`Shell`变量和环境变量,也被称为局部变量和全局变量
+ 在`Bash`中只允许创建局部变量,也就是说每个新变量都会自动设置成局部变量.如果希望某个变量成为环境变量,必须使用`export`命令将局部变量修改为"局部+全局"变量,这可以成为将变量导出到环境中
+ 在`Linux`中启动一个`shell`会创建一个进程,修改环境变量后只会对该进程及子进程有效,不会传递到父进程中.要是环境变量对所有的`Shell`起作用需要修改配置文件.
+ `Shell`环境中包含很多变量,虽然`shell`环境变量根据发行版本的不同而不同,但是一般都会包含一下环境变量:
  + `SHELL` : Shell程序的名字
  + `HOME`  : 用户的家目录
  + `LANG`  : 系统语言及字符集
  + `PAGER` : 页输出程序的名字,这经常设置为`/usr/bin/less`
  + `PATH`  : 系统查找命令的路径(由冒号分开的目录列表)
  + `PS1`   : Shell提示符
  + `PWD`   : 当前工作目录
  + `TERM`  : 终端类型
  + `USER`  : 当前用户名
+ 可以使用`printenv`和`env`命令查看`Shell`中的环境变量

## 元字符（特殊字符）

+ 元字符(Meta Character)是指在`Shell`中具有特殊含义的字符,因为元字符是被`Shell`解释的,所以不同的`Shell`环境中元字符不一定完全相同
+ 简单的讲:元字符就是一些定义为特殊意义的字符.最常用的元字符如:
  + `~` :表示home目录
  + `&` :在后台运行程序
  + `\\`:转义字符

## 历史列表

+ 在输入命令时,`Shell`会将每条命令保存到历史列表中,可以使用不同的方式访问历史列表,调取历史命令或者对历史命令进行二次修改执行
+ 在历史列表中,每一条命令称为一个事件,而每一个事件都有一个内部编号,称为事件编号.历史列表的功能就是它可以基于事件编号调取命令.例如: `!24`重新执行编号为`24`的命令

+ `$0`, 表示要执行的shell脚本名称
+ `$1`, `$2` 用来表示传入到脚本中对应位置的参数

## /dev/null

+ `/dev/null`, 是一个特殊的设备文件,它丢弃一切写入其中的数据,可以将它视为一个黑洞,它等效于只写文件,写入其中的所有内容都会消失,尝试从中读取或输出不会有任何结果
+ 用途:`/dev/null`,通常被用于丢弃不需要的输出流,或作为用于输出流的空文件,这些操作通常由重定向完成,任何你想丢弃的数据都可以写入其中
+ 清空文件内容:`cat /dev/null > flag.txt`

## 在后台运行脚本

+ `/etc/init.d/test.sh &` : 直接在后台运行脚本
+ `jobs` : 查看当前`shell`环境中已经启动的任务情况
+ 直接在后台运行`test.sh`的方法,当遇到退出当前`shell`终端时,后台运行的`test.sh`也就结束了.这是因为直接在后台运行的方法使得`test.sh`在后台运行时,运行`test.sh`进程的父进程是当前`shell`终端进程,关闭当前`shell`终端时,父进程退出,发送`hangup`信号给所有子进程,子进程收到`hangup`以后也会退出.
+ 所以想要退出当前`shell`终端时`test.sh`继续运行,则需要**使用nohup忽略hangup信号**.
+ 在后台不中断的运行`test.sh`,可以使用`nohup`忽略`hangup`信号,或者使用`setid`将其父进程改为`init`进程(进程号为`1`)
  - `nohup /etc/init.d/test.sh &` : 不中断的在后台运行`test.sh`,`test.sh`的打印信息会输出到当前目录下的`nohup.out`中
  - `setsid /etc/init.d/test.sh &` : 不中断的在后台运行`test.sh`

## shell流程控制

+ `shell`的流程控制不可为空，如果`else`分支没有语句执行，就不要写这个`else`

+ `if else`
  ```
    if condition
    then
      command1
      command2
      ...
      commandN
    elif condition2
    then
      command
    else
      command
    fi
  ```
+ 写成一行（适用于终端命令提示符）
  + `if [ $(ps -eaf | grep -c "ssh") -gt 1];then echo "true"; fi`

+ `if else`的`[...]`判断语句中大于使用`-gt`，小于使用`-lt`
+ **如果使用`((...))`作为判断语句，大于和小于符号可以直接使用`>` 和 `<`**

+ `for`
  ```
    for var in item1 item2 ... itemN
    do
      command1
      command2
      ...
      commandN
    done
  ```
+ 写成一行：
  + `for var in item1 item2 ... itemN; do command1; command2... done;`
+ 当变量值在列表里，`for` 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可以为任何有效的`shell`命令和语句。`in`列表可以包含替换，字符串和文件名。
+ `in`列表是可选的，如果不用它，`for`循环使用命令行的位置参数

+ `while`
  ```
    while condition
    do
      command
    done
  ```
+ 变量计算中不需要加上`$`来表示变量，具体查看`let`命令

+ 无限循环
  ```
    while :
    do 
      command
    done

    while true
    do
      command
    donw

    for (( ; ; ))
  ```

+ `until`循环
  + `until`循环执行一系列命令直至条件为`true`时停止
  + `until`循环与`while`循环在处理方式上正好相反
    ```
      until condition
      do
        command
      donw
    ```
  + `condition`一般为条件表达式，如果返回值`false`，则继续执行循环体内的语句，否则跳出循环。

+ `case... esac`
  ```
    case value in 
    模式1）
      command1
      command2
      ...
      commandN
      ;;
    模式2）
      command1
      command2
      ...
      commandN
      ;;
    esac
  ```
+ `case`工作方式，取值后面必须为单词`in`，每一个模式必须以右括号结束。取值可以为变量或常是，匹配发现取值符合某一模式后，其间所有命令开始执行，直到遇到`;;`
+ 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令不再继续其他模式。如果没有一个匹配模式，使用星号捕获该值，再执行后面的命令

+ 跳出循环
  + `break`和`continue`

## shell函数

+ 函数定义格式
  ```
    [ function ] functionName [ () ]
    {
      action;

      [return int;]
    }
  ```
+ 说明
  + 可以带`function fun()`定义，也可以直接`fun()`定义，不带任何参数
    + 例如：`function manual()` 或者 `manual()`
  + 参数返回，可以显示加`return`返回，如果不加，将以最后一条命令运行结果作为返回值。`return`后跟数值`0-255`
  + 调用函数方式：
    + `manual`
    + 传入参数：`auto 参数1 参数2`

+ 函数返回值在调用该函数后通过`$?`来获得
+ 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始，直到shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可

+ 函数参数
  + 在`shell`中，调用函数时可以向其传递参数。在函数体内部，通过`$n`的形式来获取参数的值

## 文件包括

+ 文件包括的语法格式：
  ```
    . filename  # 注意点号和文件名中间有一个空格
    # 或者
    source filename
  ```

## shell脚本中使用root权限

+ 两种方法：
  + 使用`expect`
  + (不对)使用`sudo`，但是这种方法只能进入`root`执行一条指令，命令格式为    + `echo [password] | sudo -s [commond]`
      + `-s` -- run `shell` as the target user ; a command may also be specified

### expect

+ `expect`是一个免费的编程工具语言，用来实现自动和交互式任务进行通信，而无需人的干预
+ `expect`需要Tcl编程语言的支持，要在系统上运行expect必须首先安装Tcl
+ `expect`的核心是`spawn、expect、send、set`
  - `spawn`    调用要执行的命令
  - `expect`   等待命令提示信息的出现，也就是捕捉用户输入的提示：
  - `send`     发送需要交互的值，替代了用户手动输入内容
  - `set`      设置变量值
  - `interact` 执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。
  - `expect`   eof 这个一定要加，与spawn对应表示捕获终端输出信息终止，类似于if....endif
+ `expect`脚本必须以`interact`或`expect` `eof`结束，执行自动化任务通常`expect` `eof`就够了
+ 设置`expect`永不超时 `set timeout -1`
+ 设置`expect` 300秒超时，如果超过300没有`expect`内容出现，则退出 `set timeout 300`
+ `expect`编写语法：`expect`使用的是tcl语法
  - 一条Tcl命令由空格分割的单词组成. 其中, 第一个单词是命令名称, 其余的是命令参数  `cmd arg arg arg`
  - $符号代表变量的值. 在本例中, 变量名称是foo.  `$foo`
  - 方括号执行了一个嵌套命令. 例如, 如果你想传递一个命令的结果作为另外一个命令的参数, 那么你使用这个符  `[cmd arg]`
  - 双引号把词组标记为命令的一个参数. "$"符号和方括号在双引号内仍被解释  `"some stuff"`
  - 大括号也把词组标记为命令的一个参数. 但是, 其他符号在大括号内不被解释 `{some stuff}`
  - 反斜线符号是用来引用特殊符号. 例如：n 代表换行. 反斜线符号也被用来关闭"$"符号, 引号,方括号和大括号的特殊含义

+ expect脚本自动获取root权限
  ```
    #!/usr/expect/bin/expect -f

    set timeout=5 #设置5秒超时
    #下面几行后面不能添加注释，否则会异常
    #send "exit\r" - exit命令：会退出root账号，成为普通用户
    spawn su - root
    expect "密码："
    send "zlkj\r"
    send "pwd\r"
    #send "exit\r"
    interact #使用interact后，脚本将退出到root账号下，可以手动执行root权限的命令
    exit 0 #退出脚本
  ```

  + 暂时搁置，shell脚本中不能运行，tcl编程语言未安装，spawn命令不能识别