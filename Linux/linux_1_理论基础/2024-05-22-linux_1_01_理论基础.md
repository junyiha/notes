---
category: Linux
date: 2024-05-22 09:00:00 +0800
layout: post
title: linux_1_01_理论基础
tag: LinuxBasic
---
## 简介

+ linux系统的相关理论知识

## linux psmisc 软件包 详解

`psmisc` 是一个用于 Linux 操作系统的软件包，它包含了一些有用的进程管理工具，通常用于查找和操作进程。以下是有关 `psmisc` 软件包的详细信息和一些常见工具：

1. **`killall` 命令**：`killall` 命令用于终止具有指定名称的进程。通常，您可以提供要终止的进程的名称，然后 `killall` 会尝试找到并终止所有与该名称匹配的进程。

   示例用法：
   ```bash
   killall process_name
   ```

2. **`pkill` 命令**：`pkill` 命令允许根据进程的名称或其他属性来终止进程。与 `killall` 不同，`pkill` 具有更多的灵活性，可以使用正则表达式等来匹配进程。

   示例用法：
   ```bash
   pkill -u username process_name
   ```

   这将终止特定用户 (`-u` 参数) 启动的具有特定名称的进程。

3. **`pstree` 命令**：`pstree` 命令用于以树形结构显示系统上的进程，显示进程之间的父子关系，使您可以更好地了解进程之间的关联。

   示例用法：
   ```bash
   pstree
   ```

   这将显示整个进程树。

4. **`fuser` 命令**：`fuser` 命令用于查找正在使用特定文件或文件系统的进程。它可以帮助您找出哪个进程占用了文件或目录。

   示例用法：
   ```bash
   fuser -u filename
   ```

   这将列出正在使用指定文件的进程，并显示它们的用户名。

5. **`peekfd` 命令**：`peekfd` 命令用于查看进程的文件描述符。它可以用于监视进程的文件操作。

   示例用法：
   ```bash
   peekfd process_id
   ```

   这将显示指定进程的文件描述符信息。

`psmisc` 软件包提供了这些实用工具，可用于查找和管理进程，以及诊断与进程相关的问题。这些工具在系统管理员和开发人员之间广泛使用，用于处理进程管理任务。如果您需要执行进程管理操作或诊断进程相关问题，`psmisc` 软件包是一个有用的工具集。要在大多数 Linux 发行版中安装它，您可以使用包管理器，如 `apt`（Debian/Ubuntu）或 `yum`（Red Hat/CentOS）。

## 常见的处理器架构

计算机领域中有许多不同的处理器架构，每种都有其独特的特点和用途。以下是一些常见的处理器架构：

1. **x86/x86-64（Intel和AMD）：** x86 架构是最常见的桌面和服务器处理器架构之一。x86-64 是其 64 位版本，也被称为 AMD64。它广泛用于个人计算机、工作站和服务器。

2. **ARM：** ARM 架构是一种低功耗、高性能的处理器架构，广泛用于移动设备、嵌入式系统、物联网设备和一些服务器。它是许多智能手机和平板电脑的基础。

3. **PowerPC：** PowerPC 架构最初由 IBM、Motorola 和苹果合作开发，用于 Macintosh 计算机。虽然在桌面领域的份额不大，但在嵌入式和服务器市场中仍有用武之地。

4. **SPARC（Scalable Processor Architecture）：** SPARC 架构是由甲骨文公司开发的，用于高性能计算和企业级服务器。它具有强大的多线程能力。

5. **MIPS（Microprocessor without Interlocked Pipeline Stages）：** MIPS 架构用于嵌入式系统、网络设备和某些路由器。它还曾用于一些游戏机，如索尼的 PlayStation。

6. **RISC-V：** RISC-V 是一种开源的指令集架构，具有灵活性，广泛用于教育、嵌入式系统和一些自定义处理器的设计。

7. **Itanium（IA-64）：** Itanium 架构是由英特尔和HP合作开发的，用于高性能计算和企业级服务器。然而，它在市场上的成功有限，已经逐渐被其他架构取代。

8. **Z系列（IBM System z）：** Z 系列是 IBM 用于大型企业主机的处理器架构，用于处理高度事务性的应用程序。

9. **Alpha：** Alpha 架构是由 DEC（Digital Equipment Corporation）开发的高性能 RISC 处理器架构，已经停止生产，但曾在科学计算和高性能计算中广泛使用。

这只是一些常见的处理器架构，还有许多其他特定用途的架构和自定义架构，适用于各种不同的应用领域。不同的处理器架构适合不同的用途，选择取决于性能、功耗、成本和应用程序的需求。

## 芯片架构 amd x86_64 详解

"AMD x86_64"，也称为"AMD64"或"x86-64"，是一种 64 位的 CPU 架构，由 AMD 公司于 2003 年首次引入。它是一种扩展的 x86 架构，用于替代传统的 32 位 x86 架构，以支持更大的内存寻址范围和更高的性能。以下是 AMD x86_64 架构的一些详细信息：

1. **寻址范围：** 最显著的优势是它可以寻址更大的内存范围。32 位系统的极限是约 4GB 内存，而 x86_64 架构可以支持数百 TB（1 TB = 1024 GB）的内存，这使得它特别适用于大规模数据处理和高性能计算任务。

2. **寄存器：** AMD x86_64 架构引入了更多的通用寄存器和 SIMD（单指令多数据）寄存器，这有助于提高并行计算性能。

3. **指令集：** x86_64 架构是对传统 x86 指令集的扩展，增加了一些新的指令，以提高性能和支持更多的数据类型。它仍然能够运行 32 位的 x86 软件，通过一种称为“兼容模式”的方式。

4. **操作系统支持：** 主流操作系统，包括 Windows、Linux 和 macOS，都支持 AMD x86_64 架构。这使得它成为通用计算平台的首选架构。

5. **性能：** 64 位的处理能力和更多的寄存器通常导致更好的性能，特别是在处理大规模数据和复杂计算时。

6. **虚拟化：** AMD x86_64 架构还增强了虚拟化支持，使得在一个物理主机上运行多个虚拟机成为可能。

7. **兼容性：** 大多数现有的 32 位 x86 软件可以在 x86_64 系统上运行，通常通过一种称为“多架构支持”的方式，同时也能够运行专为 64 位系统编译的软件。

总之，AMD x86_64 架构是一种高性能、高扩展性的架构，适用于各种计算任务，从桌面计算机到数据中心服务器。它已成为现代计算领域的标准之一，广泛用于各种计算场景。

## sha256码

SHA-256（安全散列算法 256 位）是一种密码散列函数，用于将输入数据（消息）转换为 256 位（32 字节）的散列值。这个散列值通常以十六进制表示，由 64 个字符组成。SHA-256 是 SHA-2 家族中的一员，提供了高度的安全性和散列性能，广泛用于密码学、数字签名、数据完整性验证以及其他安全相关应用。

SHA-256 的主要特点包括：

1. **不可逆性（One-way Function）**：无法从散列值还原出原始输入数据。你可以计算散列值，但不能反向计算出输入数据。

2. **唯一性**：不同的输入数据将产生不同的 SHA-256 散列值。即使输入数据仅有微小的改变，也会导致不同的散列值。

3. **固定长度**：SHA-256 的输出始终是 256 位（32 字节）的散列值。

4. **抗碰撞（Collision Resistance）**：在实际应用中，很难找到两个不同的输入数据产生相同的 SHA-256 散列值。

SHA-256 在许多领域都有广泛的应用，包括密码学、数字签名、区块链、数据完整性验证、密码存储等。它被认为是目前非常安全的散列算法之一，因为攻击者需要耗费极大的计算资源才能破解或找到碰撞（相同散列值的两个不同输入数据）。

要计算数据的 SHA-256 散列值，你可以使用各种编程语言和工具库提供的函数或命令。例如，在 Linux 命令行中，你可以使用以下命令计算一个文件的 SHA-256 散列值：

```bash
sha256sum file_name
```

其中 `file_name` 是要计算散列值的文件名。

请注意，SHA-256 散列值通常用于验证数据的完整性，而不是加密数据。要加密数据，通常需要使用加密算法而不是散列函数。

## dpkg-dev 详解

在Ubuntu中，`dpkg-dev` 是一个软件包，提供了一些开发工具和功能，用于创建和管理 Debian 软件包。Debian 软件包是 Ubuntu 及其衍生版操作系统所使用的软件包格式。`dpkg-dev` 工具使得创建、构建和管理这些软件包变得更加容易和自动化。

以下是 `dpkg-dev` 的一些主要功能和用法的详细解释：

1. **创建 Debian 软件包：**
   `dpkg-dev` 提供了 `dh_make` 工具，用于生成初始的 Debian 软件包模板。该工具可以根据源代码目录自动创建 `debian/` 目录和一些必要的文件，以便开始构建一个 Debian 软件包。

2. **构建 Debian 软件包：**
   使用 `dpkg-buildpackage` 工具可以根据软件包的源代码和 `debian/` 目录中的控制文件，自动构建 Debian 软件包。该工具会编译源代码、创建二进制文件、打包文件和文档，并生成一个完整的 Debian 软件包。

3. **修改和更新软件包：**
   在修改现有的 Debian 软件包时，`dpkg-dev` 工具提供了一些有用的工具和指南，以确保正确地进行修改并更新软件包的版本号、更新说明等信息。

4. **软件包信息和元数据：**
   `dpkg-dev` 包含一些工具来查看和检查软件包的信息和元数据。例如，`dpkg-deb` 工具可以用于查看软件包文件的详细信息，而 `dpkg-genchanges` 工具可以生成变更记录文件。

5. **生成软件包差异：**
   `dpkg-dev` 提供了 `dpkg-gencontrol` 和 `dpkg-genchanges` 等工具，用于生成二进制软件包和源代码软件包之间的差异文件，方便软件包的升级和维护。

请注意，`dpkg-dev` 工具通常用于开发人员和软件打包者，而普通用户通常不需要直接使用这些工具。如果您只是想使用和安装 Debian 软件包，请使用 `apt` 命令，它是 Ubuntu 包管理器的前端，会自动处理软件包的下载、安装和依赖关系。

如果您对软件包的开发和打包有兴趣，可以参考 `dpkg-dev` 的文档和相关资源，了解更多详细信息和使用方法。

## ubuntu ftp 服务器 详解

在 Ubuntu 上设置 FTP 服务器通常可以使用 vsftpd（Very Secure FTP Daemon）。vsftpd 是一个非常流行的 FTP 服务器软件，它被设计为简单、安全且高效。以下是在 Ubuntu 上搭建 vsftpd FTP 服务器的详细步骤：

1. 安装 vsftpd：
打开终端，使用以下命令安装 vsftpd：

```bash
sudo apt update
sudo apt install vsftpd
```

2. 配置 vsftpd：
安装完成后，您需要进行一些配置来设置 FTP 服务器的参数。主要的配置文件是 `/etc/vsftpd.conf`，您可以使用文本编辑器（如 nano 或 vim）来编辑该文件：

```bash
sudo nano /etc/vsftpd.conf
```

在该文件中，您可以根据需要调整一些设置，例如：

- 启用或禁用匿名访问：
```bash
anonymous_enable=YES   # 允许匿名访问
```
```bash
anonymous_enable=NO    # 禁止匿名访问
```

- 设置本地用户访问：
```bash
local_enable=YES       # 允许本地用户登录
```

- 设置写权限：
```bash
write_enable=YES       # 允许用户上传文件
```

- 指定用户根目录：
```bash
local_root=/home/ftp   # 指定FTP用户的根目录
```

3. 重新启动 vsftpd：
编辑配置文件后，保存并退出文本编辑器。然后，重新启动 vsftpd 以应用新的配置：

```bash
sudo systemctl restart vsftpd
```

4. 防火墙设置：
如果您的系统上启用了防火墙（如 ufw），需要允许 FTP 的数据传输端口（默认为 20 和 21 端口）：

```bash
sudo ufw allow 20/tcp
sudo ufw allow 21/tcp
```

5. 添加 FTP 用户（可选）：
如果您希望用户可以访问 FTP 服务器并上传文件，您需要在系统上创建相应的本地用户。您可以使用以下命令创建新用户并设置密码：

```bash
sudo adduser ftpuser  # 创建名为 "ftpuser" 的用户
sudo passwd ftpuser   # 设置 "ftpuser" 用户的密码
```

现在，您的 Ubuntu 系统上已经成功安装和配置了 vsftpd FTP 服务器。用户可以使用 FTP 客户端连接到您的服务器，上传和下载文件。请注意，为了保障数据传输的安全，建议使用 SFTP（SSH File Transfer Protocol）或 FTPS（FTP Secure，基于 TLS/SSL 加密）等加密的方式进行传输。

## linux 可用交换内存 与实际空闲内存 区别 详解

在Linux系统中，有两种类型的内存可用性，分别是可用交换内存（Swap）和实际空闲内存（Free Memory）。这两者的区别如下：

1. 可用交换内存（Swap）：
   可用交换内存是指交换空间（Swap Space）中未被使用的内存。交换空间是指硬盘上专门用于作为虚拟内存的一部分。当系统的物理内存（RAM）不足时，Linux系统会将一部分不常用的内存页面转移到交换空间，以释放物理内存给正在运行的进程使用。这个过程称为交换（Swap）。

   交换空间的设置对于系统性能是有益的，因为它可以避免系统的物理内存耗尽，从而防止系统崩溃或应用程序因为内存不足而崩溃。然而，当系统频繁进行交换时，会导致性能下降，因为硬盘速度远慢于内存访问速度。

   在Linux系统中，你可以使用`free`命令查看交换内存的情况，其中的`Swap`列显示的就是可用交换内存。

2. 实际空闲内存（Free Memory）：
   实际空闲内存是指当前未被任何进程使用的物理内存。它是系统中真正空闲可用的内存，可以用于立即分配给新的进程或者已经运行的进程的内存需求。实际空闲内存直接影响着系统的性能，因为足够的空闲内存可以保证系统响应速度和运行稳定性。

   同样，你可以使用`free`命令查看实际空闲内存，其中的`free`列显示的是实际空闲内存的大小。

需要注意的是，虽然可用交换内存（Swap）可以提供一种缓解内存不足的方式，但它并不能完全替代实际的物理内存。当系统过度依赖交换空间来弥补物理内存的不足时，会导致系统性能下降，因为交换到硬盘的数据访问速度较慢。因此，对于性能敏感的应用和系统，建议增加物理内存以避免频繁的交换行为。

## debian NetworkManager 详解

NetworkManager 是一个用于在 Linux 系统上管理网络连接的服务和工具集。它是一个常见的网络管理器，广泛用于各种 Linux 发行版中，包括 Debian。

下面是关于 NetworkManager 在 Debian 上的一些详细说明：

1. 功能：NetworkManager 提供了一种集中管理网络连接的方式，包括有线连接、Wi-Fi 连接、移动数据连接等。它可以自动检测和配置网络设备，管理 IP 地址、DNS 设置、路由表等网络参数，以及处理连接的自动连接、断开和重连。

2. 配置文件：NetworkManager 的配置文件通常位于 `/etc/NetworkManager/` 目录下。其中，`/etc/NetworkManager/NetworkManager.conf` 是主要的配置文件，定义了全局配置选项。此外，每个用户的网络连接配置存储在 `/etc/NetworkManager/system-connections/` 目录下。

3. 命令行工具：Debian 提供了一组命令行工具用于管理 NetworkManager。其中，`nmcli` 是一个强大的命令行界面工具，用于配置和管理网络连接。你可以使用 `nmcli` 查看连接状态、添加、编辑或删除网络连接配置，以及执行其他与网络管理相关的操作。

4. 图形界面：Debian 也提供了各种图形界面工具来管理 NetworkManager。其中，`nm-applet` 是 NetworkManager 的系统托盘应用程序，提供了一个简单的界面来查看和管理网络连接。此外，许多桌面环境（如 GNOME、KDE 等）也提供自己的网络管理工具，可以与 NetworkManager 集成。

5. 集成和兼容性：NetworkManager 与许多网络设备和协议兼容，并能与各种网络服务和工具集成。它支持以太网、Wi-Fi、移动数据（3G/4G）等多种连接类型，并与 DHCP、DNS、VPN、PPPoE 等网络服务协议配合工作。

总体而言，NetworkManager 提供了一种方便和灵活的方式来管理网络连接，在 Debian 系统中被广泛使用。它通过命令行工具和图形界面工具提供了多种管理选项，可适应各种网络环境和需求。

要深入了解 NetworkManager 的使用和配置，请参考 Debian 官方文档和 NetworkManager 的官方文档，以获得更详细和准确的信息。

## dummy output 

"dummy output" 是一个常见的术语，用于描述一个没有实际输出或功能的占位符或虚拟输出。

在计算机领域中，"dummy output" 通常用于表示一个虚拟的输出设备或占位符，它不会实际产生任何输出，或者仅仅是为了满足某些需求而存在。这种虚拟输出通常用于测试、模拟或占位的目的。

例如，在音频设备的设置中，你可能会看到一个名为 "dummy output" 的选项。这个选项表示一个虚拟的输出设备，用于模拟音频输出，而不是实际连接到物理设备。它可以用于测试音频设置或在没有物理音频设备的情况下进行音频处理。

类似地，在软件开发中，"dummy output" 也可以指代一个占位符或虚拟的输出对象。它可能是一个空函数、空类或其他形式的占位符，用于满足代码结构或接口的要求，但没有实际的功能或输出。

总的来说，"dummy output" 表示一个没有实际输出或功能的占位符或虚拟输出，通常用于测试、模拟或占位的目的。

---

## systemd

`systemd` 是用于管理Linux系统的初始化进程和服务管理器。它是最新的系统初始化方案，用于代替传统的 `init` 系统。`systemd` 提供了一套功能丰富的命令行工具，用于管理系统服务、单元（units）、日志和其他系统资源。

下面是一些常用的 `systemd` 命令及其简要说明：

1. `systemctl`：`systemctl` 命令用于管理系统服务，包括启动、停止、重启、启用、禁用等操作。例如：
   - 启动服务：`systemctl start service-name`
   - 停止服务：`systemctl stop service-name`
   - 重启服务：`systemctl restart service-name`
   - 启用服务：`systemctl enable service-name`
   - 禁用服务：`systemctl disable service-name`

2. `journalctl`：`journalctl` 命令用于查看系统日志，可以显示 `systemd` 单元的日志、内核消息等。例如：
   - 查看所有日志：`journalctl`
   - 查看特定服务的日志：`journalctl -u service-name`
   - 根据时间范围过滤日志：`journalctl --since "2022-01-01" --until "2022-01-02"`

3. `systemd-analyze`：`systemd-analyze` 命令用于分析系统启动时间和性能。例如：
   - 显示启动时间：`systemd-analyze`
   - 显示关键路径：`systemd-analyze critical-chain`
   - 显示各个服务的启动时间：`systemd-analyze blame`

4. `systemd-resolve`：`systemd-resolve` 命令用于管理系统的网络解析器和 DNS 配置。例如：
   - 查看 DNS 服务器：`systemd-resolve --status`
   - 清除 DNS 缓存：`systemd-resolve --flush-caches`

这只是 `systemd` 提供的一小部分命令，它还具有许多其他功能和选项，可用于管理系统的各个方面。您可以通过查阅 `systemd` 的官方文档或运行 `man` 命令来获取更详细的信息，例如 `man systemctl`、`man journalctl` 等。

---

## 压缩与解压  

+ 将文件压缩不只是为了节省硬盘空间,同时也可以节省网络传输时间,归档文件方便管理等
+ 压缩可分为无损压缩与有损压缩两种,但不管是采用何种技术模型,其本质内容都是一样的,即** 通过某种特殊的编码方式将数据信息中存在的重复度,冗余度有效地降低,从而达到数据压缩的目的** 
+ 在Linux中很多压缩程序只能针对一个文件进行压缩,当要压缩一大堆文件时,首先得先将一堆文件打成一个包(tar命令),然后再用压缩程序进行压缩(gzip, bzip2命令),就是说压缩会分为两步:先打包再压缩
+ 打包,tar命令可以将多个文件和目录创建一个档案(归档),tar最初是用来在磁带上创建档案;tar命令也可以修改档案中的文件,或者加入新的文件;使用tar程序打出来的包常称为tar包,tar包通常以`.tar`结尾
+ 归档的一般用途:
  + 把一大堆的文件和目录打包成一个tar包,便于网络传输
  + 生成tar包后,再用其他的程序进行压缩
+ 压缩
  + gzip,是GNUzip的缩写,它是一个GNU自由软件的文件压缩程序,文件经过它压缩以后以`.gz`为扩展名.
  + gzip不能用来压缩目录,需要先归档目录,然后再压缩,gzip和tar一起构成了Linux操作系统中流行的文件压缩格式(`.tar.gz`)

## 一切皆文件 

+ "一切皆文件"是Unix/Linux的基本哲学之一,它是指Linux系统中的所有的一切都可以通过文件的方式访问和管理,即使不是文件,也以文件的形式来管理.例如硬件设备,进程,套接字等都抽象成文件,使用统一的用户接口,虽然文件类型各不相同,但是对其提供的却是同一套操作
+ 这里的一切都是单项的,也即所有的东西都单向通过文件系统呈现,反向不一定可行.例如:通过新建文件的方式来创建磁盘设备是行不通的
+ 在Linux中共有7种类型的文件,分为3大类:
  + `-` : 普通文件,包括文本文件和二进制文件
  + `d` : 目录文件(文件夹文件)
  + 特殊文件
    + `l` : 链接文件
    + `c` : 字符设备文件
    + `s` : 套接字(Socket)文件,用于网络通讯,一般由应用程序创建
    + `p` : 命名管道文件
    + `b` : 块文件

## Linux文件基本属性

+ 在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等
  + 当为 `d` 则是目录
  + 当为 `-` 则是文件
  + 若是 `l` 则表示为链接文档(link file)
  + 若是 `b` 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)
  + 若是 `c` 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)

+ 接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)
+ 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已

+ 每个文件的属性由左边第一部分的 10 个字符来确定
+ 从左至右用 0-9 这些数字来表示
  + 第 0 位确定文件类型，
  + 第 1-3 位确定属主（该文件的所有者）拥有该文件的权限
  + 第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限
  + 第 7-9 位确定其他用户拥有该文件的权限

+ 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户
+ 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组
+ 文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户
+ 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限

+ Linux文件属性有两种设置方法，一种是数字，一种是符号
+ Linux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限
+ 文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限
  + r  --  4
  + w  --  2
  + x  --  1
+ 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： -rwxrwx--- 分数则是
  + owner = rwx = 4+2+1 = 7
  + group = rwx = 4+2+1 = 7
  + others= --- = 0+0+0 = 0

## inode索引节点 

+ `inode` 是理解`Unix/Linux`文件系统和硬盘存储的基础
+ 理解`inode`,不仅有助于提高系统操作水平,还有助于体会Unix设计哲学,即如何把底层的复杂性抽象成一个简单概念,从而大大简化用户接口

+ `inode`是什么?
  - 理解`inode`,要从文件存储说起 -- 文件储存在硬盘上,硬盘的最小存储单位叫做**扇区(`Sector`)** ,每个扇区储存`512`字节(相当于`0.5KB`)
  - 操作系统读取硬盘的时候,不会一个扇区一个扇区地读取,这样效率太低.而是**一次性连续读取多个扇区,即一次性读取一个块(`block`)**,这种由多个扇区组成的**块** ,是文件存取的最小单位.**块** 的大小通常是`4KB`,即连续八个扇区(`sector`)组成一个块(`block`)
  - 文件数据都存储在块中,那么还需要一个地方储存文件的**元信息** ,比如文件的创建者,文件的创建日期,文件的大小等.**这种储存文件元信息的区域就叫做`inode`** ,中文译名为**索引节点** 
  - 每一个文件都有对应的inode,里面包含了与该文件有关的信息
  
+ `inode`的内容:
  - `inode`包含文件的元信息,具体来说有:
    + 文件的字节数
    + 文件拥有者的`User ID`
    + 文件用户组的`Group ID`
    + 文件的读,写,执行权限
    + 文件的时间戳,共有三个
      + `ctime`,指inode上一次变动的时间
      + `mtime`,指文件内容上一次变动的时间
      + `atime`,指文件上一次打开的时间
    + 链接数,即有多少文件名指向这个`inode`
    + 文件数据`block`的位置
  - 可以使用`stat`命令,查看某个文件的inode信息

+ `inode`的大小
  - `inode`也会消耗硬盘空间,所以在格式化硬盘的时候,操作系统自动将硬盘分成两个区域,一个是数据区,存放文件数据;另一个是`inode`区(`inode table`),存放`inode`所包含的信息
  - `inode`节点一般占用`128`字节或`256`字节.`inode`节点的总数,在格式化时会自动设定.一般是每`1KB`或每`2KB`就设置一个`inode`
+ inode号码
  - 每个`inode`都有一个号码,操作系统用`inode`号码来识别不同的文件.
  - **`Unix/Linux`系统内部不使用文件名,而是使用`inode`号码来识别文件**.对于系统来说,文件名只是inode号码便于识别的别称或者绰号.
  - 表面上,用户通过文件名打开文件.实际上,系统内部将这个过程分为三步:
    + 系统找到文件名对应的`inode`号码
    + 通过`inode`号码,获取`inode`信息
    + 根据`inode`信息,找到文件数据所在的`block`,读出数据
  - 通过命令`ls -i filename`查看文件名对应的inode号码
  
+ 目录文件
  - `Unix/Linux`系统中,目录(`directory`)也是一种文件.打开目录,实际上就是打开目录文件
  - 目录文件的结构非常简单,就是一系列目录项(`dirent`)的列表.每个目录项由两个部分组成:所包含文件的文件名,以及该文件名对应的`inode`号码
  - **所以在使用`ls -lh`命令查看文件夹大小时,所有的文件夹只有`4KB`大小**
+ `inode`的特殊作用
  - 由于`inode`号码与文件名分离,这种机制导致了一些`Unix/Linux`系统特有的现象
  - 当文件名包含特殊字符,无法正常删除时,可以删除`inode`节点,就能直接删除文件
  - 移动文件或重命名文件,只是改变文件名,不影响`inode`号码,所以在`Linux`中移动文件不论大小基本秒成
  - 打开一个文件后,系统就以`inode`号码来识别文件,不再考虑文件名.因此,系统无法从`inode`号码得知文件名.

## 硬链接和软链接 

+ 在Linux中有两种link(链接)的概念,一般称之为硬链接和软链接(或符号链接)
+ 硬链接
  + 一般情况下,文件名和inode号码是"一一对应"的关系,每个inode号码对应一个文件名(每个文件默认有一个硬链接).但是Unix/Linux系统允许多个文件名指向同一个inode号码
  + 这意味着,可以用不同的文件名访问同样的内容,对文件内容进行修改后,会影响所有文件名.但是,删除一个文件名,不影响另一个文件名的访问,这种情况就被称为"硬链接(hard link)"
  + 创建一个硬链接,就会为文件创建了一个新的文件名.硬链接有两个重要局限性:
    + 硬链接不能链接不在同一系统的文件,也就是说硬链接不能链接与文件不在同一磁盘分区上的文件;
    + 硬链接不能链接目录
  + 一个硬链接和文件本身没有什么区别.当列出一个包含硬链接的文件时,不会有特殊的链接指示说明.当一个硬链接被删除时,文件本身的内容仍然存在(也就是说,它所占用的磁盘空间不会被重新分配),直到所有关联这个文件的硬链接都删掉.
+ 软链接:
  + 创建软链接是为了克服硬链接的局限性
  + 软链接是通过创建一个特殊类型的文件(指针)链接到文件或目录,就像windows的快捷方式
  + 文件A和文件B的inode号码虽然不一样,但是文件A的内容是文件B的路径.读取文件A时,系统会自动将访问指向文件B.因此,无论打开哪一个文件,最终读取的都是文件B,但是,文件A依赖于文件B而存在,如果删除了文件B,打开文件A就会报错:"No such file or directory"
  + 软链接与硬链接最大的不同:文件A指向文件B的文件名,而不是文件B的inode号码

## 安全模型与权限 

+ 在linux系统中,所有的操作实质上都是在进行进程访问文件的操作.在访问文件之前需要取得相应的权限,而权限是通过Linux系统中的安全模型获得的.理论上进程所拥有的权限与执行它的用户的权限相同.其中涉及的一切内容,都是围绕这个核心进行的.
+ Linux系统中的安全模型,有两种类型:
  + Linux系统上最初的安全模型称为** 自主访问控制(DAC, Discretionary Access Control)** 
  + 后来又增加设计了一个新的安全模型叫** 强制访问控制(MAC, Mandatory Access Control)** 
  + MAC和DAC不是互斥的,DAC是最基本的安全模型,也是最常用的访问控制机制,是Linux必须具有的功能;而MAC是构建在DAC智商的加强安全机制,属于可选模块
+ 文件权限控制
  + 对文件的权限分三组进行控制:
    + `user`对文件属主设定的权限
    + `group`对文件属组设定的权限
    + `othre`对其他者设定的权限
  + 常用的可设定的权限值,包括:
    + `r` : 读权限
    + `w` : 写权限
    + `x` : 执行权限
    + `s` : 强制位权限
    + `t` : 粘滞位权限
    + `i` : 不可修改权限
    + `a` : 只追加权限

## 端口 

+ `netstat  -a  # 列出所有端口`
+ `netstat -at  # 列出所有tcp端口`
+ `netstat -au  # 列出所有udp端口`
+ `netstat -l   # 只显示监听端口`
+ `netstat -lt  # 只列出所有监听tcp端口`
+ `netstat -lu  # 只列出所有监听udp端口`

### 查看指定端口

+ `sudo netstat -tlnp | grep 8083`
+ `sudo lsof -i:8083`

### lsof

+ apt install lsof

## 终端,控制台和shell的区别 

+ 终端(terminal)
+ 控制台(console)
  + 控制台是计算机的基本设备,而终端是附加设备
+ Shell俗称壳(用来区别于核)
  + 软件shell,俗称壳,是读取并解释命令的程序.
  + Shell是一个用C语言编写的程序,它是用户使用Linux的桥梁,用户通过Shell访问操作系统内核的服务

## 启动服务 

+ 启动`mysql`
  + 使用`service`启动: `service mysql start`

## Linux系统启动过程 

+ Linux系统的启动过程可以分为五个阶段:
  + 内核的引导
    + 当计算机打开电源后,首先是`BIOS`开机自检,按照`BIOS`中设置的启动设备(通常是硬盘)来启动.
    + 操作系统接管硬件以后,首先读入`/boot`目录下的内核文件
  + 运行init
    + (init程序的类型)
      + SysV:init
      + Upstart:init
      + Systemd:systemd
    + `init`进程是系统所有进程的起点,可以把它比作系统所有进程的老祖宗,没有这个进程,系统中任何进程都不会启动.
  + 系统初始化
  + 建立终端
  + 用户登录系统


## Linux下RTC时间：系统时间与RTC实时时钟时间

+ Linux系统下包含两个时间：**系统时间** 和 **RTC时间**
  - 系统时间：是由主芯片的定时器进行维护的时间，一般情况下都会选择芯片上最高精度的定时器作为系统时间的定时基准，以避免在系统运行较长时间后出现大的时间偏移。特点是掉电后不保存
  - RTC时间：是指系统中包含的RTC芯片内部所维护的时间。RTC芯片都有电池+系统电源的双重供电机制，在系统正常工作时由系统供电，在系统掉电后由电池进行供电。因此系统电源掉电后RTC时间仍然能够正常运行
+ 每次Linux系统启动后在启动过程中会检测和挂在RTC驱动，在挂在后会自动从RTC芯片中读取时间并设置到系统时间中去。此后如果没有显式的通过命令去控制RTC的读写操作，系统将不会再从RTC中获取或者同步设置时间
+ Linux命令中`date`和`time`等命令都是用来设置系统时间的；而`hwclock`命令是用来设置和读写RTC时间的

## 文件系统标识

+ 在`/etc/fstab`配置文件中你可以以三种不同的方法表示文件系统：内核名称，UUID或者label。
+ 使用UUID或者是label的好处再与它们与磁盘顺序无关。
+ 如果你在BIOS中改变了你的存储设备顺序，或者是重新拔插了存储设备，或是因为一些BIOS可能会随即地改变存储设备的顺序，那么用UUID或者是label来表示将更有效

+ 显示分区的基本信息：`lsblk -f`
+ 内核名称：`fdisk -l` 来获得内核名称，前缀是`dev`
+ `UUID`：所有分区和设备都有唯一的UUID。**它们由文件系统生成工具`(mkfs.*)`在创建文件系统时生成。**

+ 路径名有空格，可以使用`\040`转义字符来表示空格（以三位八进制数来进行表示）
  - `UUID=47FA-4071 /home/username/Camera\040Pictures vfat defaults, noatime 0 2`

+ `tmpfs`
  - `tmpfs`是一个临时文件系统，驻留于你的交换分区或者是内存中（取决于你的使用情况）。使用它可以提高文件访问速度，并能够保证重启时会自动清除这些文件
  - 经常使用`tmpfs`的目录有`/tmp, /var/lock, /var/run`。不要把tmpfs使用于`/var/tmp`，因为这一个目录中的临时文件在重启过程中需要被保留。
  - 默认情况下，tmpfs分区被和设置为总的内存的一半，当然可以自由设定

## POSIX API

+ POSIX，全称为**可移植性操作系统接口**，是一种关于信息技术的IEEE标准。它包括了系统应用程序的接口（API），以及实时扩展（C语言）
+ 该标准的目的是定义了标准的基于UNIX操作系统的系统接口和环境来支持源代码级的可移植性。现在，标准主要提供了依赖C语言的一系列标准服务，在将来的版本中，标准将致力于提供基于不同语言的规范。
+ 该标准对核心需求部分定义了一系列任何编程语言都通用的服务，这一部分服务主要从其功能需求方面阐述，而非定义依赖于编程语言的接口。
+ 语言规范主要由两部分组成
  - 一部分包括了访问核心服务的编程语言的标准接口，这些核心服务为标准中基于编程语言的核心需求部分所定义
  - 另一部分包含了一个特殊语言服务的标准接口。

+ 该标准一共被分为四个部分：
  - 陈述的范围和一系列标准参考
  - 定义和总概念
  - 各种接口设备
  - 头文件

## 挂载

+ 挂载目录:
  + 工具:nfs, sshfs, 

+ 挂载(mount):
  - "挂载"发生在计算机想要使用任何类型的存储设备(如硬盘,CD-ROM,网络设备)之前,操作系统必须讲这个设备纳入自己的文件系统中

+ `mount -t type device dir` 
  - 挂载操作,实际上是把设备(device)中的文件系统附加到dir上,可以通过访问dic来访问这个设备
  - 其本质就是针对某一设备,分析出其文件系统结构,并根据其文件系统类型调用linux中相应的驱动,处理该设备的元数据,将这些信息附加到linux的目录树上,并呈现出来.

## 内网穿透 

+ 内网，就是在公司或者家庭内部，建立的一种局域网络或者是办公网络，从而实现多台电脑之间可以进行资源的共享，包括设备，资料，数据等。而外网则是由一个网关与其他的网络系统连接，相对于内网而言，这种网络称之为外部网络，也就是我们经常说到的互联网。

+ 内网穿透，是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。
+ 内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功能之外，还可以解决UDP中出现的数据传输不稳定的问题

+ 内网穿透可以通过开放的第三方端口来实现，可以安装一个NAT123端口内网穿透软件，然后再添加映射，并且配置出映射端口的信息，外网的地址是映射之后访问的域名，同时也可以是自己或者默认的域名，通过内网穿透，可以用域名进行对应的内网应用。如果是外网地址使用的是自己的域名，可以把域名的解析只想提示目标地址来使用。

+ 简单来说，内网穿透就是在我们没有公网IP的时候，也可以通过内网穿透服务器的转发，在任何互联网（广域网）连接内网的设备。

+ 推荐工具：Zero Tier , frp, **socat命令**

+ `ngrok`:
  + `ngrok config add-authtoken 2Fyd9ZRXPYDbBNIZQRXAPd036Un_cCTH2CsrmttkSzKE1ind`
  + `ngrok tcp 22 `
  + `ssh user@0.tcp.jp.ngrok.io -p 11111`

## ubuntu18 显卡配置

1. 查看显卡设备和显卡驱动 --> `ubuntu-drivers devices`
2. 自动安装合适的显卡     --> `sudo ubuntu-drivers autoinstall`
3. 重启系统

## 开机启动服务/脚本

+ 系统启动时需要加载的配置文件
  + /etc/profile
  + /root/.bash_profile
  + /etc/bashrc
  + /root/.bashrc
  + /etc/profile.d/*.sh
  + /etc/sysconfig/
  + /etc/rc.local

+ 自定义服务文件，添加到系统服务，通过`Systemctl`管理
  + 写服务文件，例如nginx.service, redis.service, supervisord.service
    ```
        [Unit]      --  服务说明
        Description --  描述服务
        After       --  描述服务类别

        [Service]    -- 服务运行参数的设置
        Type=forking -- 为后台运行的形式
        ExecStart    -- 为服务的具体运行命令
        ExecReload   -- 为服务的重启命令
        ExecStop     -- 为服务的停止命令
        PrivateTmp=True  -- 表示给服务分配独立的临时空间
        注意：启动，重启，停止命令全部要求使用绝对路径

        [Install]    --  服务安装的相关设置，可设置为多用户
        WantedBy=multi-user.target
    ``` 

+ 文件保存在`/usr/lib/systemd/system/`路径下，权限为`754`

+ 设置开机自动启动
  + `systemctl enable nginx.service`

+ 停止开机自启动
  + `systemctl disable nginx.service`

+ 验证是否为开机自启动
  + `systemctl is-enabled nginx`

+ 查看所有已经启动的服务
  + `systemctl list-units --type=service`

# 什么是socks

+ socks是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是SOCKets的缩写
+ 当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格。允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到版本4。最新协议是版本5，与前一版相比，增加支持UDP，验证以及IPv6

## 共享目录

### linux之间建立共享目录

如何使A服务器的某个目录挂载到B服务器的某个目录下,使其达到B服务下的目录文件一旦变更,可以实时的在A服务器的目录下体现出来?

Linux的解决方式
+ 将B服务器的该目录,设置为共享文件夹
+ A服务器通过mount的方式,指定对应的远程主机所抛出来的共享文件夹进行连接.

原理:
+ 挂载,并非将远程服务的文件实时拷贝到目标文件夹中
+ A服务器每次对于自身挂载文件的访问,实际上都是发送了一次新的RPC请求,请求目标服务器将其对应的目录数据实时返回到A服务器的文件当中进行展示.
+ Linux中存在一个应用:NFS网络文件系统(Network File System),它是一种适用于分散式文件系统的协定,让应用程序在客户端通过网络访问位于磁盘中的数据,是在类Unix系统间实现对应的磁盘文件共享的一种方法.

NFS和RPC的关系:
+ NFS在文件传送或信息传送过程中依赖于RPC协议.
+ RPC,远程过程调用(Remote Procedure Call)是能使客户端执行其他系统中程序的一种机制.
+ NFS本身是没有提供信息传输的协议和功能,但是NFS却能让我们通过网络进行资料的分享,这是因为NFS使用了一些其他的传输协议.而这些传输协议用到这个RPC功能,可以说NFS本身就是使用RPC的一个程序.只要用到NFS的地方都要启动RPC服务,不论是NFS 服务器还是NFS客户端,因为这样服务器和客户端才能通过RPC来实现程序端口的对应.
+ 可以这么理解:NFS是一个文件系统,而RPC是负责信息的传输

### 安装并配置NFS服务

1. 安装nfs服务器端服务: `apt-get install nfs-kernel-server`        
2. 编辑`/etc/exports`下的配置文件: 
      1. `sudo vim /etc/exports`
      2. 添加配置信息:`/home/zjy/share_folder *(rw, sync, no_root_squash, no_subtree_check)`
            1. `/home/zjy/share_folder`:共享文件夹的路径
            2. `*` : 允许所有的网段访问,也可以使用具体的IP
            3. `rw` : 挂接此目录的客户端对该共享目录的权限:读,写
            4. `sync`:资料同步写入内存和硬盘
            5. `no_root_squash`:root用户具有对根目录的完全管理访问权限
            6. `no_subtree_check` : 不检查父目录的权限
3. 重启服务,将会自动映射端口:`sudo /etc/init.d/rpcbind restart`
4. 重启nfs服务:`sudo /etc/init.d/nfs-kernel-server restart`
5. 创建共享文件夹
6. 查看ip地址,准备给客户端挂载

客户端配置:
1. 创建用于存放挂载的目录:`sudo mkdir /opt/share_folder`
2. 挂载服务器端共享目录:`sudo mount -t nfs 192.167.15.5:/mnt/A311D_share_folder /opt/share_folder`
3. 取消挂载:`sudo umount /opt/share_folder`

## /etc/apt/source.list

### debian 9 strech arm64

+ apt源
  ```
    # debian
    deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free
    # deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-free
    deb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free
    # deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free

    # deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free
    # deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free
  ``` 

## apt 出现 Certificate verification failed

+ `apt install ca-certificates --reinstall`