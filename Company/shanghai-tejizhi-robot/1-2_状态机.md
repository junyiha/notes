---
category: Company
date: 2024-08-26 09:00:00 +0800
layout: post
title: 1_2_状态机
tag: Shanghai-tejizhi-robot
---
## 简介

+ 状态机开发相关笔记

## 有限状态机(维基百科)

+ 有限状态机(finite-state machine, FSM)，又称有限状态自动机(finite-state automaton, FSA)，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

+ 状态存储关于过去的信息，就是说: 它反映从系统开始到现在时刻的输入变化。转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。动作是在给定时刻要进行的活动的描述。有多种类型的动作
  + 进入动作(entry action): 在进入状态时进行
  + 退出动作(exit action): 在退出状态时进行
  + 输入动作: 依赖于当前状态和输入条件进行
  + 转移动作: 在进行特定转移时进行

## 什么是状态机

+ 状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型
+ 什么是状态(state)
  + 现实事物是有不同状态的，例如一个LED灯，有亮和灭两种状态。
  + 我们通常说的状态机是有限状态机，也就是被描述的事物的状态的数量是有限个
+ 状态机(state machine)，不是指一台实际机器，而是指一个数学模型，更直接一点，是指一张状态转换图

+ 状态机的全程是有限状态自动机，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态是可以明确运算出来的。
+ 例如对于灯泡，给定初始状态 灯泡灭，给定输入 打开开关，那么下一个状态是可以运算出来的。

## 四大概念

+ State, 状态。一个状态机至少要包含两个状态。例如灯泡有亮和灭两个状态
+ Event，事件。事件就是执行某个操作的出发条件或者口令。对于灯泡，打开开关就是一个事件
+ Action，动作。事件发生以后要执行动作。例如事件是打开开关，动作是开灯。编程的时候，一个Action一般就对应一个函数
+ Transition，变换。也就是从一个状态变化为另一个状态。例如 开灯过程 就是一个变换

## 实现

+ 进程5状态模型。进程管理是Linux五大子系统之一。
  + 可运行态：当进程正在被CPU执行，或已经准备就绪随时可由调度程序执行，则称该进程为处于运行状态（running）。进程可以在内核态运行，也可以在用户态运行。当系统资源已经可用时，进程就被唤醒而进入准备运行状态，该状态称为就绪态。
  + 浅度睡眠态（可中断）：进程正在睡眠（被阻塞），等待资源到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。
  + 深度睡眠态(不可中断)：其和浅度睡眠基本类似，但有一点就是不可由其他进程信号或时钟中断唤醒。只有被使用wake_up()函数明确唤醒时才能转换到可运行的就绪状态。
  + 暂停状态：当进程收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时就会进入暂停状态。可向其发送SIGCONT信号让进程转换到可运行状态。
  + 僵死状态：当进程已停止运行，但其父进程还没有询问其状态时，未释放PCB，则称该进程处于僵死状态。

+ 定义该状态及的状态
```cpp
typedef enum {
  sta_origin=0,
  sta_running,
  sta_owencpu,
  sta_sleep_int,
  sta_sleep_unint
}State;
```

+ 发生的事件
```cpp
typedef enum{
  evt_fork=0,
  evt_sched,
  evt_wait,
  evt_wait_unint,
  evt_wake_up,
  evt_wake, 
}EventID;
```

+ 定义一个结构体用来表示当前状态转换信息
```cpp
typedef struct {
  State curState;//当前状态
  EventID eventId;//事件ID
  State nextState;//下个状态
  CallBack action;//回调函数，事件发生后，调用对应的回调函数
}StateTransform ; 
```