## 简介

+ 目标检测相关笔记
+ 除了图像分类，图像生成，图像去噪，目标检测也是计算机视觉领域非常常见的一类问题。其在人脸检测，行人检测，图像检索和视频监控等方面有广泛应用。

## 目标检测是什么

+ 目标检测，英文为Object Detection，有时候也称之为物体检测，物体识别等。简单来讲，目标检测是与计算机视觉和图像处理有关的计算机技术，其涉及在数字图像和视频中检测特定类（例如人，建筑物或汽车）的语义对象的实例。目标检测在人脸检测，行人检测，图像检索和视频监控等计算机视觉领域有广泛的应用。动态物体检测与识别也是自动驾驶中需要攻克的一项关键技术。
+ 目标检测实际上就主要做一件事情。识别图像中指定存在的所有对象及其位置，并标示出来

## 目标检测的前处理

+ 目标检测的前处理技术主要包括图像预处理、特征提取、数据增强等。图像预处理包括图像缩放、归一化、旋转、剪裁等操作，这能够对原始图像进行一定的优化和处理，提高模型的鲁棒性和准确率。特征提取是从原始图像中提取目标特征的过程，常用的提取特征的方式有卷积神经网络（CNN）、霍夫变换、边缘检测等方法。数据增强则是通过对原始图像进行变换，如随机裁剪、随机翻转、亮度调节、添加噪声等操作，增加训练数据量，提高模型的泛化能力。

+ 通过OpenCV读取图片，对图片进行缩放

## 机器学习和深度学习中关于图像数据输入的 Shape

+ 在机器学习的图片输入数据中，只需要将图片数据的4维(图片的多少，图片的长，图片的宽，图片的通道数)转换为2维即可
```python3
train_data = train_data.reshape(train_data.shape[0], train_data.shape[1] * train_data.shape[2] * train_data.shape[3])
```

+ 深度学习，读取图片阶段:
```python3
item_image = cv2.imread(img_path)
item_image = cv2.resize(item_image, (224,224), interpolation=cv2.INTER_AREA)
```
  + cv2.imread()是为了读取图片上的数据，也就是原始图像数据的信息。
  + 在cv2.resize()中，可以指定输出图片的大小，也就是图片的长和宽。
+ 把读取到数据转换成ndarray
```python3
train_data = np.array(train_data, dtype='float32')
```
+ 此时，如果打印train_data的维度，会显示一个4个维度的数据，(图片的数量，图片的长，图片的宽，图片的通道数)

+ shape
  + 图像形状，行数，列数，通道数

+ size
  + 图像大小，行数 * 列数 * 通道数

+ dtype
  + 图像数据类型，通常为uint8

## 目标检测的后处理

+ 目标检测的后处理技术主要是指对目标检测算法的输出进行调整和优化，以提高检测结果的准确性和稳定性。
+ 后处理技术一般包括非极大值抑制（NMS）、筛选、矫正等方法。
+ 非极大值抑制是指对检测框进行去重和筛选，只保留探测到的目标中得分最高的那一个，并抑制周围高度重叠的框。
+ 筛选技术是指判断目标是否符合检测条件，去掉检测到的误检目标或不符合条件的目标。
+ 矫正技术是指对检测框的位置和倾斜角度进行矫正，使得目标在图像中的位置更为精确，提高识别准确性。这些技术通常在目标检测的训练和测试过程中都会使用。

+ 目标检测并不一定需要后处理，但通常情况下会进行后处理来进一步提高模型的准确性和稳定性。后处理技术能够对目标检测的结果进行优化和调整，例如去除重复检测框、筛选、矫正等等
+ 在目标检测中，由于前景和背景的比例极为不平衡，因此检测框往往会出现大量的误检和漏检。后处理技术能够对这些问题进行针对性的处理，提高最终的检测准确率
+ 常用的后处理技术包括非极大值抑制（NMS）、筛选、矫正等。这些技术不仅可以提高目标检测的准确性，还能够缩短检测时间、减少处理数据的复杂度，从而优化算法的整体性能。因此，目标检测中通常会使用后处理技术来优化模型的表现

## NMS(Non-Maximum Suppression)

+ NMS（Non-Maximum Suppression）是目标检测中常用的一种后处理技术，用于去除重复的检测结果，只保留最佳的目标框，从而提高模型精度和效率
+ NMS的原理是基于阈值和重叠率进行筛选。假设模型输出了多个待筛选的检测框，每个检测框都有一个置信度分数，表示该框中包含目标的概率。NMS需要分别对每个类别的检测框进行处理

+ 详细流程如下
  + 首先，按照置信度分数从高到低对检测框进行排序。
  + 取分数最高的检测框A，作为起始框，并从剩余的框里删除A。
  + 按照重叠率的大小判断剩余框中是否与A重叠，若存在则计算它们的IoU值（交并比）。
  + 若IoU值大于预设阈值（一般设为0.5），则将该框从剩余框中删除；若IoU值小于阈值，则保留该框。
  + 重复第2-4步，直到剩余框中没有可删除的框，即所有检测框都被筛选过了。
  + 将剩余的保留框和置信度分数返回。
+ 下面是一个简单的Python实现：
```python3
def nms(detections, threshold=0.5):
    # detections: 待筛选的检测框列表，每个元素为(x1, y1, x2, y2, score)
    # threshold: 阈值，设定IoU值小于阈值的框为非极大值框
    
    if len(detections) == 0:
        return []
    
    # 按照置信度分数从高到低排序
    detections = sorted(detections, key=lambda x: x[4], reverse=True)
    
    # 用于保存最终保留下来的检测框
    keep = []
    
    while len(detections) > 0:
        # 取分数最高的框作为起始框
        A = detections[0]
        keep.append(A)
        
        # 计算该起始框和剩余框的IoU值
        B = detections[1:]
        overlaps = [iou(A, b) for b in B]
        
        # 将IoU值大于阈值的框删除
        indices = [i+1 for i, overlap in enumerate(overlaps) if overlap > threshold]
        detections = [b for i, b in enumerate(detections) if i not in indices]
        
    return keep
```
+ 其中，iou函数用于计算两个框之间的IoU值。

+ 目前有很多对NMS算法的改进方法。下面是几种常见的NMS改进方法：
  + Soft-NMS：传统的NMS是直接抑制掉重叠框中候选框中分数较低的框，而Soft-NMS通过修改分数的方式，将重叠的框的分数逐渐降低。例如，重叠的框的分数会随着IoU值的增加而逐渐减少，而不是直接变为0。这样做可以让模型更加关注可靠的检测结果，避免错判。
  + Adaptive NMS：Adaptive NMS主要是为了解决NMS不同的IoU阈值不适用于不同的物体大小和密度的问题。它引入了一个Adaptive Parameter，该参数会根据候选框大小和样例分布自适应地调整IoU阈值，从而更好地适应不同尺寸的物体目标
  + Soft-NMS with Learnable Weight Scheme：Soft-NMS技术引入了一个权重系数，确定哪些重叠框应该被抑制，而Soft-NMS-LWS则引入了一个学习的权重计算任务，让模型自己学习如何更好地选择重叠框。
+ 这种方法通常会在训练期间学习最佳的权重，并且适用于NMS抑制的具有不同尺度粒度的多个检测结果
+ 这些改进方法的核心思想都是为了更好地处理较为复杂的目标检测情况，例如遮挡和噪声干扰等。同时，这些改进方法还可以进一步提高检测精度并减少误检率，相对于传统的NMS方法表现更出色

+ 目标检测算法中，有些方法可以不需要显式的NMS后处理技术，例如YOLO和SSD（Single Shot MultiBox Detector）。这些方法具有以下特点
  + YOLO：YOLO（You Only Look Once）是一种实时的目标检测算法，它的目标检测过程是在单个神经网络中并行进行的。YOLO将整个图像分成多个网格，每个网格预测出N个边界框及它们的置信度，然后根据置信度和类别得分，筛选出最佳的框。在选择框时，YOLO使用了阈值（置信度分数），减少了重叠框的存在，从而取代了传统的NMS技术。这种方式不仅能够实现快速检测，还能避免高阈值造成的误检和低阈值造成的漏检
  + SSD：SSD（Single Shot MultiBox Detector）也是一种实时目标检测算法，与YOLO类似，它也是将整个图像分成多个网格进行处理。但SSD采用的是先验框机制，通过预设的先验框，让模型更加有效的学到各个物体的形状和大小等特征。在每个网格上，SSD预测出每个先验框的位置和它们所属的类别，然后通过非最大抑制的方式删除一些冗余的框。相比其他的检测算法，SSD是一种速度较快，精度较高的算法。

## 图像处理(维基百科)

+ 图像处理是指对图像进行分析，加工和处理，使其满足视觉，心理或其他要求的技术。图像处理是信号处理在图像领域上的一个应用。目前大多数的图像均是以数字形式存储，因而图像处理很多情况下指数字图像处理。此外，基于光学理论的处理方法依然占有重要的地位。
+ 图像处理是信号处理的子类，另外与计算机科学、人工智能等领域也有密切的关系
+ 传统的一维信号处理的方法和概念很多仍然可以直接应用在图像处理上，比如降噪、量化等。然而，图像属于二维信号，和一维信号相比，它有自己特殊的一面，处理的方式和角度也有所不同

+ 常用的信号处理技术
  + 大多数用于一维信号处理的概念都有其在二维图像信号领域的延伸，它们之中的一部分在二维情形下变得十分复杂。 同时图像处理自身也具有一些新的概念， 例如，连通性、旋转不变性，等等。这些概念仅对二维或更高维的情况下才有非平凡的意义。
  + 图像处理中常用到快速傅立叶变换，因为它可以减小数据处理量和处理时间。

+ 从一维信号处理扩展来的技术和概念
  + 分辨率
  + 动态范围
  + 带宽
  + 滤波器设计
  + 微分算子
  + 边缘检测
  + Domain modulation
  + 降噪(Noise reduction)

+ 专用于二维（或更高维）的技术和概念
  + 连通性
  + 旋转不变性

+ 典型问题
  + 几何变换(geometric transformations): 包括放大，缩小，旋转等
  + 颜色处理(color): 颜色空间的转化，亮度以及对比度的调节，颜色修正等
  + 图像融合(image composite): 多个图像的加，减，组合，拼接等
  + 降噪(image denoising): 研究各种针对二维图像的去噪滤波器或者信号处理技术
  + 边缘检测: 进行边缘或者其他局部特征提取
  + 分割: 依据不同标准，把二维图像分割成不同区域
  + 图像编辑: 和计算机图形学有一定交叉
  + 图像配准: 比较或集成不同条件下获取的图像
  + 图像增强(image enhancement)
  + 图像数字水印: 研究图像域的数据隐藏，加密或者认证
  + 图像压缩: 研究图像压缩

+ 应用
  + 摄影以及印刷
  + 卫星图像处理(Statellite image processing)
  + 医学图像处理(Medical image processing)
  + 面孔识别，特征识别(Face detection, feature detection, face identification)
  + 显微图像处理(Microscope image processing)
  + 汽车障碍识别(Car barrier detection)