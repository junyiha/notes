## 任务 -- 图片编码成jpeg并保存

+ 常用命令：
 
  ```
    cp -r ../ubuntu1604/CV183x .

    ./configure.sh -c CV183X -p aarch64 -g

    bash ssh-1838.sh

    scp user@192.167.15.58:/home/user/workspace/vca_learn-workspace/video_process/build/test.exe ./test_enc.exe

    export LD_LIBRARY_PATH=/data/picture/VideoProcess/3party/lib:/data/picture/VideoProcess/lib:/mnt/flash/Server/lib/:$LD_LIBRARY_PATH

    gdbserver :9999 test_enc.exe test_ffmpeg --src MAH00433.mp4

    scp -r imgs/ user@192.167.15.58:/tmp/
  ```

+ 参考例子的编码部分
  + sample_venc_lib.c : 1387 non-bind mode, source frame either comes from file or VPSS
  + sample_multivenc.c : 437 encode_loop

### 遇到的基础概念：

+ 编码，就是输入一个数据帧，然后将该帧编码成数据包

+ 通过接口使用物理设备，
+ 每一个物理设备都有一个设备号，一一对应，指定哪一个设备号就是用哪一个设备

+ 编码器，解码器 工作原理和底层实现
  + 一直工作，关于流，没有停止，是一个个数据，只是编译器定义某一段为一帧或一个数据包

### 任务关键点

+ 经过测试，
  + 接收解码出来，不经过VPPS处理的数据帧，编码出来的图片是正常的
  + 接收解码出来，再经过VPPS处理的数据帧（直接将从VPPS处理通道中取出来的数据帧发送到编码通道），编码出来的图片则是不正常的

+ 大致结论（V1.0）：
  + 在例子中对于接收编码的数据，有两种模式：绑定模式和非绑定模式
    + 绑定模式：编码器和视频处理子系统（VPSS）绑定，需要取的数据帧是在VPSS通道中直接送入到编码通道中
    + 非绑定模式：不绑定VPSS，直接将`VIDEO_FRAME_INFO_S`结构体发送到通道中
  + 之前一直出错的原因在于，对于VPSS处理获取到的数据帧，**是直接送到编码通道中的，而不是通过绑定的方式**，所以晶视已经存在编码器和视频处理子系统设备绑定，可能就不支持直接将VPSS处理后生成的数据帧手动发送到编码器中

+ 

---------------------------------------------------------------------------

## 概述

+ `CVITEK` 所提供的多媒体软件架构（`Multimedia Framework`， 简称 `MMF`），用以缩短应用程序开发所需的时间。 此架构屏蔽了芯片端的复杂底层设计和差异，对应用程序提供统一且便捷的MMF Programming Interface编程接口。 MMF 包含了以下功能： 
  + ISP 影像前处理（包含 HDR、去噪、边缘锐化等）
  + 输入影像撷取及输出
  + 图像几何校正
  + H.265/ H.264/JPEG 编解码
  + 音频撷取及输出
  + 音频编解码等

+ 定义及缩写
  + MMF   -- `Multimedia Framework`      --  多媒体软件架构
  + ISP   -- `Image Signal Processor`    --  影像处理处理器
  + VI    -- `Video Input`               --  影像输入
  + VPSS  -- `Video Process Sub-System`  --  影像处理子系统
  + VO    -- `Video Output`              --  影像输出
  + VDEC  -- `Video Decoder`             --  影像解码
  + VENC  -- `Video Encoder`             --  影像编码
  + MIPI  -- `Mobile Industry Processor Interface` -- 移动行业处理器接口

+ 内部主要处理流程：
  + VI 捕捉视频图像，可对其做剪切、影像优化等处理后，再将图像数据传递给VPSS 处理
  + **VDEC 将编码后的码流解码，再将图像数据传递给 VPSS 处理**
  + **VPSS 接收 VI 或 VDEC 发送的图像，并可同时输出多个不同分辨率的图像，以供预览、编码或抓拍**
  + VO 接收 VPSS 处理后的图像，并根据设定的时序输出到显示设备
  + REGION 可以将用户所指定的位图（Bitmap）作为 OSD 叠加到图像数据上

+ 系统绑定
  + SDK 提供系统绑定接口（`CVI_SYS_Bind`） ，即通过绑定数据源和数据接收者来建立两者之间的关联关系。 **绑定后，数据源生成的数据将自动发送给接收者**。 
  + 一个数据源可以绑定多个数据接收者，若数据源未绑定，则最终会自动返回视频内存区块池
  + 同一个数据接收者只能绑定一个数据源
  + VI 和 VDEC 作为数据源,是以通道为发送者,向其他模块发送数据,用户将设备号置为 0,SDK 不检查输入的设备号
  + VPSS 作为数据接收者时,是以设备(GROUP)为接收者,接收其他模块发来的数据,用户将通道号置为 0
  + 其他情况均需指定设备号和通道号

+ 智能盒子上的视频文件相关应用
  + 存储介质 --》 VDEC --》 VPSS --》 VENC --》 压缩码流或存储介质
  + 存储介质或压缩码流 --》 VDEC --》 VPSS --》VO --》 显示屏

--------------------------------------------------------------------------------------------------------------------------------

## 结构体

+ VDEC_CHN_ATTR_S
  + MMF文档：273页

--------------------------------------------------------------------------------------------------------------------------------

## 视频解码(VDEC)

### 概述

+ 文档256页

+ VDEC模块提供驱动视频解码硬件工作的对应接口，实现**视频解码功能**

+ 定义及缩写
  + VDEC            -- Video Decoder，视频解码器
  + Output Order    -- 输出顺序
  + Decoding Order  -- 解码顺序
  + Displayer Order -- 播放顺序
  + Frame           -- 帧
  + Stream          -- 码流

+ 图像输出方式
  + 按照H.264/H.265视频标准，输入的Stream经解码之后，输出的影像顺序未必等于输入的顺序，因此在播放时会分为Decoding order 和 Display order
    + Decoding order -- 输出影像的顺序等于输入Stream的顺序
    + Display Order  -- 输出影像的顺序等于最后播放的顺序

### CVI_VDEC_CreateChn

+ 原型：`CVI_S32 CVI_VDEC_CreateChn(VDEC_CHN VdChn, const VDEC_CHN_ATTR_S *pstAttr);`
+ 参数：
  + CVI_S32  -- typedef int CVI_S32
  + VdChn  --  输入， 视频解码通道号
  + pstAttr -- 输入， 解码通道属性指针
+ 返回值：
  + CVI_SUCCESS 成功
  + 非0         失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 系统内存不足时，返回`HI_ERR_VDEC_NOMEM` 错误码
  + **使用JPEG/MJPEG时**，要在创建解码信道（通道）之前要先创建专属于VDEC的模块VB池，不同协议解码所需要的图像VB块大小不同，参考`sample_vdec_lib.c`内的`vdecInitVBPool`函数
  + **H264 H265内核已经保留了memory， 所以不需要调用VB函数**
+ 示例代码：
  + `/sample/common/sample_common_vdec.c:720:`

### CVI_VDEC_DestoryChn

+ 原型：`CVI_S32 CVI_VDEC_DestoryChn(VDEC_CHN VdChn);`
+ 参数：
  + VdChn -- 视频解码通道号 - 输入
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 销毁前必须保证通道已经创建，否则会返回通道未创建错误
  + 销毁前必须停止接收码流（或者尚未开始接收码流）否则返回错误

### CVI_VDEC_GetChnAttr

+ 原型：`CVI_S32 CVI_VDEC_GetChnAttr(VDEC_CHN VdChn, VDEC_CHN_ATTR_S *pstAttr)`
+ 功能：获取视频解码通道属性
+ 参数：
  + VdChn  -- 视频解码通道号  -- 输入
  + pstAttr -- 解码通道属性指针 -- **输出**
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + VDEC通道必须已经创建
  + 此函数通常在CVI_VDEC_SetChnAttr前使用，或者是在获取decoder frame之前调用，以确认通道正常
+ 举例
  + `sample_common_vdec.c`内的`SAMPLE_COMM_VDEC-GetPic()`函数（587）

### CVI_VDEC_SetChnAttr

+ 原型：`CVI_S32 CVI_VDEC_SetChnAttr(VDEC_CHN VdChn, const VDEC_CHN_ATTR_S *pstAttr);`
+ 功能：设置视频解码通道属性
+ 参数：
  + VdChn  -- 视频解码通道号 -- 输入
  + pstAttr -- 解码通道属性指针 -- 输入
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意：
  + VDEC通道必须已经创建
  + 切换通道属性之前必须先停止接收码流，否则返回错误

### CVI_VDEC_StartRecvStream

+ 原型：`CVI_S32 CVI_VDEC_StartRecvStream(VDEC_CHN VdChn);`
+ 功能：解码器开始接收用户发送的码流
+ 参数
  + VdChn  -- 视频解码通道号  -- 输入
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 启动接收码流前必须保证通道已经创建，否则会返回错误

### CVI_VDEC_StopRecvStream

+ 原型：`CVI_S32 CVI_VDEC_StopRecvStream(VDEC_CHN VdChn);`
+ 功能：解码器停止接收用户发送的码流
+ 参数
  + VdChn  -- 视频解码通道号  -- 输入
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 调用此接口，必须在CVI_VDEC_DestoryChn之前

### CVI_VDEC_QueryStatus

+ 原型：`CVI_S32 CVI_VDEC_QueryStatus(VDEC_CHN VdChn, VDEC_CHN_STATUS_S *pstStatus);`
+ 功能：查询解码通道状态
+ 参数
  + VdChn  -- 视频解码通道号  -- 输入
  + pstStatus  -- 视频解码通道状态结构体指针  -- **输出**
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 启动接收码流前必须保证通道已经创建，否则会返回错误
+ 参阅`sample_common_vdec.c`内的`SAMPLE_COMM_VDEC_CmdCtrl`用法

### CVI_VDEC_SetChnParam

+ 原型：`CVI_S32 CVI_VDEC_SetChnParam(VDEC_CHN VdChn, const VDEC_CHN_PARAM_S *pstPrarm);`
+ 功能：设置解码通道参数
+ 参数
  + VdChn  -- 视频解码通道号 -- 输入
  + pstParaqm  --  通道参数  -- 输入
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 启动接收码流前必须保证通道已经创建，否则会返回错误

### CVI_VDEC_GetChnParam

+ 原型：`CVI_S32 CVI_VDEC_GetChnParam(VDEC_CHN VdChn, const VDEC_CHN_PARAM_S *pstPrarm);`
+ 功能：获取解码通道参数
+ 参数
  + VdChn  -- 视频解码通道号 -- 输入
  + pstParaqm  --  通道参数  -- **输出**
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 启动接收码流前必须保证通道已经创建，否则会返回错误

### CVI_VDEC_SendStream

+ 原型：`CVI_S32 CVI_VDEC_SendStream(VDEC_CHN VdChn, const VDEC_STREAM_S *pstStream, CVI_S32 s32MilliSec);`
+ 功能：发送码流数据至视频解码通道
+ 参数：
  + VdChn  -- 视频解码通道号 -- 输入
  + pstStream  -- 解码码流数据指针 -- 输入
  + s32MilliSec  -- 送码流方式标志  -- 输入  
    + 取址范围： -1， 阻塞
+ 返回值
  + CVI_SUCCESS -- 成功
  + 非0         -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + **发送数据前必须保证已经调用`CVI_VDEC_CreateChn`, `CVI_VDEC_StartRecvStream`**
  + 此接口在mjpeg， jpeg译码状态下，送入长度0（pstStream->u32Len)会返回CVI_SUCCESS
  + 译码失败会回传错误码：`ERR_CVI_VDEC_SEND_STREAM`

### CVI_VDEC_GetFrame

+ 原型：`CVI_S32 CVI_VDEC_GetFrame(VDEC_CHN VdChn, VIDEO_FRAME_INFO_S *pstFrameInfo, CVI_S32 s32MilliSec);`
+ 功能：获取视频解码通道的解码图像
+ 参数：
  + VdChn         -- 视频解码通道号     -- 输入
  + s32MilliSec   -- 获取图像方式标志   -- 输入
    + 取值范围： -1 ， 阻塞
  + pstFrameInfo  -- 获取的解码图像信息  -- 输出
+ 返回值
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意
  + 启动接收码流前必须保证通道已经创建，否则会返回错误

### CVI_VDEC_ReleaseFrame

+ 原型：`CVI_S32 CVI_VDEC_ReleaseFrame(VDEC_CHN VdChn, const VIDEO_FRAME_INFO_S *pstFrameInfo);`
+ 功能：释放视频解码通道的图像
+ 参数
  + VdChn         -- 视频解码通道号       -- 输入
  + pstFrameInfo  -- 解码后的图像信息指针  -- 输入
+ 返回值
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求：
  + cvi_vdec.h  cvi_comm_video.h  cvi_comm_vdec.h
  + libvdec.so / libvdec.a
+ 注意：
  + 此接口需要和CVI_VDEC_GetFrame配对使用，获取的数据应当在使用完之后立即释放，如果不立即释放，会导致解码过程阻塞等待资源
  + 释放的数据必须是CVI_VDEC_GetFrame从该通道获取的数据，不得对数据信息结构体进行任何修改
  + 释放视频解码通道的图像必须在通道销毁之前。

--------------------------------------------------------------------------------------------------------------------------------

## 编码

### 概述

+ 文档：193页

+ 视频编码主要提供视频及时编码，将输入信号源影像经过标准影音编码器作压缩，降
低数据量，提供应用层影音服务

+ 目前有支持的输入源为：
  + 用户在 `User Mode` 自行输入的影像资料
  + 视频输入（`VI`）模块收到的影像直接发送到编码器
  + 视频输入（`VI`）模块收到的影像经视频处理子系统（`VPSS`）发送到编码器

+ 目前支持的视频标准为
  + JPEG
  + MJPEG
  + H.264
  + H.265

+ 定义及缩写
  + `Bitrate`           -- 比特率
  + `Fixed QP`          -- 固定 QP
  + `Frame --`          -- 帧
  + `Packet --`         -- 包
  + `Frame Buffer`      -- 帧存
  + `Video Quality`     -- 图像质量
  + `MB Macroblcok`     -- 宏块
  + `RC Rate Control`   -- 码率控制器RC Rate Control码率控制器
  + `Encoded Bitstream` -- 编码流
  + `VBR Variable Bitrate` -- 可变码率
  + `CBR Constant Bitrate` -- 固定码率
  + `QP Quantization Parameter` -- 量化参数

+ VENC 模块的输入为待编码的图像，输出为编码后的 Bitstream。 VENC 含有两个子模组，Receiver和Encoder。
  
+ Receiver
  + 接收影像的输入

+ Encoder
  + 将收到的影像进行图片及视频编码，转换成 Encoded Bitstream，目前支持的视频标准为
  + JPEG
    + 支持的图像格式为
    + YUV422
    + YUV420
  + MJPEG
    + 支持的图像格式和 JPEG 相同
  + H.264
    + 支持的图像格式为
    + YUV420
  + H.265
    + 支持的图像格式为
    + YUV420

+ 视频编码通道
  + 视频编码通道为视频编码的基本操作单元，内部主要包含VENC相关功能，通道相关设定。 
  + 系统上可以有多个视频编码通道，各通道独立运作。 
  + 各通道建立后，用户可按需求设置通道基本参数，如图像分辨率、编码 Bitrate、RC 机制... 等，相关的参数会对VENC初始化

+ 码率控制
  + RC 为 Encoder 中控制 Bitrate 和 Video Quality 的主要模块，主要藉由各视讯标准中的 QP 这个参数，进一步控制影像质量，
  + 当 QP 变大时，编码出来的资料量会变小，但 Video Quality 会变差; 
  + 当 QP 变小时，编码出来的资料量会变大，但 VideoQuality 会变好
  + 视频编码通常会与 RC 同时运作，如果是图片编码 （如 JPEG），因为只有单张图片，不会需要此模块

+ Fixed QP
  + 在统计时间内，影像中的所有 MB 使用同一个 QP 值。

+ 编码码流帧配置模式
  + 压缩后的编码码流，使用CVI_VENC_GetStream取得Encoded Bitstream，相关资讯如下
  + u32PackCount
    + 此张 Frame 含有多少个 NAL packet，例如目前压缩格式为 H.264，第一张为 I frame， 此值会为 3 （含 SPS，PPS，1 Slice），第二张 Frame 为 1（含 1Slice)
  + pstPack
    + 根据 u32PackCount 的数量，会含有 pstPack[0] ~

+ 多编码器并行编码
  + H.264 和 H.265 支持多路编码，目前默认最多为 8 路并行编码，以下为注意事项
  + 编码整体性能需要低于硬件设计限制，超过会无法达到设定的 framerate
  + 所需要的 Frame Buffer 会随着路数的增加成正比增加，DRAM 使用量亦随之增加

### CVI_VENC_CreateChn

+ 原型：`CVI_S32 CVI_VENC_CreateChn (VENC_CHN VeChn, const VENC_CHN_ATTR_S *pstAttr);`
+ 功能：创建编码通道
+ 参数：
  + `VeChn`    -- VENC Channel 号         --  输入
  + `pstAttr`  -- VENC_CHN_ATTR_S 属性指针 --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 通道属性分为三个结构：
    + `VENC_ATTR_S`: 决定编码属性,**此属性决定编码协议并赋值设定对应宽，高**
    + `VENC_RC_ATTR_S`:码率控制器属性， 此属性随编码设定及码率控制模式 （CBR、VBR、FIXQP）不同对应子结构做设定
    + `VENC_GOP_ATTR_S`: GOP 类型属性,编码 GOP 类型(编码单参考帧,P帧, GOP 类型。)
    + 推荐的编码宽高为: 3840x2160(4k)、1920x1080(1080P)、1280x720(720P)
  + 用户可参阅 `sample_common_venc.c` 内 `SAMPLE_COMM_VENC_SetChnAttr`参考对应属性指针的设定

### CVI_VENC_DestroyChn

+ 原型：`CVI_S32 CVI_VENC_DestroyChn (VENC_CHN VeChn);`
+ 功能：销毁编码通道
+ 参数：
  + `VeChn`  -- VENC Channel 号  -- 输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 销毁并不存在的通道,将返回失败
  + 可参阅 `sample_common_venc.c`,销毁通道前必须停止传送 frame

### CVI_ VENC_StartRecvFrame

+ 原型：`CVI_S32 CVI_VENC_StartRecvFrame(VENC_CHN VeChn, const VENC_RECV_PIC_PARAM_S *pstRecvParam);`
+ 功能：开启编码通道接收输入图像,允许指定接收帧数,**超出指定的帧数后自动停止接收图像**
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstRecvParam`  --  接收图像参数结构体指针,用于指定需要接收的图像帧数  --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 如果通道未创建,则返回失败
  + **开启编码器接收之后才能开始接收图像编码**
  + 可參照 `sample_common_venc.c` 內 `SAMPLE_COMM_VENC_Start` 函式

### CVI_ VENC_StopRecvFrame

+ 原型：`CVI_S32 CVI_VENC_StopRecvFrame(VENC_CHN VeChn);`
+ 功能：停止编码通道接收输入图像。
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 通道销毁前,需调用 `CVI_VENC_StopRecvFrame`
  + 如通道未创建或通道已销毁,则返回失败
  + **调用此接口仅停止接收原始数据编码,码流 buffer 并不会被清除**
  + 此接口用于编码通道停止接收图像来编码,**在编码通道销毁或复位前必须停止接收图像**
  + 可參照 `sample_common_venc.c` 內 `SAMPLE_COMM_VENC_Stop` 函式

### CVI_VENC_QueryStatus

+ 原型：`CVI_S32 CVI_VENC_QueryStatus(VENC_CHN VeChn, VENC_CHN_STATUS_S *pstStatus);`
+ 功能：查询编码通道状态。
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstStatus`  --  编码通道的状态指针。 --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 如果通道未创建,则返回失败
  + 在编码通道状态结构体中,**`u32CurPacks` 表示当前帧的码流包个数**。在调用`CVI_VENC_GetStream` 之前应确保 `u32CurPacks` 大于 0

### CVI_VENC_SendFrame

+ 原型：`CVI_S32 CVI_VENC_SendFrame(VENC_CHN VeChn, const VIDEO_FRAME_INFO_S *pstFrame, CVI_S32 S32MilliSec);`
+ 功能：送出影像以供编码
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstFrame`  --  VIDEO_FRAME_INFO_S 属性指针  --  输入
  + `S32MilliSec`  --  发送图像超时时间,取值范围:[-1,+∞ ) | -1:阻塞 | 0:非阻塞 | 大于0:超时时间。--  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + 此接口支持用户发送图像至编码通道，以进行编码
  + 调用该接口发送图像,用户需要保证编码通道已创建且开启接收输入图像
  + 可參照 `sample_venc_lib.c` 內 `SAMPLE_VENC_GetVencStreamProc`

### CVI_VENC_GetStream

+ 原型：`CVI_S32 CVI_VENC_GetStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream, CVI_S32 S32MilliSec);`
+ 功能：获取编码的码流。
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstFrame`  --  码流结构体指针  --  输出
  + `S32MilliSec`  --  发送图像超时时间,取值范围:[-1,+∞ ) | -1:阻塞 | 0:非阻塞 | 大于0:超时时间。--  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意:
  + venc 通道必须先创建,否则此函式会回传错误
  + 在非 `bind mode` 状况下,`CVI_VENC_SendFrame` 必须有调用过,否则`CVI_VENC_GetStream` 将无法获得码流结构
  + `CVI_VENC_GetStream` 调用之前,可以搭配 `CVI_VENC_GetChnAttr`,`CVI_VENC_QueryStatus` 调用确保编码信道当下的正确性
  + 码流结构体 `VENC_STREAM_S` 包含 4 个部分
    + 码流包信息指针 `pstPack` --  指向一组 `VENC_PACK_S` 的内存空间,**该空间由调用者分配**。注意:`pstPack` 空间必须在调用`CVI_VENC_GetStream` 前给予对应空间,否则将回传错误
  + 可參照 `sample_venc_lib.c` 內的 `SAMPLE_VENC_GetVencStreamProc`

### CVI _ VENC_ReleaseStream

+ 原型：`CVI_S32 CVI_VENC_ReleaseStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream);
+ 功能：释放码流缓存
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstFrame`  --  码流结构体指针  --  输出
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意：
  + 请确认 `venc` 通道已创建
  + 请确认 `CVI_VENC_ReleaseStream` 在 `CVI_VENC_GetStream` 之后,**若提前调用`CVI_VENC_ReleaseStream`,则 `CVI_VENC_GetStream` `将不具备取得正确stream` 保证**
  + 用户获取码流后必须及时释放已经获取的码流缓存,否则可能会导致码流`buffer` 满,影响编码器编码

### CVI_VENC_GetChnParam

+ 原型：`CVI_S32 CVI_VENC_GetChnParam(VENC_CHN VeChn, VENC_CHN_PARAM_S *pstChnParam);`
+ 功能：获取通道参数。
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstChnParam`  --  Venc 的通道参数指针  --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a

### CVI_VENC_SetChnParam

+ 原型：`CVI_S32 CVI_VENC_SetChnParam(VENC_CHN VeChn, const VENC_CHN_PARAM_S *pstChnParam);`
+ 功能：设置通道参数。
+ 参数：
  + `VeChn`  --  编码通道号  --  输入
  + `pstChnParam`  --  Venc 的通道参数指针  --  输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_venc.h、cvi_venc.h
  + 库文件:libvenc.a
+ 注意：
  + 本接口在编码通道创建之后,编码通道销毁之前调用
  + 此函数呼叫于`CVI_VENC_CreateChn` 之后
  + 此函数API参数支持venc crop设置，其使用参数为
    + VENC_CHN_PARAM_S,stCropCfg。 可设定对应的 x，y 轴及宽（width），高（height）

--------------------------------------------------------------------------------------------------------------------------------

## 视频处理子系统(VPSS) -- API参考

### CVI_VPSS_GetChnFrame

+ 原型:`CVI_S32 CVI_VPSS_GetChnFrame(VPSS_GRP VpssGrp, VPSS_CHN VpssChn, VIDEO_FRAME_INFO_S *pstFrameInfo, CVI_S32 s32MilliSec);`
+ 功能:用户从通道获取一帧处理完成的图像
+ 参数:
  + VpssGrp  -- VPSS GROUP 号,取值范围:`[0,VPSS_MAX_GRP_NUM]`  -- 输入
  + VpssChn  -- VPSS 通道号，取值范围:`[0,VPSS_MAX_CHN_NUM]`    -- 输入
  + pstVideoFrame  -- 待发送的图像信息（详解在系统控制章节）  -- **输出**
  + s32MilliSec  --  超时时间  -- 输入
+ 返回值:
  + CVI_SUCCESS   -- 成功
  + 非0           -- 失败，其值为错误码
+ 需求:
  + 头文件:cvi_comm_vpss.h、cvi_vpss.h
  + 库文件:libvpu.a
+ 注意:
  + Group 必须已经创建
  + **该函数将获得的图像信息保存在 pstvideoFrame 里面,并包含了图像的虚拟地址和物理地址**

+ `VENC_CHN_ATTR_S::VENC_ATTR_S`:决定编码属性,此属性决定编码协议并赋值设定对应宽，高

