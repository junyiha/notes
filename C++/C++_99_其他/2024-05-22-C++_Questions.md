---
category: Cpp
date: 2024-05-22 09:00:00 +0800
layout: post
title: C++_Questions
tag: CppOthers
---
## 简介

+ C++面试 问题

## 左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么

+ 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。
  + 左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
  + 右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。

+ 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。
  + 纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值
+ 需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。

## C++ 右值引用 详解

C++11引入了右值引用（Rvalue References）的概念，它是C++中一种新的引用类型，用于支持移动语义（Move Semantics）和完美转发（Perfect Forwarding）。右值引用与传统的左值引用（Lvalue References）有所不同，主要用于优化移动语义和避免临时对象的不必要拷贝。下面是关于右值引用的详细解释：

### 1. 右值引用的语法：

右值引用的语法是在类型名后添加 &&，表示对右值的引用。例如：

```cpp
int&& rvref = 42;  // rvref 是对右值 42 的引用
```

### 2. 移动语义（Move Semantics）：

移动语义是指将资源从一个对象转移到另一个对象，而不是进行深拷贝。右值引用使得我们可以区分左值和右值，并且能够在移动语义下实现高效的资源转移。

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1);  // 移动 v1 到 v2，v1 变为空
```

### 3. 完美转发（Perfect Forwarding）：

完美转发是指在函数模板中保留函数调用时的精确类型信息。右值引用在完美转发中发挥着重要作用，允许在不丢失值类别（value category）信息的情况下将参数传递给其他函数。

```cpp
template <typename T>
void forwarder(T&& arg) {
    target(std::forward<T>(arg));  // 保留 arg 的值类别信息进行转发
}
```

### 4. std::move() 函数：

std::move() 是一个用于将左值转换为右值引用的函数，它并不移动对象，而只是改变对象的类型，使其可以绑定到移动构造函数或移动赋值运算符。

```cpp
std::vector<int> v = {1, 2, 3};
std::vector<int> v2 = std::move(v);  // 将 v 转为右值引用，调用移动构造函数
```

### 5. 注意事项：

- 在使用右值引用时要谨慎，确保不会访问到已经被移动的对象。
- 尽量使用 std::move() 来明确表达对象的移动语义，以提高代码的可读性和性能。

右值引用的引入使得C++具备了更加灵活和高效的资源管理能力，可以在不牺牲性能的情况下实现资源的有效转移和管理，是C++11引入的一个重要特性。

## C++ 协程 详解

C++20引入了协程（Coroutines）的概念，它是一种轻量级的并发编程模型，可以简化异步编程和状态机的实现。协程允许在函数内部通过暂停和恢复的方式来控制执行流程，从而实现异步操作、生成器和状态机等功能。下面是关于C++协程的详细解释：

### 1. 协程的基本概念：

- **生成器（Generator）**：协程可以用于实现生成器，即能够生成一系列值的函数，每次调用都可以产生一个新值，并在下次调用时继续执行。
- **异步操作（Asynchronous Operations）**：协程可以用于实现异步操作，即函数可以在执行过程中暂停等待异步操作的结果，并在异步操作完成后恢复执行。
- **状态机（State Machines）**：协程可以用于实现状态机，即函数可以在不同的状态之间切换，并在每个状态下执行不同的逻辑。

### 2. C++20 中的协程支持：

C++20 引入了 `co_await`、`co_yield`、`co_return` 等关键字，用于定义和控制协程。协程的定义通过 `co_return` 关键字返回一个协程类型（如 `std::coroutine_handle`），并使用 `co_await` 和 `co_yield` 控制执行流程。

```cpp
#include <iostream>
#include <coroutine>

struct MyCoroutine {
    struct promise_type {
        int value;
        auto initial_suspend() { return std::suspend_never{}; }
        auto final_suspend() { return std::suspend_always{}; }
        MyCoroutine get_return_object() { return {}; }
        void unhandled_exception() {}
        void return_value(int v) { value = v; }
    };

    bool await_ready() { return false; }
    void await_suspend(std::coroutine_handle<> h) {}
    int await_resume() { return 42; }
};

MyCoroutine foo() {
    co_return 42;
}

int main() {
    MyCoroutine c = foo();
    std::cout << "Result: " << c.await_resume() << std::endl;  // 输出 42
    return 0;
}
```

### 3. 使用协程的注意事项：

- 协程是一种特殊的函数类型，定义和使用方式与普通函数略有不同，需要熟悉相关语法和约定。
- 协程的执行流程是可以暂停和恢复的，需要谨慎处理协程中的状态和资源管理问题，避免出现悬空指针和资源泄漏等问题。
- 协程可以有效地简化异步编程和状态机的实现，但也需要考虑其对性能和可维护性的影响。

总的来说，C++协程是一种强大的并发编程工具，可以简化异步编程和状态机的实现，提高代码的可读性和可维护性。通过合理地使用协程，可以实现更加简洁和高效的异步代码，提高程序的性能和响应性。

## 进程 线程 协程 之间的区别 详解

进程（Process）、线程（Thread）和协程（Coroutine）是计算机中用于实现并发的三种重要机制，它们在管理和利用计算机资源方面有着不同的特点和应用场景。下面是对进程、线程和协程之间的区别进行详细解释：

### 1. 进程（Process）：

- **定义**：进程是计算机中执行中的程序的实例，它拥有独立的内存空间、代码和数据，并且由操作系统进行管理。
- **特点**：
  - 独立性：每个进程拥有独立的内存空间，不同进程之间无法直接共享内存数据。
  - 安全性：进程之间的内存空间是隔离的，可以保证数据的安全性和稳定性。
  - 并发性：多个进程可以并发执行，由操作系统进行调度和管理，互相之间不会影响。
- **应用场景**：进程常用于实现多任务、多用户和多进程通信等需求，例如操作系统中的进程管理和应用程序的并发执行。

### 2. 线程（Thread）：

- **定义**：线程是操作系统中最小的执行单元，它是进程的一个执行流程，拥有独立的执行栈和程序计数器，但共享相同的进程地址空间和资源。
- **特点**：
  - 共享性：线程之间共享相同的内存空间和资源，可以方便地进行数据共享和通信。
  - 轻量级：相比于进程，线程的创建和切换成本较低，可以更高效地实现并发操作。
  - 并发性：多个线程可以并发执行，共享进程的资源，但需要注意线程安全性问题。
- **应用场景**：线程常用于实现多线程编程、并行计算和异步任务处理等需求，例如多线程服务器、图形界面程序和网络通信等。

### 3. 协程（Coroutine）：

- **定义**：协程是一种用户态的轻量级线程，它可以在函数内部实现暂停和恢复执行流程，不需要操作系统的调度和管理。
- **特点**：
  - 用户态实现：协程是在用户态下实现的，不依赖于操作系统的线程和进程调度，具有较低的开销和更高的灵活性。
  - 非抢占式：协程不会被强制中断，而是由程序员显式地控制协程的暂停和恢复，可以更灵活地管理执行流程。
  - 轻量级：相比于线程和进程，协程的创建和切换成本更低，适用于大量的并发任务和高频的状态切换。
- **应用场景**：协程常用于实现异步编程、状态机和生成器等需求，例如事件驱动编程、协作式任务调度和高效的生成器实现。

### 总结：

- 进程、线程和协程是实现并发编程的三种主要机制，各自具有不同的特点和应用场景。
- 进程提供了独立的执行环境和安全的数据隔离，适用于多任务和多用户的场景。
- 线程提供了共享的执行环境和资源，可以更高效地实现并发操作和数据共享。
- 协程提供了用户态的轻量级并发机制，可以实现高效的异步编程和状态机，适用于需要大量的并发任务和高频的状态切换的场景。

## 什么是多态

+ 术语--**多态**，指的是有多种形式，因此函数多态允许函数可以有多种形式。
+ 在了解多态之前，需要了解虚函数
  + 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
  + 虚函数是指**一个类中希望重载的成员函数**，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。
  + 而函数重载，是允许参数不同，但函数名相同。函数重载的关键是函数的参数列表--也称为**函数特征标**(`function signature`)。
  + 如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。
  + **C++允许定义名称相同的函数，条件是它们的特征标不同**。如果参数数目和/或参数类型不同，则特征标也不同。
+ 同一代码可以产生不同效果的特点，称为“多态”

## 虚函数和纯虚函数

+ 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
+ 虚函数是C++中用于实现多态(`polymorphism`)的机制，核心理念就是通过基类访问派生类定义的函数。

+ 注意：在普通的虚函数后面加上`=0`，这样就声明了一个纯虚函数(`pure virtual function`)
+ 纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们**派生类都会有这个函数**

+ 在什么情况下使用纯虚函数？
  - 当想在基类中**抽象出一个方法，且该基类只能被继承，而不能被实例化时**
  - 这个方法**必须在派生类中被实现**
+ 如果满足以上两点，可以考虑将该方法被声明为纯虚函数

+ 当一个类打算被用作其他类的基类时，**它的析构函数必须是虚的**

## 虚函数和纯虚函数的区别 详解

虚函数（Virtual Function）和纯虚函数（Pure Virtual Function）都是用于实现多态性的重要机制，但它们有一些关键的区别。

### 虚函数（Virtual Function）：

1. **定义**：虚函数是在基类中使用 `virtual` 关键字声明的成员函数，它可以被派生类重写（覆盖）。

2. **实现**：虚函数可以在基类中提供默认的实现，但派生类可以选择是否覆盖它。如果派生类覆盖了虚函数，则在运行时根据对象的实际类型来调用对应的函数。

3. **语法**：虚函数可以有实现，也可以没有实现。如果在基类中定义了虚函数的实现，派生类可以选择是否覆盖该函数；如果在基类中定义了纯虚函数，派生类必须实现该函数。

4. **示例**：

```cpp
class Base {
public:
    virtual void display() {
        cout << "Display from Base" << endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        cout << "Display from Derived" << endl;
    }
};
```

### 纯虚函数（Pure Virtual Function）：

1. **定义**：纯虚函数是在基类中声明但没有提供实现的虚函数，它在基类中不具有实际的功能，而是为了让派生类必须提供实现。

2. **实现**：派生类必须实现基类中定义的纯虚函数，否则派生类也会成为抽象类。

3. **语法**：纯虚函数用 `virtual` 关键字声明，并在后面添加 `= 0` 来表示该函数是纯虚函数。

4. **示例**：

```cpp
class Base {
public:
    virtual void display() = 0; // 纯虚函数声明
};

class Derived : public Base {
public:
    void display() override {
        cout << "Display from Derived" << endl;
    }
};
```

### 区别总结：

1. 虚函数可以有实现，派生类可以选择是否覆盖；纯虚函数没有实现，派生类必须提供实现。
2. 虚函数用 `virtual` 关键字声明；纯虚函数用 `virtual` 关键字声明并在后面添加 `= 0`。
3. 基类中含有纯虚函数的类被称为抽象类，不能创建实例对象；而含有虚函数的类可以创建实例对象。
4. 使用虚函数的目的是实现运行时多态，而使用纯虚函数的目的是定义接口，强制派生类实现特定的行为。

## C++ 虚函数和纯虚函数的实际应用

虚函数和纯虚函数在 C++ 中有着广泛的实际应用，它们主要用于实现多态性和定义接口，以下是它们的一些常见实际应用：

### 虚函数的实际应用：

1. **实现运行时多态性**：虚函数允许在基类中定义函数的行为，而派生类可以根据自己的需要覆盖（重写）这些函数，从而实现基于对象的实际类型的动态调用。

2. **实现基类的默认行为**：基类中的虚函数可以提供默认的行为，派生类可以选择是否覆盖它们。这样可以在基类中提供一些通用的实现，而在派生类中根据需要进行特化。

3. **方便的扩展**：通过在基类中添加虚函数，可以方便地在派生类中添加新的行为，而不需要修改基类的定义。

4. **实现抽象类**：虚函数可以使基类成为抽象类，即含有至少一个纯虚函数的类，抽象类不能创建对象，只能用作接口的定义。

### 纯虚函数的实际应用：

1. **定义接口**：纯虚函数用于定义接口，强制派生类实现特定的行为。基类中的纯虚函数提供了一种规范，告诉派生类必须提供的函数接口。

2. **实现多继承的接口**：纯虚函数可以用于实现多继承的接口，一个类可以继承多个含有纯虚函数的抽象类，并提供它们的具体实现。

3. **防止实例化抽象类**：含有纯虚函数的类被称为抽象类，抽象类不能创建实例对象，但可以被用作基类，派生类必须实现所有纯虚函数才能被实例化。

4. **提供默认行为**：纯虚函数可以提供基类中的默认行为，派生类可以选择是否覆盖它们，从而实现基类的通用行为和派生类的特定行为。

综上所述，虚函数和纯虚函数在 C++ 中有着重要的应用，它们为面向对象编程提供了灵活性和可扩展性，能够更好地组织和设计代码结构，提高代码的可维护性和可重用性。

## 引用和指针的区别

+ 引用变量
  - 引用是已定义的变量的别名（另一个名称）
  - 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的
  - `int rats; int & rodents = rats;  // make rodents an alias for rate`
  - 其中，`&`不是地址运算符，而是类型标识符的一部分。就像声明中的`char*`指的是指向`char`的指针一样，`int&`指的是指向int的引用。
  + 引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量

+ 指针
  - 指针，是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元

+ 区别：
  + 指针是存储变量地址的变量；引用是变量的别名。
  + 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错
  + 指针变量定义时可以初始化为NULL；引用不能初始化为NULL，不然报错。
  + const修饰指针变量，const放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const修饰引用，const放在&之前，不能修改引用所表示的变量的值；const放在&之后，const的作用被忽略，可以修改引用所表示的变量的值。
  + 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名
  + sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
  + 指针可以有多级，引用只有一级。
  + 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。

## 静态链接库与动态链接库

+ 静态链接库：
  + 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
  + 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
  + 创建静态库需要用到一个工具:`AR`

+ 动态链接库：
  + 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
  + 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**

## 静态链接库与动态链接库的区别

静态链接库和动态链接库是两种不同类型的库文件，它们在软件开发中扮演着不同的角色，并且具有一些显著的区别：

### 静态链接库（Static Linking Library）：

1. **链接方式**：
   - **编译时链接**：静态链接库在编译时被链接到可执行文件中，将库的代码和可执行文件合并为一个单独的可执行文件。

2. **文件格式**：
   - **文件大小**：相对较大，因为它包含了被调用的库的完整副本。
   - **扩展名**：通常是`.lib`（在Windows平台）或`.a`（在Unix/Linux平台）。

3. **运行时**：
   - **独立性**：生成的可执行文件独立运行，不需要外部依赖。
   - **移植性**：可能导致较大的可执行文件，并且需要在每个使用相同静态库的应用程序中重新链接和更新。

### 动态链接库（Dynamic Linking Library）：

1. **链接方式**：
   - **运行时链接**：动态链接库在程序运行时被加载到内存中，并且可以被多个程序共享使用。

2. **文件格式**：
   - **文件大小**：相对较小，因为它包含了可共享的代码和数据，被多个程序共享使用。
   - **扩展名**：通常是`.dll`（在Windows平台）或`.so`（在Unix/Linux平台）。

3. **运行时**：
   - **依赖性**：程序在运行时需要正确的动态链接库存在，否则会出现运行错误。
   - **更新和维护**：修改动态链接库可能影响多个程序，但是可以通过单独更新库文件来修复或升级功能，不需要重新编译整个程序。

### 总结区别：

- **静态链接库**在编译时将代码和数据合并到可执行文件中，使得程序独立运行，但增加了可执行文件的大小和每个应用的维护负担。
- **动态链接库**在运行时被加载到内存中，多个程序可以共享它，减少了磁盘空间和内存的占用，但程序需要确保相应的库在运行时存在。

在实际开发中，通常会根据具体需求和考虑因素来选择使用静态链接库或动态链接库。

## 简单介绍一下webserver

+ Web服务器是一种软件或者应用程序，负责接收客户端请求并向其提供响应的资源。它充当客户端和后端服务器之间的中介，通过HTTP协议进行通信。

+ Web服务器的主要功能包括
  + 接收和处理客户端请求：Web服务器监听指定的端口，接收来自客户端(例如浏览器)发送的HTTP请求。它解析请求，识别所需资源，并采取适当的操作来响应请求
  + 资源管理：Web服务器负责管理和提供各种资源，例如HTML文件，图像，CSS样式表，Javascript脚本等。它能够从磁盘上的文件系统中获取这些资源，并将其发送给客户端。
  + 处理动态内容: 除了静态资源外，Web服务器还可以与后端应用程序(例如CGI脚本，PHP脚本，ASP.NET等)交互以生成动态内容。它可以将请求转发给适当的后台处理程序，并将生成的结果返回给客户端。
  + 连接管理: Web服务器需要管理并保持与多个客户端之间的连接。他可以使用不同的策略来处理连接池，线程池或者事件驱动等方式来高效地处理并法请求
  + 安全性和身份验证: 为了保护网站和数据安全，Web服务器通常具有各种安全功能，例如HTTPS支持，SSL证书配置，身份验证和访问控制等。
  + 日志记录: Web服务器可以记录每个请求的详细信息，包括访问时间，客户端IP地址，请求路径，响应状态等。这些日志对于分析和监视网站流量以及故障排除非常有用。

+ 常见的Web服务器软件包括Apache HTTP Server, Nignx, Microsoft IIS等。他们在性能，可靠性和扩展性方便都有不同的特点，开发人员可以根据实际情况需求选择适合自己的项目的Web服务器。

## 这个webserver并发连接多少

+ 这个取决于具体的Web Server的实现和配置。一般来说，web server可以通过多线程，多进程或异步IO等方式处理并发连接。不同的实现方式和硬件环境都会对并发连接数产生影响。
+ 有些服务器可以处理成千上万并发连接，而另一些可能只能处理几百个。因此，并发连接数是相对灵活可调的，取决于特定情况下所使用的服务器架构和配置。

## 线程池和线程个数怎么设置

+ 配置线程池的大小需要考虑多个因素，包括系统资源，任务类型和负载情况等。以下是一些常见的设置原则：
  + CPU核心数： 通常线程池的大小应该与CPU核心数相近或者略大，这样可以最大程序利用CPU资源
  + 任务类型和执行时间: 如果任务属于I/O密集型，即涉及到等待外部资源(例如网络请求，文件读写等),可以设置较大的线程池来充分利用CPU空闲时间。而对于计算密集型任务，由于存在CPU竞争，适当减少线程池大小可能更高效
  + 内存限制：每个线程都需要一定的内存开销，在确定线程池大小时需要考虑系统可用内存。避免过多线程导致内存耗尽和频繁的内存交换。
  + 平均负载：根据当前系统平均负载情况动态调整线程池大小。例如使用指标如CPU利用率，请求处理速度等来监控系统负载，根据阈值自动调整线程池大小。

+ 总的来说，合理设置线程池大小可以提高程序性能和资源利用率。但是要注意避免过渡设置导致资源浪费或者系统性能下降。

## 线程模型怎么搭配epoll进行使用

+ 在线程模型中，可以使用epoll作为事件驱动的I/O多路复用机制，以提高服务器的并发性能。

+ 一种常见的搭配方式是，使用一个主线程负责监听新连接，并将新连接分配给工作线程处理。具体步骤如下: 
  + 创建一个epoll实例，并设置感兴趣的事件类型(例如可读事件)
  + 在主线程中创建监听套接字，并将其加入到epoll实例中
  + 进入循环，调用epoll_wait()函数等待事件发生。
  + 当有新连接到来时，在主线程中接收连接请求，并根据一定的策略选择一个空闲的工作线程。
  + 将新连接的套接字添加到该工作线程的epoll实例中，并设置相应的回调函数或处理逻辑。
  + 工作线程从自己所属的epoll实例中获取就绪事件，并执行响应的操作(例如读取数据，处理业务逻辑等)
  + 回到第三步，继续等待新事件

+ 这样，通过将连接分配给不同的工作线程进行处理，可以提高系统对并发请求的处理能力。

+ 需要注意以下几点:
  + 主线程只负责监听新连接，不直接处理具体请求。工作线程才是真正处理业务逻辑和响应客户端请求的地方
  + 每个工作线程都需要拥有自己的epoll实例，以避免竞争和阻塞。每个工作线程独立负责处理自己所分配的连接
  + 在具体实现时，还需要考虑连接管理，线程池，数据同步等方面的细节。

+ 以上是一种常见的搭配方式，根据实际情况和需求，也可以选择其他线程模型(例如多线程，异步IO等)结合epoll使用。

## 怎么理解io多路服用

+ IO多路复用是一种通过同时监听多个IO事件的机制，使得一个进程能够同时处理多个IO请求。他利用操作系统提供的select, poll, epoll等函数，在一个线程内监听多个文件描述符(socket)上是否有数据刻度或可写，从而避免了使用多线程或多进程来处理并发IO请求的开销。

+ 通过IO多路复用，可以将大量的网络连接集中到少数几个线程或进程上进行管理和处理，提供了系统的并发性能。当某个文件描述符就绪时(例如有数据可读)，应用程序会得到通知并可以立即对其进行读取操作，这样就能更高效地利用CPU资源

## poll和epoll的关系和区别

`poll` 和 `epoll` 都是在 Linux 中用于实现事件驱动 IO 的机制，它们都可以用于处理大量的文件描述符，并在事件就绪时通知应用程序进行处理。以下是它们之间的关系和区别：

1. **关系：**
   - `poll` 和 `epoll` 都是 Linux 提供的 I/O 复用机制，用于监视多个文件描述符的状态，并在有事件发生时通知应用程序。
   - `epoll` 实际上是 `poll` 的增强版本，是 `poll` 的一种改进，引入了更高效的事件通知机制。

2. **区别：**
   - **性能：** `epoll` 比 `poll` 更加高效。`poll` 在监视大量文件描述符时，会遍历整个文件描述符数组来查找就绪事件，而 `epoll` 使用了基于事件的就绪通知机制，只在有事件发生时才通知应用程序，因此在处理大量文件描述符时性能更高。
   - **事件触发模式：** `poll` 采用的是边缘触发模式（Edge-Triggered），即只有当文件描述符状态发生变化时才通知应用程序。而 `epoll` 则支持两种触发模式：水平触发模式（Level-Triggered）和边缘触发模式（Edge-Triggered）。
   - **接口：** `epoll` 的接口比 `poll` 更加灵活和强大，提供了更多的选项和功能，例如支持同时监视多个 `epoll` 对象，支持添加和删除文件描述符等。
   - **适用范围：** `poll` 适用于少量的文件描述符，而 `epoll` 更适用于大量的文件描述符，尤其是在高并发网络编程中，`epoll` 的优势更加明显。

综上所述，`epoll` 是 `poll` 的一种改进和扩展，相比 `poll`，`epoll` 更加高效、灵活和功能强大，在处理大量文件描述符时性能更好。因此，在 Linux 中进行高性能的网络编程时，通常会选择使用 `epoll`。

## epoll的边沿触发和水平触发

+ 在Linux中，epoll是一种高效的I/O事件通知机制。他提供了两种触发模式：边沿触发(Edge Triggered)和水平触发(Level Triggered)

+ 边沿触发(Edge Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，只会触发一次通知
  + 如果不立即处理该事件，下次调用epoll_wait()时将不再返回该事件直到有新的事件再次发生。
  + 边缘触发适合于非阻塞的，以消息为单位进行处理的场景

+ 水平触发(Level Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，如果没有处理完全部数据，下次调用epoll_wait()时仍然会返回该事件
  + 直到该文件描述符上没有待处理的数据或者被关闭才不再返回该事件
  + 水平触发适合于阻塞式，基于流的传输协议，例如TCP

+ 选择使用边沿触发还是水平触发取决于具体场景和应用需求。一般来说，在高并发且非阻塞的网络服务器中，边缘触发能够更好地控制事件通知频率和减少无效循环检查。而对于普通应用程序或者阻塞式的IO操作，水平触发则是更常见和常用的模式。

## 两种模式都使用过吗？两种使用起来有什么区别吗？

+ 边缘触发(Edge Triggered)模式和水平触发(Level Triggered)模式是在事件驱动系统中常见的两种触发方式

+ 区别：
  + 边缘触发模式：当输入信号从低电平变为高电平或从高电平变为低电平时，会产生一个触发事件只有在状态改变瞬间才会触发事件例如，边缘触发模式可用于处理硬件中断信号。
  + 水平触发模式：只要输入信号保持在指定的电平上，就会持续触发事。无论输入信号处于何种状态，只要满足条件就会持续触发事件。例如，在网络编程中，水平触发模式可用于处理socket数据的读取。

+ 总体而言，边缘触发更适合处理瞬时状态变化的场景，而水平触发则更适合连续性地监测和响应特定状态。

## 有观察过这两种的区别从连接到数据

+ 边缘触发(Edge Triggered)和水平触发(Level Triggered)是指从数字电子系统中用于触发事件的不同方式。

+ 在边缘触发模式下，只有在输入信号的状态从低电平到高电平或者从高电平到低电平的瞬间时，才会触发事件。换句话说，只有在信号变化的边缘时刻才会被触发

+ 而在水平触发模式下，只要输入信号保持为高电平或者低电平状态，就会持续地产生触发事件。无论输入信号是否有变化，在达到预设的水平时都会触发事件。

+ 区别主要体现在连接和传输数据方面：
  + 连接：对于边缘触发模式，通常需要一个外部时钟或者专门的边缘检测器来监测输入信号的变化，并将结果传递给系统。而水平触发模式则可以直接使用输入信号作为事件的条件。
  + 传输数据：在边缘触发模式下，当边缘变化时彩绘进行数据传输。而在水平触发模式下，一旦满足了预设条件，数据传输就会立即开始。

## HTTP是什么 详解

HTTP（Hypertext Transfer Protocol，超文本传输协议）是一种用于传输超文本数据的应用层协议，它是万维网的基础之一，用于在客户端和服务器之间传输数据。以下是对HTTP的详细解释：

1. **通信模型**：
   - HTTP是一种客户端-服务器模型的协议，客户端向服务器发送请求，服务器响应请求并返回数据给客户端。
   - 客户端通常是指浏览器，而服务器则是存放网页和其他资源的主机。

2. **无状态协议**：
   - HTTP是一种无状态协议，即每次请求与响应之间没有记忆，服务器不会保留之前请求的任何状态信息。
   - 这意味着每个请求都是独立的，服务器不会知道请求是否来自同一用户或会话。

3. **请求-响应模型**：
   - HTTP请求由客户端发送到服务器，请求中包含请求方法、URL、请求头和请求体等信息。
   - 服务器接收到请求后，根据请求的信息进行处理，并返回一个HTTP响应，响应包含状态码、响应头和响应体等信息。

4. **状态码**：
   - HTTP响应中包含一个状态码，用于表示服务器对请求的处理结果。
   - 常见的状态码包括200（OK，请求成功）、404（Not Found，请求的资源不存在）、500（Internal Server Error，服务器内部错误）等。

5. **请求方法**：
   - HTTP定义了一些请求方法，用于指定对服务器执行的操作类型。
   - 常见的请求方法包括GET（获取资源）、POST（提交数据）、PUT（更新资源）、DELETE（删除资源）等。

6. **URL**：
   - URL（Uniform Resource Locator，统一资源定位符）用于指定请求的资源在服务器上的位置。
   - URL由协议类型、主机名、路径和查询字符串等组成，例如：http://example.com/path/to/resource?query=value。

7. **头部信息**：
   - HTTP请求和响应中包含头部信息，用于传递一些元数据和控制信息。
   - 头部信息包括请求头和响应头，常用于传递请求的用户代理、接受的内容类型、缓存控制指令等。

8. **持久连接**：
   - HTTP/1.1引入了持久连接（Keep-Alive），允许在单个TCP连接上发送多个HTTP请求和响应，以减少连接建立和关闭的开销，提高性能。

HTTP作为一种基础协议，被广泛应用于万维网中，支持超文本传输和资源访问，是构建Web应用程序和客户端的重要基础。

## HTTP2.0详解

HTTP/2.0（简称HTTP2）是超文本传输协议（HTTP）的第二个主要版本，它是HTTP/1.1的继任者，旨在提供更高效的传输性能和更好的用户体验。下面是对HTTP/2.0的详细解释：

### 1. 目标和特点：

- **提高性能**：HTTP/2旨在提高网页加载速度，减少延迟和传输时间。
- **降低开销**：通过头部压缩、多路复用等技术，减少通信量和连接数，降低网络开销。
- **提高安全性**：鼓励使用TLS加密连接，增强数据传输的安全性和隐私保护。
- **向后兼容**：尽可能与HTTP/1.1保持向后兼容，确保现有应用和工具的平稳升级。

### 2. 主要特性：

- **二进制协议**：HTTP/2采用二进制格式传输数据，与HTTP/1.1的文本格式相比，更高效地编码和解析。
- **多路复用**：允许在单个连接上并行发送多个请求和响应，避免了HTTP/1.x中的队头阻塞问题。
- **头部压缩**：使用HPACK算法对HTTP头部进行压缩，减少了重复头部的传输开销。
- **服务器推送**：服务器可以主动推送相关资源给客户端，避免了客户端请求资源的额外延迟。
- **流量控制**：通过流量控制机制，客户端和服务器可以控制数据流的速率，避免了窗口溢出导致的拥塞问题。
- **优先级和依赖**：可以设置请求的优先级和依赖关系，优化资源的加载顺序和并行传输。
- **Server Push**：服务器可以在客户端请求资源的同时主动推送相关资源给客户端，减少了客户端的等待时间。

### 3. 与HTTP/1.x的区别：

- **多路复用**：HTTP/1.x每个请求需要建立一个独立的连接，而HTTP/2可以在单个连接上并行发送多个请求和响应，减少了连接建立和关闭的开销。
- **头部压缩**：HTTP/2使用HPACK算法对HTTP头部进行压缩，减少了重复头部的传输开销，提高了传输效率。
- **二进制协议**：HTTP/2采用二进制格式传输数据，与HTTP/1.x的文本格式相比，更高效地编码和解析。
- **服务器推送**：HTTP/2引入了服务器推送机制，允许服务器在客户端请求之前主动推送相关资源给客户端，减少了客户端的等待时间。

### 4. 使用场景：

- **网页加载**：HTTP/2可以显著提高网页加载速度，降低延迟和传输时间。
- **API请求**：对于需要频繁请求API的应用场景，HTTP/2的多路复用特性可以减少连接数和请求延迟。
- **流媒体传输**：HTTP/2的流量控制和二进制格式特性使其适用于流媒体传输和大文件下载场景。

### 5. 与HTTP/3的关系：

HTTP/3是HTTP协议的下一代版本，基于QUIC（Quick UDP Internet Connections）协议，旨在进一步提高性能和安全性。HTTP/3相比于HTTP/2在传输层使用了UDP协议而不是TCP协议，以减少连接建立和头部延迟。但HTTP/3仍然保持了与HTTP/2类似的特性和语义。

总的来说，HTTP/2是HTTP协议的重要进化版本，通过多路复用、头部压缩等技术，提高了性能和效率，是现代Web应用和服务的重要基础。

## 有观察过HTTP的包吗

+ HTTP(Hypertext Transfer Protocol)是一种用于在Web浏览器和Web服务器之间传输数据的协议。通过分析HTTP包，我们可以了解请求和响应的头部信息，请求方法，URL，状态买等内容，以及实际传输的数据。这对于网络调试，安全分析和性能优化都非常有用。

## 有看过HTTP的报文的头吗

+ HTTP报文的头部包含了一些重要的信息。通常有以下几个常见的头字段
  + 请求行：包含了请求方法（GET，POST等），URI路径和HTTP协议版本。
  + 响应行：包含了响应状态码和对应的状态描述
  + 请求头：包含了客户端向服务器发送请求时附带的各种信息，例如User-Agent, Accept,Content-Type等
  + 响应头：包含了服务器返回给客户端的响应相关信息，例如Server,Content-Type,Content-Length等。
  + 实体头：包含了实体主体部分(可选)的附加信息，例如Content-Encoding, Last-Modified等。

+ 通过解析这些报文头部可以获得请求或响应的相关信息，以便进行适当的处理和解析。

## 除了GET和POST，其他方法见过吗？

+ 除了常见的GET和POST方法，还有一些其他HTTP请求方法，例如：
  + PUT： 用于创建或更新资源。通常用于向服务器发送数据，并将其存储在指定的URI下
  + DELETE： 用于删除指定的资源
  + PATCH： 用于部分更新资源，与PUT不同，PATCH仅对资源进行部分更改
  + HEAD： 类似于GET请求，但是只返回响应头信息，而不返回实际内容
  + OPTIONS： 获取目标URL所支持的通信选项

+ 这些是HTTP协议中常见的一些请求方法。具体使用哪个方法取决于你要实现的功能和服务端的支持请求

## GET和POST有什么区别吗

+ GET和POST是HTTP协议中两种常见的请求方法，他们在以下几个方面有区别：
  + 参数传递方式：GET请求通过URL参数传递数据，参数会附加在URL的末尾；而POST请求将数据放在请求体中进行传递，不会显示在URL上
  + 数据大小限制：由于GET请求将参数暴露在URL上，因此对于数据大小有限制。而POST请求没有明确的大小限制，可以传递大量的数据
  + 安装性：由于GET请求参数直接暴露在URL上，所以相对来说比较不安全，容易被拦截和篡改。POST请求把参数放在请求体中，相对更安全一些
  + 缓存机制：GET请求默认可缓存结果，浏览器会缓存返回的页面或资源；而POST请求默认不可缓存。

## URL组成，uri是什么

+ URL(Uniform Resource Locator)是统一资源定位符的缩写，他是用来标识和定位互联网上资源的字符串。一个完整的URL通常包括以下几个部分：
  + 协议(Protocol)： 表示要使用的传输协议，例如HTTP， HTTPS，FTP等
  + 主机名(Hostname)： 表示资源所在的主机或服务器的名称
  + 端口号(Port number)： 可选项，指定访问服务器时所使用的端口号，默认根据协议自动确定。
  + 路径(Path)： 指示服务器上特定资源的路径或位置
  + 查询参数(Query parameters)： 可选项，用于传递额外的参数给服务器
  + 锚点(Anchor)：可选项，在HTML中使用锚点进行页面内导航

+ URI(Uniform Resource Identifier)是统一资源标识符的缩写，他是一个用来唯一标识和引用某个资源的字符串。URI包括两种形式：
  + URL(Uniform Resource Locator),可以被用来直接访问并获取某个资源
  + URN(Uniform Resource Name)，仅用于标识资源而不提供直接访问

+ 因此，URI是URL和URN的总称

## 线程池用到哪些线程间通讯

+ 线程池通常使用以下几种线程间通讯方式：
  + 任务队列(Task Queue)： 线程池中的线程从任务队列中获取待执行的任务。通过将任务放入任务队列，可以实现生产者-消费者模型，在多个线程之间传递任务
  + 线程同步机制：在多个工作线程同时处理任务时，可能需要使用互斥锁，条件变量等线程同步机制来保证数据的一致性和避免竞态条件
  + 回调函数(Callback)：当一个任务完成后，可以通过回调函数将结果返回给调用方或者通知其他相关的模块
  + 线程间信号量(Thread Synchronization Primitives)： 通过信号量等同步原语，可以实现多个线程之间的协调和控制
  + 共享内存(Shared Memory)：多个线程可以通过共享内存在进行数据交换，但需要注意对共享数据的访问控制，以避免竞态条件

+ 这些通讯方式可以帮助线程池中的线程协作执行任务，并且能够有效地管理和分配工作负载。具体使用哪种通讯方式取决于应用程序的需求和设计

## linux 线程是怎么调度的 详解

在Linux系统中，线程的调度是由内核负责的，它根据线程的优先级和调度策略来确定线程的执行顺序。Linux提供了多种调度策略，包括先进先出（FIFO）、循环时间片（Round Robin）、实时（Real-time）等，每种策略都有不同的特点和适用场景。下面是关于Linux线程调度的详细解释：

### 1. 调度策略：

#### 先进先出（FIFO）调度：

- **特点**：按照线程加入队列的顺序执行，先加入队列的线程先执行，直到线程主动放弃CPU或者阻塞。
- **应用场景**：适用于不需要时间片轮转的场景，例如实时任务和需要按顺序执行的任务。

#### 循环时间片（Round Robin）调度：

- **特点**：按照时间片轮转的方式轮流执行每个线程，每个线程执行一个时间片后，被放回队列尾部等待下一次调度。
- **应用场景**：适用于多任务环境，可以公平地分配CPU时间，防止某个线程长时间占用CPU。

#### 实时（Real-time）调度：

- **特点**：按照线程的优先级执行，优先级高的线程具有更高的执行优先级，可以抢占优先级低的线程。
- **应用场景**：适用于对响应时间要求较高的实时任务，需要保证任务按时完成。

### 2. 调度器（Scheduler）：

Linux内核的调度器负责根据线程的优先级和调度策略来确定线程的执行顺序。常见的调度器包括CFS（完全公平调度器）和实时调度器（Real-time Scheduler），它们根据不同的调度算法和策略来进行线程调度。

- **CFS调度器**：CFS调度器是Linux内核默认的调度器，它通过红黑树数据结构来管理线程的优先级和调度顺序，采用最小化任务运行时间的方式来保证公平性和响应性。
- **实时调度器**：实时调度器是针对实时任务的调度器，包括FIFO调度器和RR调度器，它们按照不同的调度策略来保证实时任务的及时响应和高优先级的执行。

### 3. 调度优先级：

Linux线程的调度优先级范围通常是0到139，其中0是最高优先级，139是最低优先级。线程的优先级决定了它在调度队列中的位置和被调度的顺序，优先级高的线程会更快地获取CPU时间片。

### 4. 调度实现：

Linux的调度器是在内核中实现的，通过调度器模块和调度算法来实现线程的调度和管理。不同的调度策略和优先级会影响线程的调度顺序和CPU时间分配，可以根据实际需求选择合适的调度策略和优先级来优化系统的性能和响应性。

总的来说，Linux线程的调度是由内核负责的，根据线程的优先级和调度策略来决定线程的执行顺序和CPU时间分配。不同的调度策略和优先级适用于不同的场景，可以根据实际需求进行选择和配置。

## linux 线程调度算法 详解

在 Linux 中，线程调度算法是由内核的调度器负责实现的，它决定了在多个线程之间如何分配 CPU 时间片。Linux 内核提供了多种调度算法，常见的有 CFS（完全公平调度器）和实时调度器（Real-time Scheduler）。下面详细解释这些调度算法：

### 1. 完全公平调度器（CFS）：

CFS 是 Linux 内核中默认的调度器，它的目标是提供公平的 CPU 时间分配，以便于所有线程都能够获得合理的运行时间。CFS 主要特点包括：

- **红黑树数据结构**：CFS 使用红黑树来组织线程的调度队列，通过红黑树的平衡性质来实现公平调度。
- **虚拟运行时间**：CFS 通过维护每个线程的虚拟运行时间（Virtual Runtime）来决定线程的调度顺序。虚拟运行时间越小的线程优先级越高。
- **最小化任务运行时间**：CFS 会尽量将 CPU 时间均匀分配给所有线程，使得每个线程的运行时间都接近理想值，以达到公平性和响应性。

### 2. 实时调度器（Real-time Scheduler）：

实时调度器是针对实时任务的调度器，它主要包括 FIFO（First-In-First-Out）调度器和 RR（Round Robin）调度器两种。实时调度器的特点包括：

- **优先级调度**：实时调度器根据线程的优先级来决定调度顺序，优先级高的线程优先级更高，能够抢占优先级低的线程。
- **硬实时和软实时**：实时调度器可以分为硬实时和软实时两种，硬实时保证任务在规定的时间内完成，软实时允许一定程度的延迟。

### 3. 调度策略选择：

在 Linux 中，可以通过设置不同的调度策略和优先级来控制线程的调度行为。常见的调度策略包括：

- **SCHED_OTHER**：默认的调度策略，适用于普通的时间共享任务。
- **SCHED_FIFO**：FIFO 调度策略，适用于实时任务，具有最高的优先级。
- **SCHED_RR**：RR 调度策略，适用于实时任务，具有次高的优先级。

### 4. 调度算法实现：

Linux 调度器的实现是在内核中进行的，通过调度器模块和调度算法来管理线程的调度和执行。调度算法主要包括进程调度算法和线程调度算法，通过时间片、优先级和调度队列等数据结构来实现线程的调度和切换。

总的来说，Linux 线程调度算法是由内核的调度器负责实现的，主要包括完全公平调度器（CFS）和实时调度器（Real-time Scheduler）。不同的调度器和调度策略适用于不同的场景，可以根据实际需求进行选择和配置。

## linux 协程是怎么调度的

在 Linux 中，协程的调度是由用户态的协程库负责实现的，而不是由内核调度器进行管理。因此，协程的调度是基于用户态的调度器实现的，通常使用协作式调度（Cooperative Scheduling）来控制协程的执行顺序。

### 1. 协程的特点：

- **用户态实现**：协程是在用户态下实现的，不依赖于内核的调度器，具有较低的开销和更高的灵活性。
- **非抢占式调度**：协程的调度是通过协作的方式实现的，不会被强制中断，而是由程序员显式地控制协程的暂停和恢复。

### 2. 协程调度器：

协程调度器是一个用户态的调度器，负责管理和调度协程的执行。协程调度器通常包含以下几个关键组件：

- **调度队列**：用于存放待执行的协程，并根据调度策略决定执行顺序。
- **调度算法**：根据不同的调度策略来决定协程的执行顺序，如先进先出、优先级等。
- **调度器接口**：提供了控制协程执行的接口，包括启动、暂停、恢复和销毁等操作。

### 3. 协程的调度过程：

协程的调度过程主要包括以下几个步骤：

1. **启动协程**：将待执行的协程加入调度队列，并启动调度器开始执行协程。
2. **协程执行**：调度器从调度队列中选择一个协程进行执行，执行一段时间后暂停。
3. **协程切换**：当协程暂停时，调度器将控制权交给其他协程，选择下一个待执行的协程进行调度。
4. **恢复执行**：当其他协程执行完毕或主动让出CPU时，调度器将再次选择当前协程并恢复其执行。

### 4. 协程调度器的实现：

协程调度器的实现可以基于事件循环（Event Loop）或协程池（Coroutine Pool）等技术，通过事件驱动或协程轮询来实现协程的调度和执行。常见的协程库包括 Boost.Coroutine、libco 和 Coroutine in C++ 等。

总的来说，Linux 中的协程调度是由用户态的协程库负责实现的，通过协程调度器来管理和调度协程的执行。协程调度器采用协作式调度方式，根据调度策略选择下一个待执行的协程，并在协程执行一段时间后切换到其他协程，从而实现协程之间的协同执行。

## 消息队列 详解

消息队列是一种常见的通信模式，用于在不同组件或系统之间传递消息。它是一种基于先进先出（FIFO）原则的数据结构，消息发送者将消息放入队列的尾部，消息接收者从队列的头部获取消息。消息队列通常由消息中间件（Message Broker）来实现，它提供了消息存储、传输和路由等功能，以实现可靠的消息传递和异步通信。

下面详细解释消息队列的一些重要概念和特点：

### 1. 消息队列的组成部分：

- **消息**：要传递的数据单元，通常以文本或二进制格式表示，可以是任意类型的数据。
- **生产者（Producer）**：负责生成并发送消息到消息队列中的实体，将消息推送到队列中。
- **消费者（Consumer）**：负责从消息队列中获取并处理消息的实体，从队列中拉取消息进行处理。
- **消息队列**：用于存储消息的中间件，负责维护消息的顺序和状态，并确保消息的可靠传递。

### 2. 消息队列的特点：

- **解耦**：消息队列可以将生产者和消费者解耦，使它们不需要直接通信，降低了系统组件之间的耦合度。
- **异步**：消息队列实现了生产者和消费者之间的异步通信，生产者可以继续生产消息而不需要等待消费者处理完毕。
- **缓冲**：消息队列可以作为一个缓冲区，临时存储消息以应对生产者和消费者之间的速度差异。
- **扩展性**：消息队列可以水平扩展，通过增加更多的队列实例来处理更多的消息流量。
- **持久化**：一些消息队列支持消息的持久化，即使在系统重启后也不会丢失消息。

### 3. 消息队列的应用场景：

- **异步任务处理**：将耗时的任务放入消息队列，由消费者异步处理，提高系统的响应速度和并发能力。
- **解耦系统组件**：将不同系统组件之间的通信通过消息队列进行解耦，降低系统的耦合度和维护成本。
- **削峰填谷**：通过消息队列对请求进行排队和调度，平滑系统的请求流量，防止系统过载。
- **日志和监控**：将系统产生的日志和监控数据通过消息队列发送到中央化的日志分析和监控系统中进行分析和处理。
- **分布式系统集成**：在分布式系统中使用消息队列进行节点间通信和数据同步，实现分布式系统的集成和协同工作。

总的来说，消息队列是一种强大而灵活的通信模式，用于实现系统之间的异步通信、解耦系统组件、缓冲和削峰填谷等功能。通过合理地使用消息队列，可以提高系统的可靠性、扩展性和可维护性，是现代分布式系统中不可或缺的重要组件之一。

## C++类型转化

+ 在C++中，类型转换可以通过以下方式进行：
  + 隐式类型转换(Implicit Conversion)：在不需要显示指定的情况下，编译器会自动进行类型转换。例如，将一个整数复制给浮点类型变量时，编译器会自动从整型到浮点型的隐式转换
  + 显式类型转换(Explicit Conversion)：有时需要手动将一个数据类型转换为另一个数据类型。C++提供了几种显示类型转换操作符：
    + static_cast： 用于执行静态类型检查的转换，在合理范围内允许不同但相关的数据类型之间的转换
    + dynamic_cast: 用于执行安全向下造型(downcasting)，主要用于基类和派生类之间的转换
    + const_cast: 用于去除常量属性或者添加常量属性
    + reinterpret_cast: 一种底层强制类型转换，通常用于将指针或引用重新解释为其他指针或引用。

+ 注意，在使用显式类型转换时，请确保转换是安全且符合语义逻辑。错误的使用可能导致运行时错误或未定义行为

## C++中的堆和栈的区别

+ 在C++中，堆(heap)和栈(stack)是两种不同的内存分配方式，它们有以下区别
  + 分配方式：栈上的变量是通过系统自动进行分配和释放的，而堆上的内存则需要手动进行分配和释放。
  + 内存管理：栈内存由编译器自动管理，它在会变量超出作用域时自动释放。而堆内存需要手动分配和释放，在不再使用时必须显式的调用delete或者delete[]进行回收
  + 大小限制：栈通常比较小，并且大小固定，而堆没有固定大小限制，可以动态地分配所需要大小的内存空间
  + 访问速度：由于栈上的变量是连续分配的，因此访问速度相对较快。而堆上的内存分散在各个地址上，访问速度相对较慢
  + 生命周期：栈上的变量生命周期受到作用域控制，当离开作用域时会自动销毁。而堆上的对象在手动释放之前一直存在。

## 指针和引用的区别

+ 指针和引用是C++中的两个重要概念，它们可以用于间接访问对象或变量。下面是他们的区别：
  + 定义和使用方式：指针使用 * 来声明和解引用，而引用使用 & 来声明，不需要解引用
  + 空值：指针可以为空(nullptr)，表示没有指向任何对象或变量，而引用必须始终引用有效的对象
  + 可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象
  + 对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的指；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象
  + 空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。

## 关键字static的使用

+ 关键字 static 在C++中有多种用法，以下是其中几种常见的用法

1. 静态变量(Static Variables) : 在函数内部声明的静态变量具有静态生存期，即他们在整个程序执行期间都存在，并且只会初始化一次

2. 静态成员变量(Static Member Variables) : 静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享，例如：
```cpp
class MyClass {
public:
    static int sharedVariable; // 静态成员变量声明
};

int MyClass::sharedVariable = 10; // 静态成员变量定义

int main() {
    cout << MyClass::sharedVariable << endl; // 访问静态成员变量
    return 0;
}
```

3. 静态成员函数(Static Member Functions) : 静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：
```cpp
class MyClass {
public:
    static void myStaticFunction() { 
        cout << "This is a static member function." << endl;
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态成员函数
    return 0;
}
```

+ 除了以上几种用法，'static' 还可以用于限制变量或函数的作用于为当前文件(称为内部链接)以及在类模板中声明静态数据成员等。具体使用取决于上下文和需求

## webserver出现bug的debug思路

+ 当一个Web服务器出现bug时，以下是一些常见的debug思路：
  + 检查日志：查看服务器日志文件，特别是错误日志，以获取有关bug的更多信息。日志通常会记录请求和响应的详细信息，包括错误消息和异常堆栈跟踪
  + 排查输入数据：检查传递给服务器的输入数据，包括HTTP请求参数，表单数据等。验证输入数据是否符合预期，并确保他们正确解析和处理
  + 分步调试：使用适当的调试工具，在代码中设置断点并逐步执行程序，观察变量值的变化以及程序流程。这可以帮助找到引起bug的特定代码段
  + 异常处理：确保适当地捕获和处理异常。对于抛出异常的部分进行详细调试，并尝试理解异常触发的原因。
  + 代码审查：仔细审查代码逻辑，函数调用和算法实现。检查潜在的逻辑错误，边界情况和不恰当的函数使用
  + 环境配置检查：确认所需软件库和依赖是否正确安装和配置。有时，问题可能与环境相关
  + 测试用例编写：编写针对各种情况的测试用例，包括正常情况和边界条件。这有助于重现bug，并确认修复是否成功
  + 借助工具：使用适当的工具进行性能分析，内存泄漏监测或代码覆盖率分析等。这些工具可以帮助找到隐藏的问题

## linux上ping命令能确认那些内容

+ 在Linux上，使用ping命令可以确认以下内容：
  + 目标主机的可达性：通过发送ICMP Echo请求，ping命令会等待目标主机的回应。如果能够收到回应，则说明目标主机是可达的；否则，表示目标主机不可达。
  + 往返延迟时间（RTT）：ping命令会显示往返延迟时间，也就是从发送请求到接收响应所经过的时间。通过观察RTT可以评估网络的延迟情况。
  + 数据包丢失率：ping命令还会显示数据包丢失率，即发送的请求中未收到响应的比例。高丢包率可能表示网络连接存在问题。
  + TTL（Time to Live）值：每个发送出去的ICMP Echo请求都带有一个TTL值，在经过路由器时逐渐减小。当TTL为0时，路由器将丢弃该数据包并返回一个“Time Exceeded”错误消息。
  + 网络拓扑分析：通过连续向不同IP地址发送ping请求，并观察结果，可以获取一些关于网络拓扑结构和路由路径方面的信息。

+ 这些是ping命令常用来确认的内容，在诊断网络连接和故障排查时非常有用。

## ping的底层实现

+ Ping是一种网络诊断工具，用于测试主机之间的连通性。在底层实现上，Ping使用ICMP协议（Internet Control Message Protocol）来发送探测包并接收目标主机的响应。

+ 具体而言，Ping的底层实现可以分为以下几个步骤：
  + 创建一个原始套接字（Raw Socket）。
  + 构建ICMP报文，其中包括类型字段（通常为8表示请求Echo Request，或0表示回复Echo Reply）、校验和字段、标识符、序列号等信息。
  + 设置IP头部信息，包括源IP地址和目标IP地址。
  + 计算校验和，并将ICMP报文发送到目标主机。
  + 等待目标主机响应，如果收到相应的Echo Reply报文，则表示目标主机可达；如果超时未收到响应，则表示目标主机不可达。
  + 根据收到的响应时间计算往返时间（Round Trip Time, RTT），并显示或记录结果。

+ 需要注意的是，具体操作系统或平台上对Ping命令的实现可能有所差异，但基本原理都是通过ICMP协议进行网络连通性测试。

## C++中map，如果key不存在，使用[]形式遍历能成功吗

+ 在C++中，使用[]操作符形式访问一个map时，如果key不存在，会自动创建该key，并将其与一个默认值关联起来。
+ 因此，遍历一个map并使用[]形式访问时，如果key不存在，会在该位置插入新的键值对。请注意，在使用[]操作符访问时要确保map是可写的（非const）。

## tcp编程常用的api

+ 在C/C++中，进行TCP编程常用的API包括：
  + socket()：创建套接字
  + bind()：将套接字绑定到一个地址和端口
  + listen()：监听传入的连接请求
  + accept()：接受传入的连接请求并返回新的套接字
  + connect()：建立与远程服务器的连接
  + send()/sendto()：发送数据到已连接或未连接的套接字
  + recv()/recvfrom()：从已连接或未连接的套接字接收数据
  + close()：关闭套接字

+ 这些是基本的TCP编程API，可以使用它们来实现TCP服务器和客户端程序

## tcp为什么可靠

TCP（传输控制协议）被认为是可靠的，因为它在设计上具有多种机制来确保数据的可靠传输：

1. **确认和重传机制**：TCP使用确认和重传机制来确保数据的可靠传输。当发送方发送数据时，接收方会发送确认消息以确认收到数据，如果发送方在一定时间内未收到确认消息，它会认为数据丢失，并重新发送数据。这种机制可以有效应对网络中的丢包问题。

2. **流量控制**：TCP使用流量控制机制来控制发送方的数据发送速率，以避免接收方被发送过多的数据压倒。接收方会通过发送窗口大小告知发送方可以接收的数据量，发送方根据接收方的窗口大小调整发送数据的速率。

3. **拥塞控制**：TCP还使用拥塞控制机制来避免网络拥塞并确保网络的稳定性。当网络出现拥塞时，TCP会调整发送方的数据发送速率，以减少网络拥塞的程度，从而保证数据的可靠传输。

4. **顺序传输**：TCP保证数据按照发送顺序到达接收方，并且在接收端对数据进行重新排序，以确保数据的顺序性和完整性。

综上所述，TCP通过确认和重传机制、流量控制、拥塞控制以及顺序传输等多种机制来确保数据的可靠传输，使得它在网络通信中被广泛应用并被认为是可靠的传输协议。

## tcp滑动窗口 详解

TCP滑动窗口是TCP协议中用于流量控制的一种机制，它允许发送方在不等待接收方的确认消息的情况下继续发送数据，从而提高了网络的利用率和传输效率。下面详细解释TCP滑动窗口的工作原理：

1. **发送窗口和接收窗口**：
   - 发送窗口（Sender Window）：发送方维护的用于存储可以发送但尚未收到确认的数据的缓冲区大小。
   - 接收窗口（Receiver Window）：接收方维护的用于指示发送方可以发送多少数据的大小。接收方通过发送窗口大小告知发送方，发送方根据接收窗口大小来调整发送的数据量。

2. **滑动窗口的工作原理**：
   - 初始状态：发送窗口的大小等于接收窗口的大小。发送方可以发送的数据量取决于接收方的接收窗口大小。
   - 数据发送：发送方发送数据，并将发送的数据从发送窗口中移除。发送窗口的大小会根据已发送但未确认的数据大小动态调整。
   - 确认接收：接收方接收到数据后，发送确认消息通知发送方。同时，接收方会根据已接收的数据动态调整接收窗口的大小。
   - 窗口滑动：每当发送方收到确认消息时，发送窗口会向前滑动，允许发送更多的数据。这样可以使得发送方在等待确认的同时继续发送数据，提高了传输效率。
   - 动态调整：发送窗口和接收窗口的大小可以根据网络状况和系统资源动态调整，以保证流量控制的有效性和传输效率。

3. **流量控制**：TCP滑动窗口机制通过动态调整发送窗口和接收窗口的大小来控制数据流量，避免发送方发送过多的数据导致接收方无法及时处理。发送方会根据接收方的接收窗口大小来调整发送的数据量，从而保证数据的可靠传输和网络的稳定性。

总的来说，TCP滑动窗口是TCP协议中用于流量控制的重要机制，通过动态调整发送窗口和接收窗口的大小来控制数据的发送和接收，从而保证了数据传输的可靠性和网络的稳定性。

## tcp三次握手、四次挥手

+ TCP三次握手（Three-way Handshake）是建立TCP连接的过程，具体步骤如下：
  + 客户端向服务器发送一个SYN报文段，指示请求建立连接，并选择一个初始序列号。
  + 服务器收到SYN报文段后，回复客户端一个SYN+ACK报文段，表示同意建立连接，并选择自己的初始序列号。
  + 客户端收到服务器的SYN+ACK报文段后，再向服务器发送一个ACK报文段，确认连接建立。此时双方可以开始正式传输数据。

+ TCP四次挥手（Four-way Handshake）是关闭TCP连接的过程，具体步骤如下：
  + 主动关闭方（一般是客户端）发送一个FIN报文段给被动关闭方（一般是服务器），表示要关闭连接。
  + 被动关闭方收到FIN报文段后，回复一个ACK报文段进行确认。
  + 被动关闭方进入TIME_WAIT状态，在等待一段时间（一般为两个最大报文生存时间）后才能彻底关闭连接。
  + 主动关闭方收到ACK报文段后，也进入CLOSED状态。此时连接已经完全关闭。

+ 这样通过三次握手建立连接和四次挥手断开连接，确保了可靠的数据传输和双方对连接状态的准确掌握。

## 输入一个url会出现那些过程

+ 当你输入一个URL（统一资源定位符），通常会经历以下过程：
  + DNS解析：计算机将URL中的域名解析为对应的IP地址，以便进行网络通信。
  + 建立TCP连接：使用IP地址与服务器建立TCP连接，确保可靠的数据传输。
  + 发送HTTP请求：发送HTTP请求报文给服务器，包含请求方法（GET、POST等）、路径、头部信息和可能的请求体。
  + 服务器处理请求：服务器接收到请求后，根据路径找到相应的资源，并执行相关处理逻辑。
  + 返回HTTP响应：服务器将处理结果封装成HTTP响应报文返回给客户端。响应报文包含状态码、头部信息和响应体（可能是HTML、图片、JSON等）。
  + 客户端渲染：客户端接收到响应后，根据响应内容进行页面渲染或其他操作。如果是网页，则浏览器会解析HTML、CSS和JavaScript，并呈现出最终的页面效果。

## 写服务器碰到过死锁吗

+ 死锁在服务器开发中是一个常见的问题。死锁指的是多个线程或进程因为相互等待对方所持有的资源而陷入无限等待的状态。
+ 在服务器编程中，使用多线程或多进程处理并发请求时，如果不正确地管理锁和资源，就容易导致死锁情况的发生。

+ 解决死锁问题可以采取以下几种方法：
  + 避免使用过多的锁：减少并发操作所需要的锁数量，尽量简化代码逻辑。
  + 使用良好的锁策略：合理选择和管理锁，在保证数据安全性的前提下尽量减小临界区范围。
  + 按顺序获取锁：确保每个线程按照相同的顺序获取锁，避免出现循环等待情况。
  + 设置超时时间：为每个请求设置合理的超时时间，并在超时后释放所有占用资源，防止长时间阻塞导致整体性能下降。
  + 使用专门工具进行分析：借助死锁检测工具来识别和解决潜在的死锁问题。

+ 注意，在服务器开发中预防和解决死锁问题需要综合考虑系统架构、并发设计、线程安全等方面，以确保系统的稳定性和性能。

## http和https的区别

+ HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在Web浏览器和服务器之间传输数据的两种协议。
  + 安全性：最显著的区别是安全性。HTTP不加密数据传输，而HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密来保护数据的安全性。
  + 端口号：HTTP默认使用端口号80进行通信，而HTTPS默认使用端口号443进行通信。
  + 数据传输方式：HTTP的数据传输是明文的，可以被拦截并查看内容。而HTTPS通过加密技术保护数据传输，使得拦截者无法轻易解读或修改传输的内容。
  + 证书要求：为了建立HTTPS连接，服务器需要具有数字证书。这个证书由受信任的证书颁发机构（CA）签发，以确认服务器身份和公钥的有效性。

## https的认证是谁认证谁

+ 在 HTTPS 中，认证是由第三方机构颁发的数字证书来实现的。这个机构通常被称为证书颁发机构（Certificate Authority，CA）。
+ 当网站使用 HTTPS 时，它需要向证书颁发机构申请数字证书。证书颁发机构会对网站进行验证，并签发包含公钥及其他信息的数字证书。
+ 当用户访问这个网站时，浏览器会检查该数字证书是否有效并且与域名匹配。如果验证通过，则建立安全连接。如果数字证书无效或不可信，则浏览器会给出警告提示。

+ 因此，HTTPS 认证是由受信任的第三方机构（即证书颁发机构）对网站的身份进行认证，并确保通信过程中数据传输的安全性和完整性。

***

## 动态多态的实现原理

+ 动态多态是面向对象编程中的一个重要概念，它通过基类指针或引用调用派生类对象的虚函数实现。其实现原理主要涉及虚函数表(vtable)和虚函数指针(vptr)

+ 在C++中，当一个类声明了虚函数时，编译器会为该类生成一个隐藏的指向虚函数表的指针--虚函数指针(vptr)。该指针位于每个对象的内存布局开头或者继承体系的最顶层基类对象中。而对应每个带有虚函数的类编译器还会创建一个虚函数表，其中存储着该类所有虚函数的地址。
+ 当使用基类指针或引用调用某个派生类对象的虚函数时，首先通过基类指针/引用找到对应对象中存储的vptr，然后根据vptr找到对应的虚函数表，在虚函数表中查找需要调用的虚函数，并执行相应代码

+ 这种机制使得在运行时能够动态地选择适当的派生类版本进行调用。通过动态多态可以实现面向对象编程中的封装，继承和多态等特性，提高代码灵活性和可扩展性。

## 虚函数表是属于类的还是类对象的

+ 虚函数表(vtable)是属于类的，而不是类对象的。每个带有虚函数的类都会在编译过程中生成一个对应的虚函数表。这个表存储了该类所有虚函数的地址，并且在编译时确定。

+ 每个类对象都包含一个指向其所属类的虚函数表的指针--虚函数指针(vptr)，他是隐藏在对象内存布局开头或继承体系最顶层基类对象中的成员。通过这个指针，可以在运行时动态地找到并调用正确的虚函数。

+ 因此，所有同一类类型的对象共享同一个虚函数表，而不是每个对象都拥有自己独立的虚函数表。这种设计节省了内存空间，并且保证了同一类型对象调用相同虚函数时能够得到正确结果。

## 虚函数表里面有什么

虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的关键机制之一。每个含有虚函数的类都会在其对象中维护一个指向虚函数表的指针（通常称为虚函数指针），这个表存储了该类的虚函数的地址。

虚函数表中主要包含以下内容：

1. **虚函数的地址**：虚函数表中存储了类的每个虚函数的地址，这些地址指向了对应的虚函数的实际实现。在派生类中覆盖（重写）基类的虚函数时，虚函数表中存储的地址会被更新为派生类的虚函数地址。

2. **偏移量（可选）**：在包含多重继承或虚拟继承的情况下，虚函数表可能还包含了用于解析虚函数调用的偏移量。这些偏移量用于确定虚函数在继承层次结构中的具体位置。

3. **其他元数据（可选）**：虚函数表可能还包含一些其他元数据，例如用于运行时类型信息（RTTI）的指针等。

总的来说，虚函数表存储了类的虚函数的地址和相关的元数据，它允许在运行时根据对象的实际类型来动态调用对应的虚函数，实现了运行时多态性。

## 虚函数表是怎么使用的

虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的关键机制之一。它是用于在运行时确定对象的动态类型并调用正确的虚函数的。下面是虚函数表的基本使用方法：

1. **定义虚函数：** 在基类中声明虚函数，即在函数声明前加上关键字 `virtual`。例如：

```cpp
class Base {
public:
    virtual void foo() {
        // 基类虚函数的默认实现
    }
};
```

2. **派生类重写虚函数：** 派生类可以重写基类的虚函数，以实现特定的行为。在派生类中重写虚函数时，函数的签名（返回类型、函数名和参数列表）必须与基类中的虚函数完全一致。

```cpp
class Derived : public Base {
public:
    void foo() override {
        // 派生类中对虚函数的重写
    }
};
```

3. **编译器创建虚函数表：** 当类中包含虚函数时，编译器会在编译阶段为该类创建虚函数表。虚函数表是一个指针数组，存储了虚函数的地址。

4. **对象存储指向虚函数表的指针：** 对象中包含一个指向虚函数表的指针（通常是在对象的开头或结尾）。这个指针被称为虚函数指针（vptr）。编译器会在对象的内存布局中插入这个指针，并在构造函数中进行初始化。

5. **运行时动态绑定：** 当通过基类指针或引用调用虚函数时，实际调用的是指向对象的虚函数表中相应函数的指针。这个过程被称为动态绑定或运行时多态。编译器在运行时根据对象的动态类型找到正确的虚函数表，并调用正确的函数。

例如：

```cpp
Base* ptr = new Derived();
ptr->foo(); // 调用 Derived 类中的 foo() 函数
```

在这个示例中，即使 `ptr` 的静态类型是 `Base*`，但由于它指向的是 `Derived` 类的对象，因此在运行时调用的是 `Derived` 类中的 `foo()` 函数。

这就是虚函数表的基本使用方法和工作原理。通过虚函数表，C++ 实现了运行时多态性，让程序能够根据对象的动态类型调用正确的虚函数。

## 虚函数表是在编译的哪个阶段生成的

虚函数表（Virtual Function Table，简称 vtable）是在编译阶段生成的。编译器在编译类的源代码时，会扫描类中的虚函数，并为每个包含虚函数的类生成一个对应的虚函数表。

具体来说，虚函数表是在编译器为每个类生成的元数据中创建的。这些元数据包含了类的布局信息、虚函数的偏移量以及指向虚函数表的指针。编译器会在编译阶段根据这些信息为每个类生成虚函数表，并将其存储在程序的可执行文件中。

在运行时，每个对象的内存布局中都包含一个指向相应类的虚函数表的指针。这个指针（通常称为虚函数指针或 vptr）在对象构造时被初始化，指向类的虚函数表。这样，在运行时通过这个指针就能够动态地调用正确的虚函数。

总之，虚函数表是在编译阶段由编译器根据类的元数据生成的，它包含了类的虚函数的地址，用于在运行时实现多态性。

## 虚函数表在文件中的位置

虚函数表（Virtual Function Table，简称 vtable）通常是存储在程序的可执行文件中的数据段（例如 `.data` 段）中的。具体来说，每个包含虚函数的类都会在编译时生成一个对应的虚函数表，然后将这些虚函数表存储在可执行文件的数据段中。

在程序加载到内存时，操作系统会将数据段中的虚函数表加载到内存中的相应位置。每个对象的内存布局中都包含一个指向相应类的虚函数表的指针（通常称为虚函数指针或 vptr），该指针指向加载到内存中的虚函数表。

虚函数表的确切位置取决于编译器、操作系统和目标平台等因素。通常情况下，虚函数表会作为静态数据存储在程序的数据段中，并且在程序加载时被映射到内存中的合适位置。

## 虚基类 详解

虚基类（Virtual Base Class）是C++中用于处理菱形继承（Diamond Inheritance）问题的一种技术。在菱形继承中，派生类同时继承自多个共同的基类，而这些基类又有一个共同的基类。这样会导致派生类中含有多个共同基类的子对象，而造成资源浪费和混乱。虚基类的引入就是为了解决这个问题。

下面是虚基类的一些详解：

1. **菱形继承问题：** 考虑如下的继承关系：
   ```
       A
      / \
     B   C
      \ /
       D
   ```
   在这个继承结构中，如果 B 和 C 类都继承自 A 类，而 D 类同时继承自 B 和 C 类，则在 D 类中会包含两份 A 类的成员，导致资源的浪费和访问的混乱。

2. **解决方案：** 使用虚基类可以解决菱形继承问题。当一个基类被声明为虚基类时，它的派生类中不会包含对这个虚基类的多个实例，而是共享同一个实例。

3. **语法：** 将基类声明为虚基类的语法是在派生类的基类列表中，在基类名称前加上 `virtual` 关键字。例如：
   ```cpp
   class A {};
   class B : virtual public A {}; // B 继承自 A 的虚基类
   class C : virtual public A {}; // C 继承自 A 的虚基类
   class D : public B, public C {}; // D 继承自 B 和 C，A 被声明为虚基类
   ```

4. **派生类中的虚基类构造：** 虚基类的构造由最底层的派生类负责完成。在构造虚基类对象时，虚基类的构造函数只会被调用一次。

5. **虚基类的存储：** 虚基类的指针通常存储在对象的最开始位置，以确保派生类中共享同一个虚基类实例的指针是一致的。

虚基类的引入使得多继承中的派生类能够更好地组织和管理共享的基类，避免了菱形继承问题带来的资源浪费和混乱。

## 如何去管理内存，防止内存泄漏

管理内存以防止内存泄漏是编程中非常重要的一部分，特别是在使用动态内存分配（如 `new` 和 `malloc`）的情况下。以下是一些防止内存泄漏的常见方法：

1. **使用智能指针：** C++11引入了智能指针，如 `std::unique_ptr` 和 `std::shared_ptr`，它们可以自动管理动态分配的内存。`std::unique_ptr` 确保只有一个指针可以指向所管理的对象，而 `std::shared_ptr` 则允许多个指针共享相同的对象。当不再需要指针时，它们会自动释放所管理的内存。

2. **RAII（资源获取即初始化）：** RAII 是一种 C++ 编程范式，它通过在对象构造函数中获取资源并在析构函数中释放资源来管理资源。这种方法可以确保资源的正确释放，即使在发生异常或函数提前返回的情况下也能保证资源被释放。

3. **正确使用动态内存分配函数：** 当使用 `new` 和 `delete` 或 `malloc` 和 `free` 时，务必确保每次分配的内存都有相应的释放操作。避免出现分配了内存但未释放的情况，否则会导致内存泄漏。

4. **检查内存分配的返回值：** 在使用动态内存分配函数时，应该检查返回值是否为 `nullptr` 或 `NULL`，以确保内存分配成功。如果分配失败，应该进行适当的错误处理而不是继续使用未初始化的内存。

5. **避免循环引用：** 在使用智能指针时，特别是 `std::shared_ptr`，应该避免形成循环引用。循环引用会导致对象无法被正确释放，从而造成内存泄漏。可以使用 `std::weak_ptr` 来打破循环引用。

6. **使用工具进行内存泄漏检测：** 可以使用诸如 Valgrind、AddressSanitizer 等工具来检测程序中的内存泄漏问题。这些工具可以帮助识别出程序中未释放的内存，并提供有用的调试信息来帮助解决问题。

综上所述，合理使用智能指针、RAII、正确的内存分配函数、避免循环引用以及使用工具进行检测是防止内存泄漏的关键。

## 静态成员函数可以是虚函数吗

+ 静态成员函数不能声明为虚函数。虚函数是通过动态绑定来实现的，他需要在运行时根据对象的类型来确定调用的函数，但静态成员函数属于类本身而不是对象，没有动态绑定的需求

+ 虚函数依赖于对象的内存布局和虚函数表来进行动态分配，而静态成员函数并不依赖于任何具体对象的状态或特征，所以不适合使用虚函数机制。静态成员函数是属于整个类而非某个具体对象的，并且他们可以直接通过类名访问，无需创建对象实例。

+ 因此，在C++中，将静态成员函数声明为虚函数是无效且错误的。

## 为什么析构函数默认不是虚函数

+ C++中析构函数默认不是虚函数的原因是为了避免额外的开销和复杂性

+ 在设计类继承关系时，当基类指针指向派生类对象并通过该指针进行delete操作时，如果基类的析构函数时虚函数，那么会触发动态绑定，从而调用到正确的派生类析构函数。这样可以确保在删除基类指针时，正确地释放派生类对象的资源。

+ 然而，将所有的析构函数都声明为虚函数会导致额外的开销。每个对象都需要额外存储一个虚函数表指针(vptr)，增加了对象的内存消耗，对于大规模或频繁创建和销毁对象的场景来说，这种额外开销可能是不可接受的。

+ 因此，在C++中，默认情况下将析构函数声明为非虚函数。如果在父类中定义了虚析构函数，并且希望在继承体系中正确地释放资源，那么需要手动将派生类的析构函数声明为虚函数。

## 内存对齐的作用

+ 内存对齐是指在分配和使用内存时，数据对象的起始地址需按照一定规则对齐的原则。具体而言，就是要求某些特定类型的数据在内存中的地址必须是某个值(通常是他自身大小)的整数倍

+ 内存对齐的作用主要有以下几点：
  + 提高访问效率： 许多计算机体系结构要求特定类型的数据从特定地址开始读取或写入。如果为满足对齐要求，会导致额外的CPU周期来处理这种非对齐访问，从而降低程序性能
  + 减少内存碎片： 当不同大小的数据对象按照自然字节对齐方式进行排列时，可能会出现内存碎片问题。通过按照特定规则进行对齐，可以减少内存碎片，提高空间利用率
  + 支持硬件操作： 一些硬件设备(如网络卡，图形加速器等)要求数据在内存中按照固定格式排列以支持高效地传输和处理。通过正确进行内存对齐，可以确保数据符合硬件设备所需的格式要求

内存对齐是计算机中的一个重要概念，它确保数据在内存中的存储位置符合硬件要求，提高了访问内存的效率。以下是内存对齐的详细解释：

### 1. 为什么需要内存对齐？

内存对齐的目的主要有两个方面：
- **硬件要求**：某些硬件架构要求特定类型的数据位于特定地址上。例如，某些 CPU 可能只能从特定地址开始访问特定大小的数据，如果数据没有正确对齐，可能会导致性能下降甚至错误。
- **数据结构的自然对齐**：某些数据类型在内存中的布局方式与其自身的大小相关。例如，一个4字节大小的整数通常会在4字节对齐的地址上开始，这样访问它的效率更高。

### 2. 内存对齐规则

内存对齐规则通常由硬件或编译器定义，但是一般遵循以下原则：
- **基本对齐原则**：数据的存储地址必须是其大小的整数倍。例如，一个4字节大小的整数通常要求其地址是4的倍数。
- **数据结构对齐**：复合数据类型（如结构体或类）的对齐要求取决于其成员中最大的对齐要求。

### 3. 内存对齐的影响

内存对齐可能会影响程序的内存使用和性能：
- **内存浪费**：由于对齐要求，可能会导致一些内存空间被浪费掉。例如，在一个结构体中，如果某些成员的大小小于对齐要求，可能会在其后插入填充字节以满足对齐要求。
- **性能影响**：正确的内存对齐可以提高程序的性能，因为它允许 CPU 以更高效的方式访问数据。

### 4. 如何控制内存对齐

在 C/C++ 中，可以使用一些手段来控制内存对齐：
- **结构体对齐控制**：可以使用 `#pragma pack` 指令（或者类似的编译器特性）来修改结构体的对齐方式，以减少内存浪费或者与外部库/硬件的要求匹配。
- **对齐属性**：某些编译器提供了特殊的属性或指示符，可以用来指定变量或数据结构的对齐方式。

### 总结

内存对齐是一项重要的概念，对于理解计算机内存布局、编写高效的代码都非常重要。合理地处理内存对齐可以提高程序的性能和效率。

## vector 和 map 用迭代器一遍遍历容器一边删除元素，迭代器会失效吗

+ 是的，当使用迭代器遍历容器并删除元素时，迭代器可能会失效。

+ 对于vector来说，如果使用普通迭代器(例如 std::vector<int>::iterator)进行遍历和删除操作，当你删除一个元素后，后面的元素会向前填补空缺，导致当前迭代器指向的位置已经不再有效。此时继续使用该迭代器将产生为定义行为

+ 对于map来说，使用普通迭代器或者逆向迭代器进行遍历并删除操作同样存在迭代器失效的问题。因为在删除某个键值对后，其他键值对的位置可能发生变化，导致当前迭代器无法正确指向下一个要访问的元素。

+ 解决这个问题的一种常见的方式是使用 erase-remove 惯用法。即通过调用容器提供的成员函数 erase() 来移除需要删除的元素，并保持正确的迭代器位置。例如，在 std::vector 中可以使用 erase-remove idiom
  + vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end());

+ 而在map中可以配合使用返回下一个有效迭代器的 erase() 成员函数:
```cpp
for (auto it = map.begin(); it != map.end(); )
{
    if (condition)
        it = map.erase(it);
    else
        ++it;
}
```

+ 注意：
  + C++11 引入了范围循环 for-each，但不适用于在迭代过程中删除元素的情况，因为他使用的是临时迭代器并不允许修改容器。

## map是有序的还是无序的，底层实现是什么

+ std::map 是有序的关联容器，底层实现通常是红黑树(Red-Black Tree)

+ 红黑树是一种自平衡二叉查找树，它能够保持键值对按照键的大小顺序进行排序。这意味着当你遍历 std::map 时，会按照键的升序顺序返回元素。
+ 红黑树具有以下性质：
  + 每个节点要么是红色，要么是黑色
  + 根节点和叶子节点(空节点)都被认为是黑色的。
  + 如果一个节点是红色的，则其子节点必须是黑色的。
  + 对于任意一个节点而言，从该节点到其所有后代叶子节点的简单路径上，包含相同数量的黑色节点。

+ 这些性质保证了红黑树的平衡性，并且在最坏情况下仍然能够保持较高的插入，删除和查找操作效率。因此，在std::map中插入，删除和查找元素的平均时间复杂度为O(logN)，其中N是元素数量。

+ 需要注意的是，在C++11引入之前，C++标准库中还提供了一个无序关联容器 std::unordered_map，它使用哈希表作为底层实现，并且不保持元素按照特定的顺序。在 std::unordered_map 中，插入，删除和查找元素的平均时间复杂度为O(1)，但是哈希表可能会占用更多的内存，并且无法保证元素顺序。

## map为什么底层实现是红黑树而不是AVL

+ 在C++标准库中，std::map底层实现选择红黑树而不是AVL树是因为红黑树相对于AVL树有一些优势：
  + 插入和删除操作更高效： 红黑树的插入和删除操作比AVL树要快。这是因为红黑树通过旋转和颜色调整来保持平衡，不需要进行严格的平衡修复。AVL树则需要在每次插入或删除后执行可能多次的旋转以保持平衡，这导致了更多的开销。
  + 更好的空间利用率： 红黑树通常比AVL树占用更少的内存。AVL树每个节点都需要存储额外的平衡因子信息，而红黑树只需要一个额外位表示节点颜色即可
  + 查找操作性能相似： 在查找元素方面，红黑树和AVL树具有类似的性能。他们都具有O(logN)的时间复杂度，并且提供了快速的查找能力。

+ 综合考虑这些因素，C++标准库选择了选择使用红黑树作为 std::map 的底层实现，然后，在某些特定场景下，如果对插入和删除操作频繁，对空间要求较高且查找操作相对较少，可以考虑使用AVL树或者其他数据结构来满足特定需求

## IP分片 详解

IP分片是指在IPv4网络中，当IP数据包的长度超过网络链路的最大传输单元（MTU）时，路由器会将数据包分割成多个较小的片段进行传输。每个片段都是一个独立的IP数据包，但包含了原始数据包的一部分信息。下面详细解释IP分片的过程和相关概念：

1. **MTU（Maximum Transmission Unit）**：MTU是网络链路上能够传输的最大数据包大小。不同类型的网络链路（例如以太网、Wi-Fi、PPP等）都有不同的MTU值。当IP数据包的长度超过链路的MTU时，就需要进行分片。

2. **分片过程**：
   - 发送端：当发送端的IP数据包长度超过链路的MTU时，它会将数据包分割成多个较小的片段，并为每个片段设置标志字段，指示该片段是数据包的一部分，并记录了原始数据包的偏移量。
   - 路由器：路由器在转发IP数据包时，会根据下一跳的链路的MTU大小决定是否进行分片。如果下一跳链路的MTU小于数据包的长度，则路由器会将数据包分片，否则直接转发。
   - 接收端：接收端收到分片后的IP数据包后，会根据标志字段和偏移量将多个片段重组成原始的IP数据包，并将其传递给上层协议栈进行处理。

3. **分片相关字段**：
   - 标志字段（Flags）：标志字段包含3个比特，用于指示该片段的特性。其中第一个比特用于表示是否还有后续片段，第二个比特保留，第三个比特表示是否可以进行分片。
   - 偏移字段（Fragment Offset）：偏移字段指示该片段在原始数据包中的位置。它以8字节为单位，表示该片段相对于原始数据包的偏移量。

4. **重组过程**：接收端收到所有分片后，会根据IP头部中的标志字段和偏移量将多个片段重组成原始的IP数据包。重组过程中还需要处理重叠的片段和丢失的片段，以确保数据的完整性和正确性。

总的来说，IP分片是在IPv4网络中用于处理超过链路MTU的IP数据包的一种机制。它允许路由器将大的数据包分割成多个小的片段进行传输，从而确保数据能够顺利地在网络中传递，并在接收端进行重组，保证数据的完整性和可靠性。

## IP层有MTU报文分段策略，那TCP是不是可以不需要MSS分段策略

+ 在网络通信中，IP层负责将数据分成小块(报文段)进行传输，而TCP层则使用MSS(最大报文段长度)来确定每个TCP报文段的大小。MSS是TCP连接双方协商得出的一个值，表示在不发生分片的情况下能够发送的最大数据量

+ 虽然IP层已经实现了报文分段策略，但TCP仍然需要进行MSS分段策略。这是因为MTU(最大传输单元)代表了链路层能够传输的最大数据大小，而IP层根据MTU进行报文分段以适应链路层要求。然而，在经过不同网络设备和路径时，MTU可能会变化，导致某些链路上无法承载完整的TCP报文段。因此，TCP需要根据当前路径上的MTU值动态调整MSS，并将数据分成合适MTU大小的片段进行发送

+ 通过MSS分段策略，TCP可以确保在各种网络环境下可靠地传输数据，并避免发生IP层进一步对数据进行分片的情况。这有助于提高网络传输效率和可靠性。

## C++多线程编程用过哪些锁来实现同步或互斥

+ 互斥锁(Mutex) : 最常见的锁机制之一，通过lock()和unlock()函数来保护临界区，确保只有一个线程可以进入临界区执行操作

+ 递归锁(Recursive Mutex) : 类似于互斥锁，但允许同一线程多次枷锁。这种情况通常在嵌套函数调用时需要使用

+ 条件变量(Condition Variable) : 用于线程间的等待与唤醒机制。一个线程可以等待某个条件满足后再继续执行，另一个线程则可以发送信号来唤醒等待中的线程。

+ 读写锁(Read-Write Lock) : 也称为共享-独占锁，允许多个线程同时读取共享资源，但只允许一个线程独占写入

+ 自旋锁(Spinlock) : 在获取锁时不会主动阻塞线程，而是通过不断尝试获取直到成功。适用于对临界其的竞争非常短暂的情况

+ 屏障(Barrier) : 用于控制多个线程并行执行，在所有线程都达到屏障点后再继续执行后续操作

+ 这些锁都可以在C++标准库中找到对应的实现，例如 std::mutex, std::recursive_mutex, std::condition_variable, std::shared_mutex等。选择合适场景的锁机制是多线程编程中重要的技巧之一，需要根据具体需求和性能考虑作出选择。

## C和C++的区别

+ 设计思想上
  + C++是面向对象的语言，C是面向过程的语言

+ 语法上：
  + C++ 具有封装，继承，多态三种特性
  + C++ 相比C，增加了类型安全的功能，比如强制类型转换
  + C++ 支持范式编程，比如模板类，函数模板等。

## const 限定符

+ 作用
  + 修饰变量：表明该变量的值不可以被改变
  + 修饰指针：区分指向常量的指针和常量指针
  + 修饰引用：用于形参，既避免了拷贝，又避免了函数对值的修改
  + 修饰成员函数：表示函数不能修改成员变量(实际上是修饰this指针)

+ 补充：
  + 对于局部对象，常量存放在栈区
  + 对于全局对象，常量存放在全局/静态存储区
  + 对于字面值常量，常量存放在常量存储区(代码段)

## 指向常量的指针 VS 常量指针

+ 指向常量的指针(pointer to const):
  + 具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针(底层const)
  + const int * p 或者 int const * p

+ 常量指针(const pointer):
  + 常量指针是指 指针所指向的位置不能改变，即指针本身是一个常量(顶层const)，但是指针所指向的内容可以改变
  + 常量指针必须在声明的同时对其初始化，不允许先声明一个指针常量随后在对其赋值，这和声明一般的常量是一样的。
  + `int * const p = &a;`

## constexpr

+ 常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式
+ 一般来说，如果认定变量是一个常量表达式，那就把它声明成 constexpr 类型
+ 一个 constexpr 指针的初始值必须是 nullptr 或者 0， 或者是存储于某个固定地址中的对象
+ constexpr 函数是指能用于常量表达式的函数
+ 函数的返回类型及所有的形参的类型都得是字面值类型
+ 函数体中必须有且仅有一条return语句。

## #define VS const

+ #define
  + 宏定义，相当于字符替换
  + 预处理器处理
  + 无类型安全检查
  + 不分配内存
  + 存储在代码段(.text)
  + 可用 #undef 取消

+ const
  + 常量声明
  + 编译器处理
  + 有类型安全检查
  + 要分配内存
  + 存储在数据段(.data, .bbs)
  + 不可取消

## sizeof 运算符

+ sizeof 运算符的结果部分地依赖于其作用的类型
  + 对char或者类型为char的表达式执行sizeof运算，结果的1
  + 对引用类型执行sizeof运算符得到被引用对象所占空间的大小
  + 对指针执行sizeof运算得到指针本身所占空间的大小
  + 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小
  + 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素个执行一次sizeof运算并将所得结果求和
  + 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小。

+ 定义一个空类型，里面没有成员变量和成员函数，求sizeof结果为1.空类型的实例中不包括任何信息，本来求sizeof得到0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例，至于占用多少内存，由编译器决定，一般有一个char类新的内存
+ 如果该类型中添加一个构造函数和析构函数，再对该类型求sizeof结果仍为1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的类型只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数在实例内添加任何额外的信息
+ 如果把析构函数标记为虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位的机器上，一个指针占4个字节的空间，因此求sizeof得到4；在64位机器上，一个指针占8个字节的空间，因此求sizeof得到8

## 显式转换

+ static_cast ：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast
+ dynamic_cast ： 用于(动态)多态类型转换，只能用于含有虚函数的类，用于类层次间的向上向下转化
+ const_cast ： 去除”指向常量的指针“的const性质
+ reinterpret_cast ：为运算对象的位模式提供较低层次的重新解释，常用于函数指针的转换

## 形参和实参

+ 实参是形参的初始值

## static

+ 修饰局部变量 ： 使得被修饰的变量变为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序推出时销毁，默认初始化为0

+ 修饰全局变量 ： 限制了链接属性，是的全局变量只能在声明它的源文件中访问

+ 修饰普通函数 ： 使得函数只能在声明它的源文件中访问

+ 修饰类的成员变量和成员函数 ：使其只属于类而不是属于某个对象，对多个对象来说，静态数据成员只存储一处，供所有对象共用

+ 静态成员调用格式 ： <类名>::<静态成员>

+ 静态成员函数调用格式 ： <类名>::<静态成员函数名>(<参数表>)

## 参数传递

+ 指针参数传递本质上是值传递，所传递的是一个地址值

+ 一般情况下，输入用传值或者传const reference, 输出传引用(或指针)

## 内联函数的使用

+ 将函数指定为内联函数(inline)，通常就是将它在每个调用点上内联地展开
+ 一般来说，内联机制用于优化规模小(Google C++ Style 建议10行以下)，流程直接，频繁调用的函数
+ 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数

## 编译器对inline函数的处理步骤

+ 将inline函数体复制到inline函数调用点处
+ 为所用inline函数中的局部变量分配内存空间
+ 将inline函数的输入参数和返回值映射到调用方法的局部变量空间中
+ 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支(使用goto)

## 内联函数的优缺点

+ 优点：
  + 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高了程序运行速度
  + 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换(同普通函数)，而宏定义则不会
  + 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能
  + 内联函数在运行时可以调试，而宏定义不可以

+ 缺点
  + 代码膨胀，内敛是以代码膨胀(复制)为代价，消除函数调用带来的开销，如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
  + inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接
  + 是否内敛，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

## 返回类型和return语句

+ 调用一个返回引用的函数得到左值，其他返回类型得到右值

## 调试帮助

+ assert是一种预处理器宏。使用一个表达式作为它的条件 ： assert(expr)
+ 首先对expr求值，如果 表达式为false，assert输出信息并终止程序的执行。如果表达式为true，assert什么也不做

## 函数指针

+ 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关
+ C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址
+ 有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样
+ 用途：调用函数和做函数的参数，比如回调函数
```cpp
char *fun(char *p){...}  // 函数fun
char *(*pf)(char *p);    // 函数指针pf
pf = fun;                // 函数指针pf指向函数fun
pf(p);                   // 通过函数指针pf调用函数fun
```

## this 指针

+ this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象
+ this的目的总是指向”这个“对象，所以this是一个常量指针，被隐含地声明为 ClassName *const this，这意味着不能给this指针赋值
+ 当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据时，都隐式使用this指针
+ 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针
+ this并不是一个常规变量，而是个右值，所以不能取得this的地址(不能&this)
+ 在以下场景中，经常需要显式引用this指针
  + 为实现对象的链式引用
  + 为避免对同一对象进行赋值操作
  + 在实现一些数据结构时，例如list

## 拷贝函数

+ C++深拷贝与浅拷贝
  + 在未定义显式拷贝构造函数的情况下，系统会调用默认的拷贝函数：即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但是当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以此时必须采用深拷贝
  + 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝

## 析构函数

+ 整理析构函数的特性
  + 析构函数与构造函数的构造顺序相反
  + 当对象结束声明周期时，系统会自动执行析构函数
  + 析构函数声明时在函数名前加取反符号，不带任何参数，也没有返回值
  + 如果用户没有声明析构函数，系统会自动生成一个缺省的析构函数。
  + 如果类中有指针，且在使用的过程总动态申请了内存，那么需要显示构造析构函数，在销毁类指针，释放掉申请的内存空间，避免内存泄漏

## 访问控制与封装  public/private/protected

+ 定义在public说明符之后的成员在整个程序内可被访问，public成员定义接口
+ 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节
+ 基类希望它的派生类有权访问该成员，同时禁止其他用户访问，我们用受保护的(protected)访问运算符说明这样的成员

## struct与class的区别

+ struct与class定义的唯一区别就是默认的访问权限(struct默认是public,class默认是private)
+ 使用习惯上，只有少量成员变量的，使用struct定义

在C++中，struct和class都是用来定义自定义数据类型（类）的关键字，它们之间的区别主要体现在默认的访问控制权限和成员变量/函数的默认访问权限上。下面是详细解释：

1. **默认的访问控制权限**：
   - struct：在struct中，默认的访问控制权限是公有的（public），这意味着结构体的成员变量和成员函数默认是公有的，可以在外部访问。
   - class：在class中，默认的访问控制权限是私有的（private），这意味着类的成员变量和成员函数默认是私有的，只能在类的内部访问。

2. **成员变量和成员函数的默认访问权限**：
   - struct：结构体中的成员变量和成员函数默认是公有的，可以被外部访问。
   - class：类中的成员变量和成员函数默认是私有的，只能在类的内部访问。

3. **语义上的区别**：
   - 在C++中，struct通常用于表示一组相关的数据，而class通常用于表示一组相关的数据和操作。
   - 从语义上来说，struct更偏向于C语言中的结构体，主要用于存储数据；而class更偏向于面向对象的概念，可以包含数据和对数据的操作。

4. **继承权限默认设置**：
   - 在class中，如果不显式指定继承的访问权限，则默认是私有继承（private inheritance）。
   - 在struct中，如果不显式指定继承的访问权限，则默认是公有继承（public inheritance）。

除了上述区别外，struct和class在其他方面基本相同，它们都可以包含成员变量和成员函数，都可以进行继承和多态等操作。在实际编程中，选择使用struct还是class取决于具体的需求和编程习惯，但通常情况下，struct更适合简单的数据封装，而class更适合面向对象的设计。

## 友元

+ 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元(friend)

## 构造函数的初始化顺序

+ 成员变量的初始化顺序与他们在类定义中的出现顺序一致： 构造函数初始值列表中初始值的前后位置关系不会影响

## explicit

+ 用于类的构造函数，阻止其执行隐式类型转换，但是仍可以被用来进行显式类型转换

## C++ explicit关键字的作用？

在C++中，`explicit`关键字用于修饰类的构造函数，它有两种主要用途：

1. **禁止隐式类型转换：** 当一个构造函数被声明为`explicit`时，它将禁止编译器执行隐式类型转换。这意味着，该构造函数只能在显式调用的情况下进行类型转换，而不能在隐式类型转换的上下文中使用。

   ```cpp
   class MyClass {
   public:
       explicit MyClass(int x) : value(x) {}

       int getValue() const {
           return value;
       }

   private:
       int value;
   };

   void exampleFunction(MyClass obj) {
       // 在没有 explicit 关键字的情况下，可能发生隐式类型转换
       // MyClass newObj = 42;  // 错误，因为构造函数使用 explicit，禁止隐式类型转换
       MyClass newObj(42);  // 正确，需要显式调用构造函数
       int val = newObj.getValue();
   }
   ```

   上面的例子中，如果构造函数没有使用`explicit`关键字，那么在`exampleFunction(42)`这一行可能发生隐式类型转换，导致错误。通过使用`explicit`关键字，可以防止这种隐式类型转换。

2. **防止二义性问题：** 在涉及到函数重载的情况下，`explicit`关键字还可以防止二义性问题。如果一个构造函数可以被隐式调用，而另一个构造函数不能，那么在某些上下文中可能会导致编译器无法确定应该调用哪个构造函数的问题。使用`explicit`可以帮助解决这种二义性。

总的来说，`explicit`关键字用于提高代码的安全性和可读性，确保在类型转换的情况下只能进行显式调用。

## 迭代器

+ 迭代器(iterator)模式，又称游标(Cursor)模式，用于提供一种方法顺序访问一个聚合对象中各种元素，而又不需要暴露该对象的内部表示
+ 迭代器本质上是类模板，只是表现的像指针

## 顺序容器操作 emplace

+ 当调用push或者insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素

## resize / reserve

+ resize : 改变容器内含有元素的数量
+ reserve : 改变容器的最大容量

## 容器操作可能使迭代器失效

+ 在向容器中添加元素后：
  + 如果容器是vector或者string，且存储空间被重新分配，则指向容器的迭代器，指针和引用都会失效
  + 对于deque，插入到除首尾之外的任何位置都会导致迭代器，指针和引用失效
  + 对于list，指向容器的迭代器，指针和引用仍然有效。

+ 从容器删除元素后：
  + 对于list，指向容器的迭代器指针和引用仍然有效
  + 对于deque，在首尾之外的任何位置删除元素，其他元素的迭代器也会失效。
  + 对于关联式容器(例如 std::set / std::map)，插入元素不会使任何迭代器失效
  + 对于无序关联式容器(例如 std::unordered_set / std::unordered_map)，插入元素之后如果发生了rehash(新元素的个数大于max_load_factor() * bucket_count())，则所有迭代器失效

## vector对象是如何增长的

+ 当不得不获取新的内存空间时，vector和string的实现通常会分配一个比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以用来保存更多的新元素。这样，就需要每次添加新元素都重新分配容器和内存空间了

+ capacity 操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素，reserve操作允许我们通知容器它应该准备保存多少个元素
+ 初始时刻 vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ 从空间上分析，扩容因子越大，意味着预留空间越大，浪费的空间也越多，所以从空间考虑，扩容因子越小越好
+ 从时间上分析，如果预留空间不足的话，就需要重新开辟一段空间，把原有的数据复制到新空间，如果扩容因子无限大的话，那显然就不在需要额外开辟空间了，所以从时间角度看，扩容因子越大越好

## 容器适配器

+ 除了顺序容器外，标准库还定义了三个顺序容器适配器：stack, queue和priority_queue
+ 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样
+ 默认情况下，stack和queue时基于deque实现的，priority_queue是在vector之上实现的

## lambda 表达式

+ 一个lambda表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。一个lambda表达式具有如下形式
```cpp
[capture list](parameter list)->return type (function body)
```
+ 其中capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)
+ return type, parameter list和function body与任何普通函数一样，分别表示返回类型，参数列表和函数体。但是与普通函数不同，lambda必须使用尾置返回来指定返回类型

+ 我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体:
```cpp
auto f = [] (return 42);
```

## 关联容器

+ map ： 关键字-值对；
+ set ： 关键字即值
+ map ： 按关键字有序保存元素(底层为红黑树)；unordered_map：无序集合(底层为哈希表)
+ map : 关键字不可重复出现；multimap : 关键字可重复出现

## 智能指针

+ 智能指针的行为类似常规指针，重要的区别在于它负责自动释放所指向的对象

+ shared_ptr
  + 允许多个指针指向同一个对象
  + 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。一旦一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象

+ unique_ptr
  + 独占所指向的对象

+ weak_ptr
  + weak_ptr是一种弱引用，指向shared_ptr所管理的对象
  + 可打破环状引用(cycles of reference，两个其实已经没有被使用的对象彼此互相指向，使之看似还在被使用的状态)的问题

+ make_shared
  + make_shared 在动态内存中分配一个对象并初始化它，返回执行此对象的shared_ptr

## C++ 智能指针 详解

C++智能指针是一种用于管理动态内存的机制，它能够在不再需要对象时自动释放所分配的内存，从而避免了内存泄漏等问题。C++标准库提供了两种主要的智能指针：`std::unique_ptr` 和 `std::shared_ptr`。下面是对这两种智能指针的详细解释：

### std::unique_ptr：

1. **特点**：
   - `std::unique_ptr` 表示独占所有权的指针，即同一时间只能有一个 `std::unique_ptr` 指向某个对象。
   - 当 `std::unique_ptr` 被销毁时，它所管理的对象也会被销毁，从而自动释放所占用的内存。

2. **使用方法**：
   - 创建 `std::unique_ptr` 对象时，可以通过 `std::make_unique` 函数或直接使用构造函数来初始化。
   - `std::unique_ptr` 对象可以通过 `get` 方法获取原始指针，通过 `reset` 方法重新指定对象或释放指针。

3. **示例**：
   ```cpp
   #include <memory>

   int main() {
       std::unique_ptr<int> ptr = std::make_unique<int>(42);
       std::cout << *ptr << std::endl;  // 输出 42
       // ptr 销毁时自动释放内存
       return 0;
   }
   ```

### std::shared_ptr：

1. **特点**：
   - `std::shared_ptr` 表示共享所有权的指针，多个 `std::shared_ptr` 可以同时指向同一个对象。
   - 当最后一个指向对象的 `std::shared_ptr` 被销毁时，对象才会被销毁，从而自动释放所占用的内存。

2. **使用方法**：
   - 创建 `std::shared_ptr` 对象时，可以通过 `std::make_shared` 函数或直接使用构造函数来初始化。
   - `std::shared_ptr` 对象可以通过 `get` 方法获取原始指针，通过 `reset` 方法重新指定对象或释放指针。

3. **示例**：
   ```cpp
   #include <memory>

   int main() {
       std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
       std::shared_ptr<int> ptr2 = ptr1; // ptr2 和 ptr1 共享所有权
       std::cout << *ptr1 << std::endl;  // 输出 42
       std::cout << *ptr2 << std::endl;  // 输出 42
       // ptr1 和 ptr2 销毁时自动释放内存
       return 0;
   }
   ```

### 其他智能指针：

除了 `std::unique_ptr` 和 `std::shared_ptr`，C++标准库还提供了 `std::weak_ptr` 和 `std::auto_ptr`（已被弃用）等智能指针，它们各自具有特定的功能和用途。`std::weak_ptr` 用于解决 `std::shared_ptr` 的循环引用问题，`std::auto_ptr` 已经被 `std::unique_ptr` 替代，不推荐使用。

智能指针的引入极大地简化了动态内存管理，减少了内存泄漏和悬空指针等问题的发生，提高了程序的安全性和可靠性。

## C++ std::shared_ptr循环引用会引发什么？

在 C++ 中，`std::shared_ptr` 的循环引用会导致内存泄漏，因为它会阻止对象的析构函数被调用，从而无法正确释放内存。

循环引用指的是两个或多个对象相互持有 `std::shared_ptr`，形成了一个环形的引用关系。在这种情况下，每个对象都至少有一个 `std::shared_ptr` 指向它，因此它们的引用计数都不会变为 0，即使没有任何外部引用，它们也不会被销毁。

当循环引用发生时，`std::shared_ptr` 无法及时释放内存，从而导致内存泄漏。这是因为 `std::shared_ptr` 使用引用计数来管理内存，每个对象都会维护一个引用计数，当引用计数为 0 时才会释放内存。但是在循环引用中，每个对象都互相持有对方的 `std::shared_ptr`，导致它们的引用计数永远不会降为 0。

为了避免循环引用导致的内存泄漏，可以考虑以下几种解决方案：
1. 使用 `std::weak_ptr` 打破循环引用：`std::weak_ptr` 是一种弱引用指针，它不会增加对象的引用计数，因此可以用于解决循环引用问题。其中一个对象持有 `std::shared_ptr`，而另一个对象持有 `std::weak_ptr`，这样即使存在循环引用，也不会导致内存泄漏。
2. 尽量避免循环引用：在设计程序时，尽量避免出现循环引用的情况，可以通过合理设计对象之间的关系来减少循环引用的发生。
3. 使用其他智能指针：如 `std::unique_ptr`，它是独占所有权的智能指针，不会发生循环引用问题，但需要注意不能用于对象之间的共享所有权的情况。

## 怎么解决std::shared_ptr循环引用的问题

解决 `std::shared_ptr` 循环引用问题的一种常见方法是使用 `std::weak_ptr` 来打破循环引用。`std::weak_ptr` 是一种弱引用指针，它不会增加对象的引用计数，因此可以用于解决循环引用问题。以下是解决循环引用问题的步骤：

1. **设计对象关系：** 在设计程序时，尽量避免出现循环引用的情况。如果存在对象之间的循环引用，应该仔细分析对象之间的关系，并尝试重新设计以减少循环引用的发生。

2. **使用std::weak_ptr：** 将循环引用中的其中一个指针替换为 `std::weak_ptr`。由于 `std::weak_ptr` 不会增加对象的引用计数，因此它不会导致循环引用。通过使用 `std::weak_ptr`，可以避免循环引用导致的内存泄漏。

3. **在需要访问对象时使用lock()：** 如果需要在 `std::weak_ptr` 所指向的对象上执行操作，可以使用 `lock()` 方法将 `std::weak_ptr` 转换为 `std::shared_ptr`。`lock()` 方法会检查被引用的对象是否仍然存在，如果存在则返回一个有效的 `std::shared_ptr`，否则返回一个空指针。通过使用 `lock()` 方法，可以确保操作的安全性，并避免在对象已经被销毁时访问无效内存。

下面是一个示例，演示了如何使用 `std::weak_ptr` 来解决循环引用的问题：

```cpp
#include <memory>

class B;

class A {
public:
    std::shared_ptr<B> b_ptr;
};

class B {
public:
    std::weak_ptr<A> a_weak_ptr; // 使用 weak_ptr 打破循环引用
};

int main() {
    std::shared_ptr<A> a_ptr = std::make_shared<A>();
    std::shared_ptr<B> b_ptr = std::make_shared<B>();

    a_ptr->b_ptr = b_ptr;
    b_ptr->a_weak_ptr = a_ptr;

    return 0;
}
```

在这个示例中，`B` 类中使用 `std::weak_ptr` 来持有 `A` 类的指针，从而打破了 `A` 类和 `B` 类之间的循环引用。这样可以确保对象在不再需要时能够正确地被销毁，避免内存泄漏的发生。

## 拷贝控制 对象移动

+ 右值引用：所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获的右值引用。右值引用有一个重要的性质：只能绑定到一个将要销毁的对象
+ 左值持久，右值短暂：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时对象
+ 通过调用std::move来获得绑定到左值上的右值引用
```cpp
int &&rr1 = 42;   // 正确：字面常量是右值
int &&rr2 = rr1;  // 错误：表达式rr1是左值
int &&rr3 = std::move(rr1);  // ok
```

## OOP:概述

+ 面向对象程序设计(object-oriented programming)的核心思路是数据抽象(封装)，继承和动态绑定(多态)
  + 通过数据抽象，我们可以将接口与实现分离
  + 使用继承，可以定义相似的类型并对其相似关系建模
  + 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以同意的方式使用他们的对象

## 定义派生类和基类 -- 初始化顺序

+ 每个类控制它自己的成员初始化过程、
+ 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

## 静态多态 / 动态多态

+ 静态多态是通过重载和模板技术实现，在编译的时候确定
+ 动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定

+ 重载： 两个函数名字相同，但是参数的个数或者类型不同
+ 重写： 子类继承父类，父类函数中被声明为虚函数，子类中重新定义了这个虚函数

## 虚函数

+ 虚函数： 基类希望派生类覆盖的函数，可以将其定义为虚函数，这样每一个派生类可以个自定义适合自身的版本
+ 当基类定义virtual函数的时候，它希望派生类可以自己定义这个函数
+ 如果使用virtual，程序依据引用或者指针所指向对象的类型来选择方法
+ 如果不使用virtual，程序依据引用类型或者指针类型选择一个方法
+ 虚函数表指针：在有虚函数的类的对象最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表
+ 虚函数表中放了虚函数的地址，实际的虚函数在代码段(.text)中
+ 当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址
+ 使用了虚函数，会增加访问内存开销，降低效率

C++中的虚函数是一种用于实现多态性（Polymorphism）的重要机制，它允许子类重写（override）父类的成员函数，并在运行时动态地选择调用哪个版本的函数。以下是关于C++虚函数的详细解释：

1. **声明虚函数**：
   - 在C++中，通过在基类（父类）中声明虚函数，可以将其标记为虚函数。使用关键字`virtual`在函数声明前面声明函数为虚函数。
   - 虚函数的声明格式如下：
     ```cpp
     virtual return_type function_name(parameters) = 0;
     ```
   - 在基类中使用`= 0`来声明纯虚函数，纯虚函数没有实现，必须在派生类中实现。

2. **实现虚函数**：
   - 派生类（子类）可以选择性地重写基类的虚函数，通过在派生类中提供相同的函数签名和关键字`override`来实现。
   - 派生类可以选择性地使用`override`关键字，以明确地表明该函数是对基类虚函数的重写。

3. **多态性**：
   - 多态性是指通过基类指针或引用调用虚函数时，会根据实际对象的类型来动态地选择调用哪个版本的函数。
   - 运行时多态性（Run-time Polymorphism）是在运行时根据对象的类型来选择调用的函数版本，而不是在编译时确定。

4. **虚函数表（vtable）**：
   - 虚函数通过使用虚函数表来实现多态性。每个包含虚函数的类都有一个虚函数表，其中存储了指向各个虚函数的指针。
   - 每个对象都包含一个指向其类的虚函数表的指针。当调用虚函数时，程序会根据对象的虚函数表指针来确定调用哪个函数。

5. **动态绑定**：
   - 虚函数的调用是动态绑定的（Dynamic Binding），意味着在运行时确定要调用的函数版本。
   - 这与静态绑定（Static Binding）不同，静态绑定在编译时确定要调用的函数版本。

6. **虚析构函数**：
   - 在C++中，通常将基类的析构函数声明为虚析构函数。这样可以确保在删除派生类对象时，会调用派生类的析构函数。

虚函数是C++中实现多态性的重要机制，它允许子类覆盖父类的函数，并在运行时动态地选择调用的函数版本。虚函数通过虚函数表实现多态性，动态绑定确保在运行时确定调用的函数版本。

## 析构函数为什么是虚函数？

+ 将可能会被继承的基类的析构函数设置为虚函数，可以保证当我们new一个派生类，然后使用基类指针指向该派生类对象，释放掉基类指针时可以释放掉派生类的空间，防止内存泄漏

## C++ 构造函数可以是虚函数吗

在 C++ 中，构造函数不能声明为虚函数。这是因为在对象创建时，虚函数表尚未形成，因此构造函数不能被动态绑定。在构造函数期间，对象的动态类型还不可用，因此虚函数的行为是未定义的。如果您尝试在构造函数中声明虚函数，编译器可能会发出警告或错误。

## 为什么C++默认析构函数不是虚函数？

+ C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存；所以只有当一个类会被用作基类时才将其设置为虚函数。

## 抽象基类

+ 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做，书写=0就可以将一个虚函数说明为纯虚函数
+ 含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类(abstract base class)

## 虚函数 VS 纯虚函数

+ 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能够让这个函数在它的子类里面可以被覆盖(override)，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，他要留到子类里面去实现
+ 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类
+ 虚函数的类用于 实作继承，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
+ 带纯虚函数的类叫做抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类

## 访问控制与继承

+ 公有继承：保持原始状态(没有特殊要求一般用公有继承)
+ 私有继承：基类的所有成员都变为派生类的私有成员
+ 保护继承：基类的public作为派生类的保护成员，其他不变

## 多重继承与虚继承

+ 虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝，即浪费存储空间，又存在二义性的问题
+ 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节)和虚基类表(不占用类对象的存储空间。)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了)；当虚继承的子类被当作父类继承时，虚基类指针也会被继承。
+ 实际上，vbptr指的是虚基类表指针(virtual base table pointer)，该指针指向了一个虚基类表(virtual table), 虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚基类也不用像普通多继承那样维持着公共基类(虚基类)的两份同样的拷贝，节省了存储空间

## new & delete

+ 当我们使用一条new表达式时，实际执行了三步操作
  + new表达式调用了一个名为operator new(或者 operator new[])的标准库函数，该函数(从自由存储区上)分配一块足够大的，原始的，未命名的内存空间(无需指定内存块的大小)以便存储特定类型的对象(或者对象的数组)
  + 编译器运行响应的构造函数以构造这些对象，并为其传入初值
  + 对象被分配了空间并构造完成，返回一个指向该对象的指针

+ 当我们使用了一条delete表达式删除一个动态分配的对象时，实际执行了两步操作：
  + 对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数
  + 编译器调用名为operator delete(或者operate delete[])的标准库函数释放内存空间

## new和malloc有什么区别

`new` 和 `malloc` 是 C++ 中用于动态内存分配的两种不同的方式，它们有以下主要区别：

1. **类型安全性：**
   - `new` 是 C++ 的运算符，能够为指定的类型分配内存，并返回相应类型的指针。由于是针对特定类型的操作，因此 `new` 在分配内存时会自动计算所需的字节数，并将内存初始化为该类型的默认值。
   - `malloc` 是 C 语言中的库函数，它分配的内存是以字节为单位的，返回的是 `void*` 类型的指针。因此，使用 `malloc` 分配内存后需要进行显式的类型转换。

2. **构造函数和析构函数的调用：**
   - 当使用 `new` 分配内存时，会自动调用对象的构造函数进行初始化，并在对象被销毁时调用析构函数。
   - `malloc` 只是分配内存，不会调用任何构造函数或析构函数。如果需要在分配内存时执行一些初始化操作，需要手动调用构造函数。

3. **内存大小：**
   - `new` 操作符会根据指定的类型自动计算所需的内存大小，并返回一个指向该类型的指针。
   - `malloc` 分配的内存大小需要显式指定，以字节为单位。

4. **异常处理：**
   - 如果 `new` 分配内存失败，会抛出 `std::bad_alloc` 异常。
   - 如果 `malloc` 分配内存失败，会返回 `NULL`，需要手动检查分配是否成功。

5. **对于数组的支持：**
   - `new` 可以用于动态分配数组，并自动计算所需的内存大小。
   - `malloc` 分配数组时需要手动计算所需的内存大小，并进行类型转换。

综上所述，`new` 提供了更加方便、类型安全、自动化的内存分配方式，并支持对象构造和析构函数的调用，而 `malloc` 则是 C 语言的库函数，更为底层，需要手动管理内存分配和释放，并且不支持类型安全和自动化的构造和析构过程。在 C++ 中推荐优先使用 `new` 和 `delete` 来进行动态内存分配和释放。

## new的对象可以使用free释放吗？

不，`new` 分配的对象不能使用 `free` 函数进行释放。在 C++ 中，应该使用 `delete` 运算符来释放由 `new` 分配的内存。

`new` 和 `delete` 是 C++ 中用于动态内存分配和释放的运算符，它们是对应的，分别用于分配和释放内存。

使用 `delete` 来释放 `new` 分配的对象有以下几点原因：
1. `new` 和 `delete` 是 C++ 的运算符，对应关系更为明确，使用它们能够让代码更加清晰和易读。
2. `delete` 会调用对象的析构函数来释放资源，确保对象被正确地销毁，而 `free` 不会调用对象的析构函数。
3. `new` 和 `delete` 以及 `malloc` 和 `free` 并非完全兼容，混合使用会导致未定义行为。

因此，在 C++ 中，应该始终使用 `delete` 来释放由 `new` 分配的内存，而不是 `free`。

## malloc & free

+ malloc需要显式的指出内存大小：函数接收一个表示待分配字节数的size_t
+ 返回指向分配空间的指针(void*)或者返回0以表示分配失败(从堆上动态分配内存)

+ free函数接收一个void*，踏实malloc返回的指针的副本，free将相关内存返回给系统，调用free(0)没有任何意义

+ operate new的一种简单实现
```cpp
void *operater new(size_t size)
{
  if (void *men = malloc(size))
  {
    return mem;
  }
  else
  {
    throw bad_alloc();
  }
}
```

## malloc实现原理 详解

`malloc()` 是C语言标准库中用于动态内存分配的函数，它用于在程序运行时动态地分配一块指定大小的内存空间。下面是 `malloc()` 实现原理的简要解释：

1. **空闲内存管理**：
   - `malloc()` 通过管理一块内存池来实现内存的分配和释放。该内存池中包含了未分配的空闲内存块。
   - 初始时，整个内存池是一片连续的未分配内存。

2. **内存分配**：
   - 当程序调用 `malloc(size)` 时，`malloc()` 首先搜索内存池中的空闲内存块，找到一块足够大的空闲内存块。
   - 如果找到了足够大的空闲内存块，`malloc()` 将这块内存分配给程序，并返回指向这块内存的指针。
   - 如果没有足够大的空闲内存块，`malloc()` 可以选择增加内存池的大小，从操作系统中请求更多的内存，然后将其中一部分内存分配给程序。

3. **内存释放**：
   - 当程序调用 `free(ptr)` 时，其中 `ptr` 是之前由 `malloc()` 返回的指针，`free()` 将释放 `ptr` 指向的内存块，并将该内存块标记为空闲状态。
   - `free()` 并不将内存块立即返回给操作系统，而是将其标记为空闲状态，以便后续的 `malloc()` 调用可以重用这块内存。

4. **内存分片**：
   - 内存池中的内存分为不同大小的内存块，这些内存块大小通常以 2 的幂次方递增。
   - 当程序请求分配的内存大小不是内存块大小的整数倍时，`malloc()` 可能会选择比请求稍大一点的内存块，将多余的内存保留在这个内存块中，以便后续的小内存请求可以重用这个内存块的剩余空间。

5. **内存对齐**：
   - `malloc()` 返回的内存地址通常是按照特定的字节对齐方式对齐的，以提高内存访问效率。

总的来说，`malloc()` 的实现主要包括管理内存池、搜索空闲内存块、分配内存、释放内存等步骤。通过这些步骤，`malloc()` 实现了在程序运行时动态地分配和释放内存的功能。

## tcmalloc 详解

TCMalloc（Thread-Caching malloc）是由Google开发的用于多线程环境下的高效内存分配器。它是对标准的malloc函数的替代，专门针对多线程环境和大规模内存分配进行了优化。下面是TCMalloc的详细解释：

### 特点和优势：

1. **线程缓存（Thread-Caching）**：
   - TCMalloc通过为每个线程分配一个本地线程缓存（Thread Cache），避免了多线程环境下频繁的锁竞争。
   - 每个线程都有一个独立的内存缓存，减少了线程之间的竞争和同步开销，提高了内存分配的并发性能。

2. **粒度适应（Size Class）**：
   - TCMalloc将内存分配划分为不同的大小类别（Size Class），针对不同大小的内存请求采用不同的分配策略，以最小化内存碎片和提高内存使用效率。
   - TCMalloc会根据内存请求的大小选择合适的Size Class进行分配，从而避免了传统内存分配器可能存在的内存浪费问题。

3. **高效的内存回收（Memory Reclamation）**：
   - TCMalloc使用高效的内存回收机制，包括延迟释放（Delayed Freeing）和定期回收（Central Cache）等，以减少内存碎片和提高内存回收的效率。
   - TCMalloc会将未使用的内存块缓存在本地线程缓存中，定期将这些内存块回收到全局内存池中。

4. **空间效率和性能**：
   - TCMalloc具有较高的内存使用效率和分配性能，在大规模多线程环境下表现良好。
   - 与标准的malloc函数相比，TCMalloc在大规模并发情况下可以显著减少锁竞争和内存碎片，并提高内存分配的性能和效率。

5. **可配置性**：
   - TCMalloc提供了丰富的配置选项，可以根据应用程序的需求进行调整和优化，包括线程缓存大小、内存回收策略等。

### 使用场景：
- 大规模多线程应用程序：TCMalloc特别适用于需要高效处理大量并发内存分配请求的多线程应用程序，如服务器端应用、分布式系统等。

### 注意事项：
- TCMalloc并不是适用于所有场景的通用内存分配器，某些特定的应用场景可能需要根据实际情况选择合适的内存分配器。
- 在使用TCMalloc时，需要注意合理配置相关参数，以达到最佳的性能和效率。

总的来说，TCMalloc通过线程缓存、粒度适应和高效的内存回收等优化手段，提供了高效的内存分配和回收机制，特别适用于大规模多线程环境下的高性能应用程序。

## 固有的不可移植性

+ volatile
  + 当对象的值可能在程序控制或者检测之外(操作系统，硬件，其他线程等)被改变时，应该将该对象声明为 volatile，关键字 volatile 告诉编译器不应该对这样的对象进行优化
  + volatile 关键字声明的变量，每次访问时都必须从内存中取出值(没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值)

+ extern
  + 在多个文件之间共享对象
  + extern "C" 的作用是让C++编译器将 extern "C"声明的代码当作C语言代码处理，可以避免C++因为符号修饰导致代码不能和C语言库中的符号进行链接的问题

## .h 和 .cpp 文件的区别

+ .h文件里面放声明，.cpp文件里面放定义
+ .cpp文件会被编译成实际的二进制代码，而.h文件实在被include中之后复制粘贴到.cpp文件中

## 编译和链接

+ 预编译(预处理) ： 预编译过程主要处理哪些源代码文件中以 "#" 开始的预编译指令，例如 #include, #define等，生成.i 或者.ii文件
+ 编译：把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生产相应的汇编代码文件(.s文件)
+ 汇编：将汇编代码转变机器可以执行的指令(机器码)，生成.o文件
+ 链接：链接器进行地址和空间分配，符号决议，重定位等步骤，生成.out文件

## 程序的内存布局

+ 一般来讲，应用程序使用的内存空间里有如下默认区域：
  + 栈：栈用于维护函数调用的上下文。由操作系统自动分配释放，一般包含一下几个方面
    + 函数的返回地址和参数
    + 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
    + 保存上下文：包括函数调用前后需要保持不变的寄存器
  + 堆：堆是用来容纳应用程序动态分配的内存区域。由程序员分配释放，当程序使用malloc或者new分配内存时，得到的内存来自堆里
  + 可执行文件映像：存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里
  + .data : 静态区，存放全局变量和局部静态变量
  + .bss : 存放未初始化的全局变量和局部静态变量
  + .text : 代码区，存放C语言编译后的机器代码，不可在运行期间修改
  + 保留区：保留区并不是一个单一的内存区域，而是对内存中收到保护而禁止访问的内存区域的总称。例如通常C语言将无效指针赋值为0(NULL)，因此0地址正常情况下不可能有有效的访问数据

## 段错误 ： 程序出现段错误(segment fault)或者非法操作，该内存地址不能read/write的错误信息，是什么原因

+ 这是典型非法指针解引用造成的错误。当指针指向一个不允许读或者写的内存地址，而程序却试图利用指针来读或者写该地址的时候，就会出现这个错误。可能的段错误发生的时机如下：
  + 指针没有初始化或者初始化未nullptr，之后没有给他一个合理的值就开始使用指针
  + 使用野指针(指向一个已经删除的对象或者未申请访问受限内存区域的指针)
  + 指向常量的指针试图修改相关内容

## 编译型语言 VS 解释型语言

+ 有的编程语言要求必须提前将所有原地阿玛一次性转换成二进制指令，也就是生成一个可执行程序(Windows下的exe)，例如C语言，C++，Golang，Pascal，汇编等，这些编程语言成为编译型语言，使用的转换工具称为编译器

+ 有的编程语言可以一边执行一边转换，需要那些源代码就转换哪些源代码，不会生成可执行程序，例如Python，JavaScript，PHP，MATLAB等，这种编程语言称为解释型语言，使用的转换工具称为解释器

## C++ 可变长模板 详解

可变长模板（Variadic Templates）是C++11引入的一项特性，它允许模板接受可变数量的参数。这使得在泛型编程中更加灵活，能够处理不同数量和类型的参数。下面详细解释可变长模板的主要概念和用法：

### 1. 模板参数包（Template Parameter Pack）

可变长模板中的关键元素之一是**模板参数包**，它使用省略号（`...`）表示。模板参数包允许模板接受可变数量的参数。在函数模板中，模板参数包可以用于表示函数的参数列表。

```cpp
template <typename... Args>
void myFunction(Args... args) {
    // 函数体
}
```

在上述例子中，`Args`是一个模板参数包，可以接受任意数量的模板参数。

### 2. 模板展开（Template Expansion）

**模板展开**是指将模板参数包中的参数展开，以便在模板中使用这些参数。通常使用递归或折叠表达式来实现模板展开。

```cpp
template <typename T, typename... Args>
void myFunction(T first, Args... rest) {
    // 处理 first
    // 递归调用处理剩余的参数
    myFunction(rest...);
}
```

在上述例子中，`myFunction`通过递归调用实现了对参数的展开处理。

### 3. 基本情况与递归模板

在使用可变长模板时，通常需要定义基本情况和递归模板，以处理模板参数包中的参数。

```cpp
// 基本情况
template <typename T>
void process(T value) {
    // 处理单个参数的情况
}

// 递归模板
template <typename T, typename... Args>
void process(T first, Args... rest) {
    // 处理 first
    // 递归调用处理剩余的参数
    process(rest...);
}
```

### 4. 使用递归展开模板参数包

在递归展开模板参数包时，可以使用递归函数、递归类模板或者C++17引入的折叠表达式（fold expression）。

#### 4.1 递归函数

```cpp
template <typename T>
void process(T value) {
    // 处理单个参数的情况
}

template <typename T, typename... Args>
void process(T first, Args... rest) {
    // 处理 first
    process(rest...);  // 递归调用处理剩余的参数
}
```

#### 4.2 递归类模板

```cpp
template <typename T>
struct Processor {
    static void process(T value) {
        // 处理单个参数的情况
    }
};

template <typename T, typename... Args>
struct Processor {
    static void process(T first, Args... rest) {
        // 处理 first
        Processor<Args...>::process(rest...);  // 递归调用处理剩余的参数
    }
};
```

#### 4.3 折叠表达式（C++17）

```cpp
template <typename... Args>
void process(Args... args) {
    (processSingle(args), ...);  // 使用折叠表达式展开参数包
}

template <typename T>
void processSingle(T value) {
    // 处理单个参数的情况
}
```

### 示例：打印任意数量参数的函数

下面是一个示例，演示了如何使用可变长模板实现一个函数，用于打印任意数量的参数：

```cpp
#include <iostream>

// 基本情况：当没有参数时，终止递归
void print() {
    std::cout << std::endl;
}

// 递归情况：打印第一个参数，并递归调用处理剩余的参数
template <typename T, typename... Args>
void print(T first, Args... rest) {
    std::cout << first << " ";
    print(rest...);
}

int main() {
    print(1, "Hello", 3.14, 'a');
    return 0;
}
```

在这个例子中，`print`函数接受任意数量的参数，并使用递归展开参数包，打印每一个参数。这样，你可以传递不同数量和类型的参数给`print`函数。

## C++ 如何解决多继承造成的类成员重复的问题？

在C++中，多继承可能导致一个类从多个基类中继承相同的成员（变量或函数），这可能会引起命名冲突和二义性。为了解决这个问题，C++提供了一些机制：

1. **虚继承（Virtual Inheritance）：** 使用虚继承可以解决菱形继承（diamond inheritance）问题，其中一个派生类从两个不相关的基类派生而来，而另一个派生类继承这两个基类。虚继承可以防止在派生类中出现多个对同一基类的实例。

    ```cpp
    class Base {
    public:
        int data;
    };

    class Derived1 : public virtual Base {
    };

    class Derived2 : public virtual Base {
    };

    class MultipleDerived : public Derived1, public Derived2 {
    };

    int main() {
        MultipleDerived obj;
        obj.data = 42; // 可以正常访问基类的成员
        return 0;
    }
    ```

2. **使用命名空间（Namespace）：** 将基类的成员放置在不同的命名空间中，从而避免命名冲突。

    ```cpp
    namespace FirstNamespace {
        class Base {
        public:
            int data;
        };
    }

    namespace SecondNamespace {
        class Base {
        public:
            int data;
        };
    }

    class Derived : public FirstNamespace::Base, public SecondNamespace::Base {
    public:
        void someFunction() {
            FirstNamespace::Base::data = 42;  // 使用命名空间解决命名冲突
            SecondNamespace::Base::data = 24;
        }
    };
    ```

3. **重命名成员：** 在派生类中可以重命名具有冲突名称的成员，以避免二义性。

    ```cpp
    class Base {
    public:
        int data;
    };

    class Derived1 : public Base {
    };

    class Derived2 : public Base {
    };

    class MultipleDerived : public Derived1, public Derived2 {
    public:
        int derived1Data; // 重命名避免冲突
        int derived2Data; // 重命名避免冲突
    };
    ```

这些方法的选择取决于具体的情况。虚继承通常在菱形继承中使用，而使用命名空间或重命名成员则可以帮助避免普通的多继承带来的命名冲突。在设计时，尽量避免过于复杂的多继承结构，以减少潜在的问题。

## C++ 为什么要有class？

+ 考察目的：
  + 考对oop基础的理解，而不是考死语法。可引申出动态多态，RAII，类型系统，隐式成员等一票问题。大牛还是菜鸡，用这一个问题就暴露了

+ 参考答案
  + 类是C++用来实现OOP封装、继承和多态的核心机制

## 指针是什么？你能不用指针写C++程序吗？指针好还是不好？

+ 考察目的
  + 这个问题不仅考C基础和计算机原理基础，还可引申出引用，拷贝和移动语义，const correctness，value semantic等一票基础问题。

+ 参考答案
  + C++用虚函数实现多态，用RAII（和析构，异常机制）实现自动资源管理，用拷贝和移动定义资源的复制和转移，进而用隐式成员（Rule of 5，析构，拷贝构造，拷贝赋值，移动构造，移动赋值）来帮助用户省去手写冗余代码，最终达到不多写一个字的资源管理。如果说面向对象的概念已经有些过时了，资源管理却是永不过时的，也是C++从机制上不同于C的最主要一点。有些人写的糟糕C++代码其实是把写面向过程套了一层class的皮、滥用多态让代码纠缠不清、最终既不仅没有简化逻辑，也没有简化资源管理。

## 经典问题：vector和list有什么区别？

+ 考察目的
  + 一个不了解C++如何控制资源颗粒度的程序员恐怕不是一个好的C++程序员。可引申出一大票算法和数据结构问题。

`std::vector`和`std::list`是C++标准库中的两种不同类型的容器，它们有一些重要的区别，主要涉及底层实现、内存分配和访问速度等方面。

1. **底层实现：**
   - `std::vector` 是基于动态数组实现的，它在内存中是连续存储的，支持快速的随机访问。
   - `std::list` 是基于双向链表实现的，每个元素在内存中是分散存储的，支持高效的插入和删除操作。

2. **内存分配：**
   - `std::vector` 的内存是连续分配的，这样可以充分利用缓存，对于顺序访问元素非常高效。
   - `std::list` 的内存是分散分配的，插入和删除操作不需要移动其他元素，因此在这些操作上更为高效。

3. **插入和删除操作：**
   - `std::vector` 在末尾进行插入和删除操作是高效的，但在中间或头部进行插入和删除可能需要移动其他元素，效率较低。
   - `std::list` 在任意位置进行插入和删除操作是高效的，因为它只需要调整相邻元素的指针。

4. **随机访问：**
   - `std::vector` 支持常量时间的随机访问，因为它在内存中是连续存储的。
   - `std::list` 不支持常量时间的随机访问，需要通过遍历链表来访问元素。

5. **迭代器的稳定性：**
   - `std::vector` 在插入或删除元素后，可能会导致迭代器失效。
   - `std::list` 在插入或删除元素后，仍然能够保持迭代器的有效性。

根据具体的需求，选择使用`std::vector`还是`std::list`。如果需要频繁的随机访问和在末尾进行插入和删除操作，`std::vector`可能更合适。如果需要在任意位置高效地进行插入和删除操作，或者迭代器稳定性对算法有重要影响，那么`std::list`可能更合适。

## C++为什么要有类型？

+ 考察目的
  + 考对静态类型语言的理解和权衡，可引申出类型安全，泛型，模板元编程，编译时计算，静态多态等一众问题。

C++是一种静态类型的编程语言，这意味着在编译时就需要明确指定变量的类型。类型在C++中是一个非常重要的概念，它提供了以下几个关键的优势：

1. **类型安全：** 类型系统可以帮助在编译时捕捉一些错误，防止在运行时发生类型不匹配的问题。这有助于减少由于类型错误引起的潜在程序漏洞和错误。

2. **性能优化：** 静态类型信息使得编译器可以进行更好的优化，生成更高效的机器代码。编译器能够在编译时知道变量的类型，从而进行更好的类型检查和优化。

3. **代码可读性：** 类型信息提供了对代码含义的额外描述，使得代码更加清晰易懂。通过类型信息，读者可以更容易地理解代码的意图，从而提高代码的可维护性。

4. **代码组织和模块化：** 类型有助于将代码组织成各种数据结构和抽象类型，从而支持更好的模块化和封装。这使得代码更易于维护和重用。

5. **静态分析和工具支持：** 静态类型语言可以受益于许多静态分析工具，如编译器和IDE。这些工具可以在编码的早期阶段检测潜在的错误，提供更好的开发体验。

6. **安全性：** 类型系统有助于防止一些类型相关的安全漏洞，如空指针引用、越界访问等。通过类型检查，可以避免一些常见的编程错误。

7. **代码可维护性：** 类型系统有助于更好地组织和管理代码，提高代码的可维护性。类型信息可以作为文档，帮助开发人员理解和维护代码。

尽管动态类型语言（如Python和JavaScript）在某些情况下更灵活，但静态类型语言的类型系统提供了一些关键的优势，特别是对于大型、复杂的项目。这种优势使得C++等静态类型语言在需要高性能、可维护和安全性的场景中得到广泛应用。

## 进程间常用的通讯方式

进程间通信（Inter-Process Communication，IPC）是指在操作系统中，不同进程之间进行数据交换和通信的机制。常见的进程间通信方式包括：

1. **管道（Pipe）**：
   - 匿名管道：在父进程中创建，用于与子进程进行通信。只能实现单向通信。
   - 命名管道：在文件系统中创建一个特殊类型的文件，多个进程可以通过打开该文件来进行通信。可以实现双向通信。

2. **消息队列（Message Queues）**：
   - 允许进程通过消息传递的方式进行通信，消息在队列中排队，接收方可以按照先后顺序处理消息。
   - 提供了比管道更灵活的通信方式，可以实现双向通信。

3. **信号量（Semaphores）**：
   - 用于进程间的同步和互斥控制。可以用于多个进程之间的协调，以及资源的共享和保护。

4. **共享内存（Shared Memory）**：
   - 允许多个进程共享同一块内存区域，这样可以实现高效的数据交换。
   - 由于共享内存操作的直接性和高效性，但也需要进行适当的同步和互斥控制，以避免数据一致性问题。

5. **套接字（Sockets）**：
   - 提供了网络编程中进程间通信的一种方式，不仅限于本地进程间通信，也可以在不同主机上的进程间进行通信。
   - 套接字通信提供了高度灵活性和可扩展性，常用于网络应用程序的开发。

6. **信号（Signals）**：
   - 用于向进程发送异步通知，例如某个事件的发生或者异常的发生。
   - 信号提供了一种轻量级的通信机制，用于处理特定的事件或者错误情况。

7. **文件锁（File Locks）**：
   - 通过对文件进行加锁来实现进程间的同步和互斥控制。
   - 常用于控制对共享文件的访问，以避免多个进程同时修改文件造成的数据损坏。

选择适当的进程间通信方式取决于应用程序的需求和性能要求，通常需要权衡通信的复杂度、效率、可靠性和安全性等因素。

## 如果同一台机器上，不同进程需要大量通信，选哪种方式

在同一台机器上，如果不同进程需要大量通信，可以选择以下几种方式：

1. **进程间通信（Inter-Process Communication, IPC）机制**：IPC是操作系统提供的用于不同进程之间通信的机制。常见的IPC方式包括管道（pipe）、信号（signal）、消息队列（message queue）、共享内存（shared memory）和套接字（socket）等。每种方式都有自己的优缺点，选择适合具体需求的IPC方式很重要。

2. **共享内存（Shared Memory）**：共享内存允许不同进程共享同一块内存区域，从而实现高效的数据交换。这种方式适用于需要频繁进行大量数据交换的场景。

3. **消息队列（Message Queue）**：消息队列允许进程之间通过发送和接收消息进行通信。它可以实现异步通信，提高系统的灵活性和可靠性。

4. **套接字（Socket）通信**：套接字是一种可用于不同主机间或同一主机上不同进程间通信的机制。它可以在网络环境下实现进程间通信，也可以在同一台机器上进行本地通信。

5. **Remote Procedure Call（远程过程调用，RPC）**：RPC允许一个进程调用另一个进程（通常在不同机器上）的函数或过程，就像调用本地函数一样。这种方式适用于分布式系统中需要跨网络进行通信的场景。

选择哪种方式取决于通信的需求、性能要求、安全性等因素。通常来说，共享内存和消息队列适用于在同一台机器上进行进程间通信的场景，而套接字通信和RPC适用于跨网络进行通信的场景。

## 服务器性能调优方式 详解

服务器性能调优是确保服务器能够在高负载情况下稳定运行并提供良好性能的关键任务之一。下面详细介绍几种常见的服务器性能调优方式：

1. **硬件升级**：
   - **CPU**：升级到性能更高、核心更多的处理器，提高服务器的计算能力。
   - **内存**：增加内存容量，减少内存交换和磁盘I/O，提高服务器的响应速度。
   - **存储**：使用固态硬盘（SSD）替换传统机械硬盘（HDD），提高存储读写速度。
   - **网络适配器**：升级到更高带宽的网络适配器，提高网络传输速度和吞吐量。

2. **操作系统调优**：
   - **内核参数优化**：调整内核参数以适应服务器的性能需求，如调整TCP缓冲区大小、最大文件描述符数等。
   - **文件系统优化**：选择合适的文件系统并进行相应的调优，以提高文件读写性能，如使用XFS或ext4文件系统。
   - **IO调度器**：选择适合服务器负载特征的IO调度器，如noop、deadline或者cfq。

3. **应用程序优化**：
   - **代码优化**：对应用程序进行性能分析，找出性能瓶颈并进行优化，如减少不必要的计算、减少内存占用等。
   - **并发处理**：使用多线程或多进程技术提高并发处理能力，如使用线程池或进程池。
   - **缓存优化**：利用缓存技术减少对数据库或文件系统的访问次数，提高数据读取速度，如使用Redis或Memcached。

4. **负载均衡和高可用性**：
   - **负载均衡器**：使用负载均衡器将请求分发到多台服务器上，提高服务器的整体性能和可用性。
   - **集群和复制**：通过集群和复制技术提高服务的可用性，如数据库主从复制、分布式缓存等。

5. **监控和调优周期**：
   - **监控系统**：使用监控系统实时监测服务器性能指标，及时发现问题并进行调优。
   - **定期优化**：建立定期的性能优化计划，对服务器进行定期的性能调优和优化，以保持服务器的高性能状态。

6. **安全性调优**：
   - **安全策略**：制定合适的安全策略，保护服务器免受恶意攻击和未经授权的访问。
   - **漏洞修补**：定期更新操作系统和应用程序，修补已知的安全漏洞，提高服务器的安全性。

综上所述，服务器性能调优是一个综合考虑硬件、操作系统、应用程序和安全性等多方面因素的过程，需要根据具体情况采取相应的优化措施。

## DDos 详解

DDoS（分布式拒绝服务攻击）是一种网络攻击，旨在通过向目标服务器发送大量请求，超出其处理能力范围，导致服务不可用或延迟。下面对DDoS进行详细解释：

### 工作原理：
1. **招募僵尸网络**：攻击者使用恶意软件感染大量设备，将它们组成一个庞大的僵尸网络（botnet）。
2. **发动攻击**：攻击者通过控制僵尸网络中的设备，向目标服务器发送大量请求。这些请求可能是HTTP请求、TCP连接请求、UDP数据包等。
3. **超出服务器负载**：目标服务器在短时间内接收到大量请求，超出其处理能力，导致服务不可用或延迟。
4. **伪装攻击源**：攻击者通常会伪装请求的源IP地址，使得难以追踪攻击源，增加攻击难度。

### 类型：
1. **Volumetric（容量型）**：攻击者发送大量数据包，消耗目标服务器的网络带宽和系统资源。
2. **Protocol（协议型）**：攻击者利用协议漏洞向目标服务器发送特定类型的请求，消耗服务器资源。
3. **Application Layer（应用层）**：攻击者模拟合法用户向应用层发送请求，耗尽服务器的应用处理能力。

### 防御措施：
1. **流量过滤和清洗**：使用DDoS防火墙或专业的DDoS清洗服务，过滤掉恶意流量，确保合法流量到达服务器。
2. **负载均衡**：通过负载均衡器将流量分发到多台服务器上，提高整体服务的稳定性和可用性。
3. **IP黑名单和白名单**：根据流量分析结果，及时更新IP黑名单，阻止恶意流量的访问。
4. **故障自动化和弹性设计**：建立自动化故障检测和恢复机制，使系统具备弹性，能够在遭受攻击后快速恢复正常运行。
5. **网络监控和攻击检测**：使用网络监控工具实时监测网络流量，及时发现异常流量并采取相应的防御措施。

### 法律和道德问题：
DDoS攻击是非法行为，违反了大多数国家的法律。攻击者可能面临起诉和刑事指控。此外，DDoS攻击可能导致严重的财务损失和声誉损害，影响攻击者的个人和组织的道德声誉。

## mysql的存储引擎 详解

MySQL支持多种存储引擎，每种引擎都有其特定的特性、优缺点和适用场景。下面详细解释几种常见的MySQL存储引擎：

1. **InnoDB**：
   - **特性**：支持事务（ACID兼容）、行级锁、外键约束等高级功能，适合于高并发、高可靠性的应用场景。
   - **优点**：提供良好的事务支持和数据完整性，适用于大型企业应用和在线事务处理（OLTP）系统。
   - **缺点**：相比于MyISAM，InnoDB的性能稍低，占用的存储空间较大。

2. **MyISAM**：
   - **特性**：不支持事务，采用表级锁，适合于读操作频繁、写操作较少的场景。
   - **优点**：性能较高，适用于数据仓库、日志系统等读密集型应用。
   - **缺点**：不支持事务和外键约束，容易出现数据损坏，不适合于需要数据完整性保证的应用场景。

3. **MEMORY**（或者称为HEAP）：
   - **特性**：将表数据存储在内存中，速度非常快，但数据在MySQL服务重启时会丢失。
   - **优点**：适用于临时表、缓存表等需要快速访问和处理的场景。
   - **缺点**：容量受限于服务器的可用内存大小，不适合于大规模数据存储。

4. **NDB Cluster**（也称为NDB）：
   - **特性**：提供分布式存储和高可用性，适用于需要线性扩展和高可靠性的分布式系统。
   - **优点**：支持水平扩展、容错性好、适用于大规模的数据存储和高并发的事务处理。
   - **缺点**：相比于单机存储引擎，配置和维护复杂，对网络和硬件要求较高。

5. **其他存储引擎**：除了上述常见的存储引擎外，MySQL还支持其他一些存储引擎，如CSV、ARCHIVE、BLACKHOLE等，它们各自适用于特定的场景和需求。

选择合适的存储引擎取决于应用的具体需求，包括数据读写比例、事务需求、数据完整性要求、性能要求等。通常来说，InnoDB是MySQL的默认存储引擎，适用于大多数应用场景，但在特定情况下，可以根据需求选择其他存储引擎。

## 内存泄漏定位 详解

内存泄漏是指程序在运行过程中动态分配的内存空间没有被正确释放，导致系统中的可用内存不断减少，最终耗尽系统内存资源。内存泄漏可能导致程序性能下降、系统稳定性降低甚至系统崩溃。以下是定位和解决内存泄漏问题的一般步骤：

### 1. 监控和识别内存泄漏：
- **使用内存监控工具**：使用工具监控程序的内存使用情况，识别内存泄漏的迹象，如持续增长的内存占用或内存波动异常等。
- **分析崩溃报告**：如果程序崩溃，分析崩溃报告中的内存相关信息，确定是否是因为内存泄漏导致的。

### 2. 定位内存泄漏：
- **代码审查**：仔细审查程序的代码，查找可能导致内存泄漏的地方，如未释放的动态分配内存、循环引用等。
- **内存分析工具**：使用内存分析工具，如Valgrind（针对C/C++）、MAT（Memory Analyzer Tool，针对Java）等，定位内存泄漏的具体位置和原因。

### 3. 解决内存泄漏：
- **释放未使用的内存**：确定未使用的内存并及时释放，避免不必要的内存占用。
- **修复代码缺陷**：修改代码，修复导致内存泄漏的问题，如添加缺失的内存释放操作、优化内存管理逻辑等。
- **避免循环引用**：在使用动态内存分配时，避免出现循环引用，确保可以正确释放对象的内存。

### 4. 进行测试和验证：
- **单元测试**：编写单元测试用例验证修复后的代码，确保修复内存泄漏的问题。
- **性能测试**：进行性能测试，验证修复内存泄漏后程序的性能和稳定性是否得到改善。

### 5. 持续监控和优化：
- **定期审查代码**：定期审查代码，避免新的内存泄漏问题的出现。
- **持续优化内存管理**：优化内存分配和释放逻辑，减少内存占用和泄漏的可能性。

综上所述，定位和解决内存泄漏需要通过监控、分析、定位、解决和验证等一系列步骤，确保程序能够有效地管理和利用内存资源，避免内存泄漏导致的性能和稳定性问题。

## linux 内存过高会怎么样

当Linux系统的内存使用过高时，可能会导致以下几种情况和问题：

1. **性能下降**：当系统内存使用过高时，可能会导致系统性能下降，因为操作系统需要频繁地进行内存页的交换，从而增加了CPU和硬盘的负载。

2. **内存压缩和交换**：当物理内存不足以满足系统的需求时，Linux系统会将部分内存页面压缩并存储在交换空间（硬盘）中，这会导致磁盘I/O操作增加，进而影响系统的响应速度。

3. **OOM（Out of Memory）异常**：如果系统内存耗尽，但又无法从交换空间中分配更多的内存时，Linux内核会触发OOM Killer机制，选择性地终止某些进程，以释放内存资源。这可能导致重要进程被异常终止，从而导致系统服务中断或崩溃。

4. **应用程序崩溃**：当系统内存使用过高时，可能会导致运行在系统上的应用程序因内存不足而崩溃或异常退出。

5. **系统不稳定**：内存使用过高可能会导致系统不稳定，出现死机、进程僵死等异常情况，影响系统的正常运行。

因此，为了确保系统的稳定性和性能，建议及时监控系统的内存使用情况，合理规划和管理系统内存，及时优化应用程序和系统配置，以避免内存使用过高导致的问题。

## C++ std::vector扩容机制和实现原理

C++标准库中的`std::vector`是一个动态数组，它可以根据需要自动扩容以容纳更多的元素。下面是`std::vector`的扩容机制和实现原理：

### 扩容机制：

1. **初始容量（Initial Capacity）**：
   - `std::vector`在创建时通常会分配一定的初始容量，以减少频繁的扩容操作。初始容量可以通过构造函数或`reserve()`函数指定。

2. **动态扩容（Dynamic Resizing）**：
   - 当向`std::vector`中添加元素时，如果当前容量不足以容纳新元素，则`std::vector`会动态地分配更大的内存空间，并将原有元素复制到新的内存区域中。
   - 扩容操作通常会使得`std::vector`的容量成倍增加（例如，翻倍或乘以某个增长因子），以保证添加元素的时间复杂度为均摊常数时间。

### 实现原理：

1. **连续内存存储**：
   - `std::vector`中的元素通常是连续存储的，即在内存中以连续的地址存储。这使得`std::vector`支持快速的随机访问和迭代。

2. **分配器（Allocator）**：
   - `std::vector`通过分配器（allocator）来管理内存的分配和释放。分配器是一个模板参数，默认使用`std::allocator`。
   - 分配器负责分配和释放内存，并在需要时调用元素的构造函数和析构函数。

3. **扩容策略**：
   - 当`std::vector`需要扩容时，通常会分配比当前容量更大的内存空间，然后将原有元素复制到新的内存区域中，并释放原有内存空间。
   - 扩容时通常会根据增长因子（例如2倍增长）计算新的容量，以减少扩容的次数和复制的次数，从而提高性能。

4. **异常安全性**：
   - `std::vector`保证在扩容过程中的异常安全性。如果在元素复制过程中发生异常，`std::vector`会保持不变，不会造成资源泄漏。

5. **移动语义（Move Semantics）**：
   - C++11引入了移动语义，可以在元素复制过程中使用移动构造函数或移动赋值运算符，提高性能。当元素支持移动语义时，`std::vector`会优先使用移动操作而不是复制操作。

总的来说，`std::vector`通过动态扩容机制和连续内存存储实现了高效的元素添加和访问操作。在添加元素时，如果当前容量不足，`std::vector`会动态地分配更大的内存空间，并将原有元素复制到新的内存区域中，以保证添加元素的时间复杂度为均摊常数时间。

## std::vector扩容 怎么查看扩容了多少

在C++标准库中，`std::vector`没有提供直接查看扩容量的方法。由于`std::vector`的实现细节被封装在库中，并且它的扩容行为是自动进行的，因此用户无法直接获取扩容量的信息。

但是，你可以通过以下方式间接了解`std::vector`的扩容行为：

1. **预留空间（Reserve）**：`std::vector`提供了`reserve()`函数，可以预留一定数量的元素空间，而不会实际添加元素。如果你在添加大量元素之前先调用`reserve()`函数，可以减少扩容的次数，间接降低了扩容的影响。

2. **容量查询（Capacity）**：`std::vector`提供了`capacity()`函数，用于查询当前`std::vector`的容量（即已分配的内存空间大小）。虽然这并不直接告诉你扩容了多少，但可以通过跟踪容量的变化，大致了解扩容的频率和幅度。

3. **测试与分析**：通过编写测试代码，并观察`std::vector`在添加元素时容量的变化，可以推断出扩容的情况。你可以在不同的情况下测试`std::vector`的扩容行为，例如在添加元素前后分别查询容量，比较它们的差异。

虽然无法直接查看`std::vector`的扩容量，但通过上述方法，你可以了解到`std::vector`的扩容行为，并根据实际需求进行优化。

## C++ std::vector是线程安全的吗

在 C++ 标准库中，`std::vector` 并不是线程安全的。也就是说，如果多个线程同时访问和修改同一个 `std::vector` 实例，而其中至少有一个线程对其进行了修改操作（比如添加、删除元素等），就会导致未定义行为（Undefined Behavior）。

以下是一些可能导致问题的情况：

1. **并发访问和修改**：多个线程同时对同一个 `std::vector` 进行读写操作，没有采取适当的同步措施。

2. **数据竞争**：当一个线程在添加或删除元素时，另一个线程可能同时进行其他操作，导致数据竞争和未定义行为。

为了确保线程安全性，需要采取适当的同步措施，比如使用互斥锁（`std::mutex`）、读写锁（`std::shared_mutex`）、信号量等机制来保护 `std::vector` 的并发访问。另外，C++17 中引入了并行算法（parallel algorithms），其中的一些算法可以安全地并发地处理容器，包括 `std::vector`。

在多线程环境中使用 `std::vector` 时，需要特别注意以下几点：

- **避免共享**：尽量避免多个线程共享同一个 `std::vector` 实例，如果需要共享，确保采取了适当的同步措施。

- **使用线程安全容器**：考虑使用线程安全的容器，比如 `std::shared_mutex` 或第三方线程安全容器库。

- **注意迭代器失效**：在多线程环境中进行添加、删除操作时，要注意迭代器的失效问题，避免产生悬空指针。

总之，在多线程环境中使用 `std::vector` 时，一定要确保采取了适当的线程同步措施，以避免数据竞争和未定义行为。

## std::vector多线程访问会崩溃吗？

在多线程环境中访问 `std::vector` 可能会导致程序崩溃，但不是一定会发生。具体是否会崩溃取决于多个因素，包括线程访问顺序、访问的方式、操作系统和编译器的实现等。

以下是一些可能导致程序崩溃的情况：

1. **数据竞争**：如果多个线程同时对同一个 `std::vector` 进行读写操作，并且没有采取适当的同步措施（比如互斥锁），就会导致数据竞争，进而导致未定义行为，包括程序崩溃。

2. **迭代器失效**：在多线程环境中，如果一个线程在对 `std::vector` 进行添加或删除操作时，另一个线程同时进行迭代器操作（比如遍历、删除元素等），就有可能导致迭代器失效，进而导致程序崩溃。

3. **内存分配问题**：如果多个线程同时对 `std::vector` 进行扩容操作，并且没有采取适当的同步措施，可能会导致内存分配问题，进而导致程序崩溃。

4. **操作系统和编译器实现**：不同的操作系统和编译器实现对多线程访问 `std::vector` 的行为可能有所不同，一些实现可能会检测到并发访问，并在必要时引发异常或终止程序。

综上所述，虽然在多线程环境中访问 `std::vector` 可能会导致程序崩溃，但并不是一定会发生。为了确保程序的稳定性和可靠性，必须采取适当的线程同步措施，以避免数据竞争和未定义行为。

## std::vector扩容的时候多线程访问会崩溃吗

在多线程环境中，如果多个线程同时访问一个 `std::vector` 实例，并且其中至少有一个线程在进行扩容操作（比如调用 `push_back()` 添加元素导致容量不足），那么确实存在一定的风险，可能会导致程序崩溃或产生未定义行为。

以下是可能导致问题的情况：

1. **数据竞争**：如果一个线程正在扩容 `std::vector`，而另一个线程同时在对 `std::vector` 进行其他操作（比如访问元素、修改元素、删除元素等），并且没有采取适当的同步措施（比如使用互斥锁），就会导致数据竞争，从而产生未定义行为。

2. **内存分配问题**：`std::vector` 在扩容时需要重新分配内存空间，并且将原来的元素拷贝到新的内存空间中。如果多个线程同时进行扩容操作，可能会导致内存分配冲突或拷贝过程中的数据不一致，进而导致程序崩溃。

为了避免这种情况，可以采取以下几种方式：

- **线程同步**：在多线程环境中使用 `std::vector` 时，确保对其进行操作的线程之间采取适当的同步措施，比如使用互斥锁来保护对 `std::vector` 的访问。

- **单线程访问**：如果可能的话，尽量避免多个线程同时访问同一个 `std::vector` 实例，可以通过线程间的消息传递或者将 `std::vector` 复制到每个线程中来避免并发访问。

总之，在多线程环境中使用 `std::vector` 时，一定要格外小心，并确保采取了适当的线程同步措施，以避免数据竞争和未定义行为。

## std::vector扩容的方法

在 C++ 标准库中，`std::vector` 的扩容是由容器自动管理的，而不是由用户手动控制的。当 `std::vector` 中的元素数量达到当前容量时，如果继续添加新元素，则会触发扩容操作，以确保足够的内存空间来容纳新元素。

下面是 `std::vector` 扩容的一般过程：

1. **检查容量**：在添加新元素之前，`std::vector` 会先检查当前容器的大小和容量。如果当前元素数量已经达到了容器的容量上限，则需要进行扩容。

2. **分配新空间**：一旦需要扩容，`std::vector` 会分配一块新的内存空间，通常是原来容量的两倍大小（具体实现可能有所不同）。

3. **移动元素**：然后，`std::vector` 会将原来的元素从旧的内存空间移动到新的内存空间中。这个过程可能会涉及到大量的内存拷贝或移动操作。

4. **释放旧空间**：最后，`std::vector` 会释放原来的内存空间，以避免内存泄漏。

在这个过程中，用户不需要手动介入或控制扩容操作，一切都由 `std::vector` 自动完成。这种自动扩容的机制可以简化代码，减少了用户的工作量，并且保证了 `std::vector` 的动态增长能力。

虽然用户无法手动控制 `std::vector` 的扩容过程，但可以通过 `reserve()` 函数来预留一定大小的内存空间，以减少扩容操作的频率，从而提高性能。`reserve()` 函数可以在添加大量元素之前预留足够的内存空间，避免多次扩容操作。

## std::vector缩容的方法

在 C++ 标准库中，`std::vector` 并没有提供直接的缩容方法。相比之下，`std::vector` 的扩容是由容器自动管理的，而不需要用户手动介入。当元素数量减少时，`std::vector` 并不会立即释放多余的内存，而是保留这些空闲内存以备将来使用，以减少频繁的内存分配和释放操作，从而提高性能。

但是，如果用户确实希望手动释放 `std::vector` 中多余的内存，可以考虑使用以下方法之一：

1. **使用 `shrink_to_fit()` 函数**：

`shrink_to_fit()` 函数可以请求将 `std::vector` 的容量减小到与其当前大小相匹配的值。但是，这只是一个请求，具体是否会真正地释放多余的内存，取决于具体的实现。

```cpp
std::vector<int> vec;
// 添加元素到 vector 中
vec.push_back(1);
vec.push_back(2);
vec.push_back(3);

// 缩小容量
vec.shrink_to_fit();
```

2. **重新分配一个新的 `std::vector`**：

如果希望完全释放 `std::vector` 中的多余内存，可以创建一个新的 `std::vector`，并使用移动语义将元素从原来的 `std::vector` 移动到新的 `std::vector` 中。

```cpp
std::vector<int> oldVec;
// 添加元素到原 vector 中
oldVec.push_back(1);
oldVec.push_back(2);
oldVec.push_back(3);

// 创建一个新的 vector，并使用移动语义将元素从原 vector 移动到新 vector 中
std::vector<int> newVec(std::move(oldVec));
```

需要注意的是，缩容操作可能会导致内存重新分配和元素的拷贝或移动，因此应该谨慎使用。通常情况下，由于 `std::vector` 的动态增长能力和性能表现，用户无需过多关注内存的释放和缩容操作。

## C++ std::map底层原理 详解

`std::map` 是 C++ 标准库提供的关联容器，它提供了基于键值对的存储和快速的查找功能。`std::map` 的底层通常使用红黑树（Red-Black Tree）实现。下面是关于 `std::map` 的底层原理的详细解释：

### 红黑树（Red-Black Tree）：

1. **定义**：
   - 红黑树是一种自平衡的二叉搜索树，它在每个节点上都增加了一个额外的存储位来表示节点的颜色（红色或黑色）。
   - 红黑树满足以下性质：
     1. 每个节点要么是红色，要么是黑色。
     2. 根节点是黑色的。
     3. 每个叶子节点（NIL节点，空节点）是黑色的。
     4. 如果一个节点是红色的，则其子节点必须是黑色的。
     5. 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。

2. **操作**：
   - 插入、删除和查找操作在红黑树上执行，以保持红黑树的平衡性质。

### std::map 的底层实现：

1. **数据结构**：
   - `std::map` 的底层通常使用红黑树实现。每个节点包含一个键值对（key-value pair），键值对根据键的大小顺序排列。
   - 由于红黑树是一种自平衡二叉搜索树，因此 `std::map` 中的元素是有序存储的。

2. **查找操作**：
   - `std::map` 的查找操作具有较好的时间复杂度，通常为 O(log n)，其中 n 为 `std::map` 中元素的数量。
   - 查找操作通过红黑树的特性进行，在每次比较后，根据比较结果向左或向右移动，直到找到目标元素或到达叶子节点。

3. **插入和删除操作**：
   - `std::map` 的插入和删除操作会触发红黑树的平衡调整，以保持红黑树的平衡性质。
   - 插入操作会根据插入元素的键值，找到合适的位置并插入，然后进行必要的平衡调整。
   - 删除操作会删除目标元素，并进行必要的平衡调整。

4. **迭代器**：
   - `std::map` 的迭代器提供了有序访问元素的功能，可以按照键值的顺序进行遍历。

### 总结：

`std::map` 底层通常使用红黑树实现，通过红黑树的自平衡特性，实现了快速的插入、删除和查找操作，并且提供了有序存储和遍历的功能。红黑树的平衡性保证了 `std::map` 的性能稳定性，在大多数情况下具有较好的性能表现。

## std::map是线程安全的吗？

不，`std::map` 是 C++ STL 中的关联容器，它并不是线程安全的。

在 C++11 之前的标准中，C++ STL 的容器类（包括 `std::map`）都不提供多线程安全的保证。如果在多个线程中同时对同一个 `std::map` 进行读写操作，会导致数据竞争和未定义行为，可能导致程序崩溃或产生不确定的结果。

为了在多线程环境中安全地使用 `std::map`，可以采用以下几种方法之一：
1. **互斥量（Mutex）：** 使用互斥量来保护 `std::map`，在对其进行读写操作时加锁，保证同一时刻只有一个线程可以对其进行操作。
2. **使用线程安全的容器：** 一些 C++ 标准库的实现提供了线程安全版本的容器，如 `std::map` 的线程安全版本 `std::mutex`。使用这些容器可以简化多线程编程，并且避免手动管理互斥量带来的复杂性。
3. **使用锁粒度更细的并发数据结构：** 一些并发数据结构（如 `std::shared_mutex`、`std::atomic`、`std::atomic_shared_ptr` 等）可以在细粒度上实现线程安全，从而提高并发性。

需要注意的是，对于某些特定的应用场景，可能需要根据实际情况选择合适的线程安全策略。

## 能够使std::map变为线程安全的吗？

是的，可以通过使用互斥量（mutex）或使用并发容器等方式使 `std::map` 变为线程安全的。以下是两种常见的方法：

1. **使用互斥量（Mutex）：** 在对 `std::map` 进行读写操作时，使用互斥量进行加锁，以确保同一时刻只有一个线程对 `std::map` 进行操作。可以使用 `std::mutex` 或 `std::shared_mutex` 来实现互斥量的锁定和解锁。

```cpp
#include <map>
#include <mutex>

std::map<int, int> myMap;
std::mutex mtx;

void insertToMap(int key, int value) {
    std::lock_guard<std::mutex> lock(mtx); // 加锁
    myMap[key] = value;
} // 自动解锁

int getFromMap(int key) {
    std::lock_guard<std::mutex> lock(mtx); // 加锁
    return myMap[key];
} // 自动解锁
```

2. **使用线程安全的容器：** 一些 C++ 标准库的实现提供了线程安全版本的容器，如 `std::map` 的线程安全版本 `std::mutex`。使用这些容器可以简化多线程编程，并且避免手动管理互斥量带来的复杂性。

```cpp
#include <map>
#include <shared_mutex>

std::map<int, int> myMap;
std::shared_mutex mtx;

void insertToMap(int key, int value) {
    std::lock_guard<std::shared_mutex> lock(mtx); // 加锁
    myMap[key] = value;
} // 自动解锁

int getFromMap(int key) {
    std::lock_guard<std::shared_mutex> lock(mtx); // 加锁
    return myMap[key];
} // 自动解锁
```

在以上两种方法中，通过互斥量或线程安全容器的方式，可以确保在多线程环境中对 `std::map` 的安全访问，避免了数据竞争和未定义行为的发生。

## 如何实现无锁std::map

实现无锁的 `std::map` 是一个相当复杂的任务，需要考虑到并发访问和数据一致性等方面的问题。通常情况下，为了实现无锁的容器，需要使用一些基于并发编程原理的数据结构，比如并发哈希表、跳跃表等。以下是一种可能的无锁 `std::map` 的简单实现：

```cpp
#include <atomic>
#include <memory>
#include <utility>

template <typename Key, typename Value>
class LockFreeMap {
private:
    struct Node {
        Key key;
        Value value;
        std::atomic<Node*> next;
        Node(const Key& k, const Value& v) : key(k), value(v), next(nullptr) {}
    };

    std::atomic<Node*> head;

public:
    LockFreeMap() : head(nullptr) {}

    ~LockFreeMap() {
        Node* current = head.load();
        while (current) {
            Node* next = current->next.load();
            delete current;
            current = next;
        }
    }

    void insert(const Key& key, const Value& value) {
        Node* newNode = new Node(key, value);
        Node* current = head.load();
        Node* previous = nullptr;

        while (true) {
            while (current && current->key < key) {
                previous = current;
                current = current->next.load();
            }
            if (previous && previous->next.load() != current) {
                continue;
            }
            newNode->next.store(current);
            if (!previous->next.compare_exchange_weak(current, newNode)) {
                continue;
            }
            break;
        }
    }

    bool search(const Key& key, Value& value) {
        Node* current = head.load();
        while (current && current->key < key) {
            current = current->next.load();
        }
        if (current && current->key == key) {
            value = current->value;
            return true;
        }
        return false;
    }

    // 可选的删除函数
    // void remove(const Key& key) {}
};
```

这是一个基于链表的简单无锁 `std::map` 实现，它使用了原子操作来保证并发访问的正确性。在实际应用中，要实现一个高效的无锁 `std::map` 需要考虑更多的细节，如内存管理、并发冲突解决策略、性能优化等。因此，对于实际的生产环境，建议使用已经经过充分测试和优化的现有并发容器库，而不是自己编写无锁数据结构。

## hashmap 详解

哈希表（Hash Map）是一种常见的数据结构，它基于哈希函数实现了键值对的存储和快速的查找操作。下面是哈希表的详细解释：

### 哈希表的结构和原理：

1. **数据结构**：
   - 哈希表由一个数组（或称为桶、槽）和一个哈希函数组成。数组的每个元素称为一个桶，每个桶可以存储一个或多个键值对。
   - 哈希函数将键映射到数组索引，将键值对存储在相应的桶中。

2. **哈希函数**：
   - 哈希函数接受一个键作为输入，并生成一个固定大小的哈希码（哈希值）。哈希码可以将键映射到数组索引。
   - 好的哈希函数应该具有以下特性：
     - 一致性：对于相同的键，哈希函数应始终生成相同的哈希码。
     - 均匀性：哈希函数应将键均匀地映射到数组索引，以减少冲突（多个键映射到同一个索引）的发生。

3. **解决冲突**：
   - 由于哈希函数的输出空间通常小于键的集合，可能会发生冲突。冲突是指多个键映射到同一个数组索引的情况。
   - 哈希表通常使用开放地址法或链地址法来解决冲突：
     - 开放地址法：发生冲突时，通过探测序列在哈希表中查找下一个可用的位置。
     - 链地址法：在数组每个位置上存储一个链表（或其他数据结构），将冲突的键值对存储在同一个位置的链表中。

### 哈希表的优点和缺点：

- **优点**：
  - 快速的查找操作：通过哈希函数直接定位到存储位置，平均时间复杂度为 O(1)。
  - 灵活的存储空间：根据需求动态分配数组大小，节省内存空间。
  - 适用于大规模数据：在数据量大的情况下，哈希表通常比线性数据结构更高效。

- **缺点**：
  - 冲突处理：冲突可能会影响性能，需要选择合适的解决冲突方法。
  - 内存消耗：需要额外的内存空间来存储哈希表数组，且存在一定的内存浪费。
  - 哈希函数设计：选择合适的哈希函数对性能影响较大，不同的数据集可能需要不同的哈希函数。

### C++ 中的哈希表：

在 C++ 标准库中，`std::unordered_map` 提供了哈希表的实现，它基于哈希函数和链地址法解决冲突。使用 `std::unordered_map` 可以实现键值对的快速存储和查找，具有和哈希表相似的特性。

## 读写锁与互斥锁的区别

读写锁（RW锁）和互斥锁（Mutex锁）都是用于多线程编程中实现线程同步的机制，但它们在实现方式和应用场景上有所不同。

### 1. 读写锁（RW锁）：

- **适用场景**：适用于读操作频繁、写操作较少的场景，例如读多写少的共享资源。
- **并发性**：允许多个线程同时获取读锁，但只允许一个线程获取写锁。
- **特点**：读锁之间不互斥，可以并发读取共享资源；写锁与读锁和写锁都互斥，保证在写操作时不会有其他读写操作。
- **性能**：在读操作远远多于写操作时，性能优于互斥锁，因为允许并发读取。

### 2. 互斥锁（Mutex锁）：

- **适用场景**：适用于对共享资源进行临界区保护，即任何时刻只能有一个线程访问共享资源的场景。
- **并发性**：一次只允许一个线程持有锁，其他线程需要等待锁的释放才能继续执行。
- **特点**：线程之间互斥，保证临界区的互斥访问，防止竞争条件和数据不一致性问题。
- **性能**：在并发度较低、临界区保护较小的情况下性能较好，但在读操作较多时可能会成为性能瓶颈。

### 区别总结：

- **并发性**：读写锁允许多个线程同时获取读锁，但只允许一个线程获取写锁；互斥锁一次只允许一个线程持有锁。
- **适用场景**：读写锁适用于读操作频繁、写操作较少的场景；互斥锁适用于任何时刻只能有一个线程访问临界区的场景。
- **性能**：在读操作频繁、写操作较少的情况下，读写锁的性能优于互斥锁；在并发度低、临界区保护较小的情况下，互斥锁性能较好。

总的来说，读写锁适用于读多写少的场景，提高了并发读取共享资源的能力；而互斥锁适用于临界区保护，保证了临界区的互斥访问，防止了竞争条件和数据不一致性问题。在选择锁的时候需要根据具体的应用场景和性能需求来进行选择。

## libevent详解

Libevent 是一个开源的事件驱动库，用于编写高性能、可扩展性的网络服务器和客户端程序。它提供了基于事件的异步编程模型，可以轻松地处理并发连接和事件驱动的网络编程。下面是对 Libevent 的详细解释：

### 1. 主要特点：

- **事件驱动**：Libevent 使用事件驱动模型，基于事件的回调机制来处理网络事件，支持异步、非阻塞的网络编程。
- **跨平台**：Libevent 提供了跨平台的支持，可以在多个操作系统上运行，包括 Unix/Linux、Windows 等。
- **高性能**：Libevent 使用高效的事件分发机制和 I/O 多路复用技术，具有优秀的性能表现，可以处理大量并发连接。
- **可扩展性**：Libevent 提供了灵活的事件管理和线程池机制，可以轻松地扩展应用程序的性能和吞吐量。
- **丰富的功能**：除了基本的事件驱动功能外，Libevent 还提供了定时器、信号处理、缓冲管理等丰富的功能，方便开发人员构建复杂的网络应用。

### 2. 主要组件：

- **事件**：事件是 Libevent 的核心组件，用于表示各种 I/O 事件、定时器事件和信号事件等。
- **事件处理器**：事件处理器负责监听和处理事件，包括注册事件、删除事件、调度事件等操作。
- **事件分发器**：事件分发器负责将事件分发给对应的事件处理器，并调用相应的回调函数进行处理。
- **缓冲管理**：Libevent 提供了缓冲管理功能，用于管理事件的输入和输出缓冲区，提高网络传输的效率。

### 3. 使用方法：

- **初始化**：使用 `event_base_new()` 函数初始化事件驱动器。
- **创建事件**：使用 `event_new()` 函数创建事件对象，并设置相应的事件类型和回调函数。
- **注册事件**：使用 `event_add()` 函数将事件对象注册到事件驱动器中，开始监听事件。
- **事件循环**：使用 `event_base_loop()` 函数进入事件循环，处理事件的到来并调用相应的回调函数。
- **释放资源**：在程序结束时使用 `event_base_free()` 函数释放事件驱动器和事件对象。

### 4. 应用场景：

- **网络服务器**：Libevent 可以用于编写高性能的网络服务器，支持大量并发连接和高吞吐量的数据传输。
- **网络客户端**：Libevent 可以用于编写异步的网络客户端程序，实现快速响应和高效的数据传输。
- **代理服务器**：Libevent 可以用于实现代理服务器，支持 TCP、UDP 和 HTTP 等协议的代理转发。
- **网络中间件**：Libevent 可以用于实现各种网络中间件，如负载均衡、反向代理、消息队列等。

总的来说，Libevent 是一个功能强大、性能优异的事件驱动库，适用于各种网络编程场景。它的简洁易用的接口和高效的事件处理机制使得开发人员可以轻松构建高性能、可扩展的网络应用程序。

## 单线程和多线程的优势和劣势

单线程和多线程是两种不同的并发编程模型，它们各有优势和劣势，适用于不同的应用场景。

### 单线程的优势和劣势：

**优势：**

1. **简单易用**：单线程编程模型相对简单，不需要考虑线程同步、锁机制等复杂的并发控制问题。
2. **资源消耗低**：单线程只需要一个线程和一个执行栈，资源消耗较少，适用于资源受限的环境。
3. **可靠性高**：由于不存在多线程之间的竞态条件和锁问题，单线程程序更加稳定可靠，易于调试和维护。

**劣势：**

1. **性能受限**：单线程模型无法充分利用多核处理器的并行性能，无法同时处理多个任务，性能较低。
2. **响应速度慢**：单线程模型无法同时处理多个任务，可能导致某些任务等待时间较长，响应速度慢。
3. **阻塞问题**：单线程模型中如果遇到阻塞操作（如IO操作），会导致整个程序阻塞，影响其他任务的执行。

### 多线程的优势和劣势：

**优势：**

1. **并行处理**：多线程模型可以同时处理多个任务，充分利用多核处理器的并行性能，提高了程序的整体性能。
2. **提高响应速度**：多线程模型可以并发处理多个任务，提高了系统的响应速度和吞吐量。
3. **支持阻塞IO**：多线程模型可以使用阻塞IO，遇到阻塞操作时不会影响其他线程的执行。

**劣势：**

1. **复杂性增加**：多线程编程涉及到线程同步、锁机制等复杂的并发控制问题，增加了程序的复杂性和难度。
2. **资源消耗增加**：多线程模型需要创建和管理多个线程，会消耗更多的系统资源，如内存、CPU等。
3. **竞态条件和锁问题**：多线程模型容易出现竞态条件和锁问题，需要谨慎设计和管理锁机制，否则会导致死锁、饥饿等问题。

### 应用场景：

- **单线程**适用于简单的任务、资源受限的环境、IO密集型应用等。
- **多线程**适用于多核处理器、需要提高性能和响应速度的应用、CPU密集型应用等。

综上所述，单线程和多线程各有优劣，需要根据具体的应用场景和性能需求来选择适合的并发编程模型。

## C++ std::vector 和 std::queue的区别

`std::vector` 和 `std::queue` 都是 C++ 标准库中提供的容器，但它们在功能和用途上有一些不同之处。

### std::vector：

- **容器类型**：`std::vector` 是一个动态数组容器，可以动态增长和缩小，支持随机访问和元素的插入、删除操作。
- **特点**：`std::vector` 的元素在内存中是连续存储的，支持随机访问和常数时间的尾部插入和删除操作，但在中间插入和删除操作的时间复杂度较高。
- **用途**：适用于需要随机访问和动态增长的情况，如数组、动态数组、缓冲区等。

### std::queue：

- **容器类型**：`std::queue` 是一个队列容器，实现了先进先出（FIFO）的数据结构，只能在队尾插入元素，在队头删除元素。
- **特点**：`std::queue` 提供了入队（push）、出队（pop）、查看队头元素（front）、查看队尾元素（back）等操作，但不支持随机访问和中间插入删除操作。
- **用途**：适用于需要按照先进先出顺序处理元素的情况，如任务队列、消息队列等。

### 区别总结：

- **功能**：`std::vector` 提供了动态数组的功能，支持随机访问和动态增长；`std::queue` 实现了队列的功能，支持先进先出的操作。
- **操作**：`std::vector` 支持随机访问、插入、删除等操作；`std::queue` 只支持入队、出队等队列操作。
- **性能**：`std::vector` 的随机访问和尾部插入删除操作的性能较好；`std::queue` 的入队和出队操作的性能较好。

综上所述，`std::vector` 和 `std::queue` 在功能和用途上有所不同，开发者需要根据具体的需求来选择合适的容器类型。如果需要随机访问和动态增长，可以选择 `std::vector`；如果需要先进先出的队列操作，可以选择 `std::queue`。

## C++ std::vector::push_back()是怎么操作的 详解

`std::vector::push_back()` 是 C++ 标准库中 `std::vector` 容器提供的一个成员函数，用于在 vector 的末尾添加一个元素。这个操作的实现方式涉及到 vector 的内部机制，下面是对 `std::vector::push_back()` 操作的详细解释：

### 1. 实现原理：

- **空间分配**：当调用 `push_back()` 添加元素时，如果 vector 的内部存储空间不足以容纳新的元素，会自动进行空间的重新分配。
- **内存分配**：通常情况下，vector 会分配比当前容量大一定倍数的内存空间（如两倍），然后将原来的元素拷贝到新的内存空间中。
- **添加元素**：在空间重新分配之后，新的元素会被添加到 vector 的末尾，更新 vector 的大小和容量信息。
- **复杂度**：通常情况下，`push_back()` 操作的时间复杂度为 O(1)，但当 vector 需要重新分配空间时，时间复杂度会变为 O(N)，其中 N 是 vector 中元素的数量。

### 2. 代码示例：

下面是一个简单的代码示例，演示了如何使用 `push_back()` 添加元素到 vector 中：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec;
    
    // 添加元素到 vector 中
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    // 输出 vector 中的元素
    for (int i : vec) {
        std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 3. 注意事项：

- **空间重新分配**：频繁调用 `push_back()` 可能会触发多次空间重新分配，影响性能。为了避免这种情况，可以通过 `reserve()` 函数预留一定大小的空间，减少空间重新分配的次数。
- **异常安全性**：`push_back()` 操作在添加元素时可能会抛出异常（如内存分配失败），因此在使用时需要注意异常安全性。

总的来说，`std::vector::push_back()` 是向 `std::vector` 容器中添加元素的常用操作，它通过动态分配内存空间来实现元素的添加，并且具有较好的性能特性。

## C++ std::vector::push_back()和std::vector::emplace_back()的区别

`std::vector::push_back()` 和 `std::vector::emplace_back()` 都是 `std::vector` 容器提供的成员函数，用于在 vector 的末尾添加一个元素。它们的主要区别在于元素的构造方式和参数传递方式。

### std::vector::push_back()：

- **作用**：`push_back()` 用于将一个已存在的元素添加到 vector 的末尾。
- **参数**：接受一个元素类型的参数，通常是元素的拷贝或移动。
- **构造方式**：会调用元素类型的拷贝构造函数或移动构造函数来创建新的元素。
- **适用情况**：适用于已存在的元素，或需要从已有的对象创建新的元素。

### std::vector::emplace_back()：

- **作用**：`emplace_back()` 用于在 vector 的末尾直接构造一个新的元素。
- **参数**：接受与元素类型的构造函数相匹配的参数，直接传递给元素类型的构造函数。
- **构造方式**：直接调用元素类型的构造函数来创建新的元素，避免了拷贝或移动的开销。
- **适用情况**：适用于直接构造新的元素，或需要通过构造函数参数来初始化元素。

### 区别总结：

- **构造方式**：`push_back()` 使用拷贝构造函数或移动构造函数来创建新的元素；`emplace_back()` 直接调用构造函数来构造新的元素。
- **参数传递**：`push_back()` 接受元素类型的参数，通常是拷贝或移动的形式；`emplace_back()` 接受构造函数的参数，直接传递给元素类型的构造函数。
- **性能**：由于避免了拷贝或移动的开销，`emplace_back()` 的性能可能会比 `push_back()` 更好。

### 示例代码：

```cpp
#include <iostream>
#include <vector>

struct Foo {
    int value;
    Foo(int v) : value(v) {}
};

int main() {
    std::vector<Foo> vec;

    // 使用 push_back() 添加元素
    Foo foo1(1);
    vec.push_back(foo1);

    // 使用 emplace_back() 添加元素
    vec.emplace_back(2);

    // 输出 vector 中的元素
    for (const Foo& foo : vec) {
        std::cout << foo.value << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在这个示例中，`push_back()` 使用已存在的对象 `foo1` 添加元素，而 `emplace_back()` 直接通过构造函数参数来构造新的元素。

## 面向对象编程 多态详解

面向对象编程（Object-Oriented Programming，OOP）中的多态（Polymorphism）是指同一个类的不同对象对同一个消息会做出不同的响应。具体来说，多态有两种形式：编译时多态（静态多态）和运行时多态（动态多态）。

### 1. 编译时多态（静态多态）：

编译时多态是通过函数的重载和模板实现的，也称为静态多态。在编译时多态中，编译器根据函数参数的类型、个数和顺序来选择调用合适的函数或模板实例。

#### 示例：

```cpp
#include <iostream>

void print(int x) {
    std::cout << "Integer: " << x << std::endl;
}

void print(double x) {
    std::cout << "Double: " << x << std::endl;
}

int main() {
    print(5);        // 调用 print(int)
    print(3.14);     // 调用 print(double)
    return 0;
}
```

### 2. 运行时多态（动态多态）：

运行时多态是通过继承和虚函数实现的，也称为动态多态。在运行时多态中，当基类指针或引用指向派生类对象时，通过虚函数表（vtable）实现动态绑定，即根据对象的实际类型来调用对应的函数。

#### 示例：

```cpp
#include <iostream>

class Animal {
public:
    virtual void makeSound() const {
        std::cout << "Animal makes a sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() const override {
        std::cout << "Dog barks" << std::endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() const override {
        std::cout << "Cat meows" << std::endl;
    }
};

int main() {
    Animal* animalPtr;

    Dog dog;
    Cat cat;

    animalPtr = &dog;
    animalPtr->makeSound();   // 输出: Dog barks

    animalPtr = &cat;
    animalPtr->makeSound();   // 输出: Cat meows

    return 0;
}
```

### 3. 多态的优点：

- **可扩展性**：通过继承和虚函数实现的多态使得程序更容易扩展和维护，可以在不修改现有代码的情况下添加新的派生类和功能。

- **灵活性**：多态允许基类指针或引用指向派生类对象，使得同一段代码能够处理不同类型的对象，从而提高了代码的灵活性和复用性。

- **简化代码**：多态可以使代码更简洁和清晰，通过统一的接口和行为来处理不同类型的对象，减少了条件语句的使用。

总的来说，多态是面向对象编程中的一个重要概念，通过将不同类型的对象统一对待，实现了代码的灵活性、可扩展性和简洁性。

## C++ 静态多态的细节和过程 详解

C++ 中的静态多态是通过函数重载和模板实现的。在编译时多态中，编译器根据函数参数的类型、个数和顺序来选择调用合适的函数或模板实例。

### 1. 函数重载：

函数重载是指在同一个作用域中定义多个函数，这些函数具有相同的名称但是参数列表不同。在调用函数时，编译器会根据实参的类型、个数和顺序来选择调用合适的函数。

#### 示例：

```cpp
#include <iostream>

void print(int x) {
    std::cout << "Integer: " << x << std::endl;
}

void print(double x) {
    std::cout << "Double: " << x << std::endl;
}

int main() {
    print(5);        // 调用 print(int)
    print(3.14);     // 调用 print(double)
    return 0;
}
```

在上面的示例中，根据参数的类型选择调用合适的 `print` 函数，实现了编译时多态。

### 2. 函数模板：

函数模板是一种通用的函数定义方式，允许在编写代码时不指定具体的类型，而是在调用时根据参数的类型自动推导出对应的函数实例。

#### 示例：

```cpp
#include <iostream>

template<typename T>
void print(T x) {
    std::cout << "Value: " << x << std::endl;
}

int main() {
    print(5);        // 调用 print<int>(int)
    print(3.14);     // 调用 print<double>(double)
    return 0;
}
```

在上面的示例中，通过函数模板定义了一个通用的 `print` 函数，根据实参的类型自动推导出对应的函数实例，实现了编译时多态。

### 静态多态的过程：

1. 在编写代码时，定义了多个具有相同名称但参数列表不同的函数或模板。

2. 在调用函数时，编译器根据实参的类型、个数和顺序匹配到合适的函数或模板实例。

3. 编译器根据匹配到的函数或模板实例生成对应的调用代码。

4. 在程序运行时，调用生成的调用代码执行相应的操作。

总的来说，静态多态是通过函数重载和模板实现的，编译器在编译时根据参数的类型、个数和顺序选择调用合适的函数或模板实例，从而实现了编译时多态。

## C++ 动态多态的细节和过程 详解

C++ 中的动态多态是通过继承和虚函数实现的。在运行时多态中，当基类指针或引用指向派生类对象时，通过虚函数表（vtable）实现动态绑定，即根据对象的实际类型来调用对应的函数。

### 1. 虚函数：

虚函数是在基类中声明为 `virtual` 的成员函数。当基类的指针或引用指向派生类对象时，可以通过虚函数实现对派生类中重写的函数的动态调用。

#### 示例：

```cpp
#include <iostream>

class Animal {
public:
    virtual void makeSound() const {
        std::cout << "Animal makes a sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() const override {
        std::cout << "Dog barks" << std::endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() const override {
        std::cout << "Cat meows" << std::endl;
    }
};

int main() {
    Animal* animalPtr;

    Dog dog;
    Cat cat;

    animalPtr = &dog;
    animalPtr->makeSound();   // 输出: Dog barks

    animalPtr = &cat;
    animalPtr->makeSound();   // 输出: Cat meows

    return 0;
}
```

在上面的示例中，`Animal` 类中的 `makeSound()` 函数被声明为虚函数，因此可以通过基类指针 `animalPtr` 调用派生类中重写的 `makeSound()` 函数，实现了动态多态。

### 2. 虚函数表（vtable）：

每个含有虚函数的类都有一个虚函数表，其中存储了指向虚函数的指针。当对象被创建时，会为其分配一个虚函数表，并在表中存储该对象的虚函数地址。

当调用虚函数时，编译器会根据对象的实际类型查找虚函数表，并根据表中存储的虚函数地址来调用对应的函数。

### 动态多态的过程：

1. 在定义类时，通过在基类中声明虚函数来实现多态性。

2. 在创建对象时，为对象分配虚函数表，并在表中存储虚函数地址。

3. 当基类指针或引用指向派生类对象时，根据对象的实际类型查找虚函数表，并根据表中存储的虚函数地址来调用对应的函数。

4. 在程序运行时，根据对象的实际类型动态调用相应的函数，实现了运行时多态。

总的来说，动态多态是通过继承和虚函数实现的，在运行时根据对象的实际类型来调用相应的函数，从而实现了动态绑定和多态性。

## 返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？

在 C++ 中，函数的重载（Function Overloading）允许在同一个作用域中定义多个函数，这些函数具有相同的名称但是参数列表不同。在函数重载中，编译器根据函数的参数类型、个数和顺序来选择调用合适的函数，实现了静态多态。

但是，函数的重载仅仅是通过参数的不同来实现的，而不涉及函数的返回值类型。如果仅仅是返回值类型不同而函数名和函数参数相同，是无法实现静态多态的。因为编译器无法根据函数的返回值类型来选择调用合适的函数。

下面是一个例子说明：

```cpp
#include <iostream>

// 函数重载，参数列表不同
void foo(int x) {
    std::cout << "Integer: " << x << std::endl;
}

void foo(double x) {
    std::cout << "Double: " << x << std::endl;
}

// 返回值类型不同，但函数名和参数列表相同
int foo(int x) {
    return x * 2;
}

double foo(int x) {
    return x * 2.0;
}

int main() {
    foo(5);   // 编译错误：对 'foo' 的调用不明确
    return 0;
}
```

在上面的示例中，定义了两组函数重载，第一组是参数列表不同的 `foo` 函数，可以实现静态多态。而第二组是返回值类型不同但函数名和参数列表相同的 `foo` 函数，在调用时会导致编译错误，因为编译器无法确定调用哪个函数。

因此，静态多态是通过参数列表的不同来实现的，而函数的返回值类型不同并不影响函数的重载。

## 返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？

是的，通过模板（Template）可以实现函数模板的重载，从而实现静态多态。函数模板允许定义一种通用的函数，可以处理不同类型的参数，但是在调用时根据实参的类型推导出对应的函数实例。

下面是一个示例说明：

```cpp
#include <iostream>

// 函数模板重载，返回值类型不同，但参数列表相同
template<typename T>
T foo(T x) {
    return x * 2;
}

template<>
double foo<double>(double x) {
    return x * 2.0;
}

int main() {
    int result1 = foo(5);       // 调用模板函数 foo<int>(int)，返回类型为 int
    double result2 = foo(3.14); // 调用特化的模板函数 foo<double>(double)，返回类型为 double

    std::cout << "Result 1: " << result1 << std::endl;  // 输出：10
    std::cout << "Result 2: " << result2 << std::endl;  // 输出：6.28

    return 0;
}
```

在上面的示例中，定义了一个函数模板 `foo`，该模板可以处理任意类型的参数。同时，通过对 `double` 类型的特化，定义了另一个版本的 `foo` 函数，处理 `double` 类型的参数。在调用函数 `foo` 时，编译器会根据实参的类型推导出对应的函数实例，从而实现了静态多态。

因此，通过函数模板的重载和特化，可以实现返回值类型不同但函数名和参数列表相同的静态多态。

## 多态是在运行时做的还是编译时做的

多态（Polymorphism）在 C++ 中既可以在编译时实现（静态多态），也可以在运行时实现（动态多态）。

1. **编译时多态（静态多态）**：编译时多态是通过函数重载和模板实现的，编译器在编译阶段根据函数的参数类型、个数和顺序来选择调用合适的函数或模板实例。编译时多态的特点是，在编译阶段就确定了函数调用的具体实现，因此效率更高。

2. **运行时多态（动态多态）**：运行时多态是通过继承和虚函数实现的，当基类指针或引用指向派生类对象时，通过虚函数表实现动态绑定，即根据对象的实际类型来调用对应的函数。运行时多态的特点是，在运行时根据对象的实际类型确定函数调用的具体实现，因此更灵活。

在实际开发中，根据具体需求和性能要求选择合适的多态实现方式。静态多态适用于在编译时就能确定函数调用的场景，而动态多态适用于需要在运行时根据对象的实际类型确定函数调用的场景。

## 静态多态和动态多态的区别

静态多态和动态多态是两种不同的多态实现方式，它们在实现原理、使用时机和效率等方面有着明显的区别。

### 1. 实现原理：

- **静态多态**：通过函数重载和模板实现。在编译阶段根据函数的参数类型、个数和顺序来选择调用合适的函数或模板实例。

- **动态多态**：通过继承和虚函数实现。当基类指针或引用指向派生类对象时，通过虚函数表实现动态绑定，即根据对象的实际类型来调用对应的函数。

### 2. 使用时机：

- **静态多态**：适用于在编译时就能确定函数调用的场景，例如根据参数类型的不同选择不同的函数实现。

- **动态多态**：适用于需要在运行时根据对象的实际类型确定函数调用的场景，例如基类指针或引用指向派生类对象时的函数调用。

### 3. 效率：

- **静态多态**：在编译时确定函数调用的具体实现，因此效率更高，但不够灵活。

- **动态多态**：在运行时确定函数调用的具体实现，灵活性更高，但会稍微降低一些性能，因为需要在运行时查找虚函数表。

### 4. 编程模型：

- **静态多态**：通常使用函数重载和模板来实现，是一种编译期间的机制。

- **动态多态**：通常使用继承和虚函数来实现，是一种运行时的机制。

总的来说，静态多态和动态多态各有优缺点，在不同的场景下选择合适的多态实现方式能够提高代码的可维护性和灵活性。

## 原子操作是怎么做的

原子操作是计算机科学中一种重要的操作方式，用于确保多个线程或进程同时访问共享资源时的正确性。原子操作是不可中断的操作，它要么完全执行成功，要么完全不执行，不会出现部分执行的情况。

在现代计算机体系结构中，原子操作通常是通过硬件支持来实现的，其中包括处理器提供的原子指令和内存模型的支持。下面是一些常见的原子操作机制：

1. **原子指令：** 许多处理器提供了原子指令集，如原子加载（atomic load）、原子存储（atomic store）、原子交换（atomic exchange）、原子加法（atomic add）等。这些指令能够保证在多线程或多进程环境下对内存的操作是原子的，不会被中断或干扰。

2. **自旋锁：** 自旋锁是一种基于原子操作的锁机制，它通过循环等待的方式来获取锁，直到成功获取锁为止。自旋锁通常使用原子的测试和设置（test-and-set）指令来实现，它能够在多核处理器上有效地防止竞争条件的发生。

3. **原子操作库：** 许多编程语言和操作系统提供了原子操作的库函数或API，如C++11引入了 `<atomic>` 头文件，提供了一系列原子操作的模板类和函数，可以在多线程环境中安全地进行操作。

4. **事务内存（Transactional Memory）：** 事务内存是一种新兴的并发控制机制，它提供了一种以原子方式执行一组指令序列的方法。事务内存通过硬件或软件来实现，能够在保持原子性的同时提高并发性。

5. **硬件支持的原子操作：** 一些现代处理器提供了硬件支持的原子操作，如 Compare-and-Swap（CAS）指令，它是一种原子操作，可以在一个内存地址上进行比较和交换操作，通常用于实现同步原语和锁。

总的来说，原子操作是通过硬件和软件的支持来保证在多线程或多进程环境下对共享资源的操作是原子的，不会出现竞争条件或数据不一致的情况。

## C++ STL常见的容器有哪些

C++ STL（Standard Template Library，标准模板库）提供了丰富的容器类模板，用于存储和管理数据。以下是一些常见的 C++ STL 容器：

1. **序列容器（Sequence Containers）：**
   - `std::vector`：动态数组，支持快速随机访问和尾部插入删除。
   - `std::deque`：双端队列，支持快速随机访问和两端插入删除。
   - `std::list`：双向链表，支持快速插入删除和双向迭代器。
   - `std::forward_list`：单向链表，支持快速插入删除和单向迭代器。

2. **关联容器（Associative Containers）：**
   - `std::set`：有序集合，元素唯一且自动排序。
   - `std::map`：有序键值对容器，键唯一且自动排序。
   - `std::multiset`：有序多重集合，元素可重复且自动排序。
   - `std::multimap`：有序多重键值对容器，键可重复且自动排序。
   - `std::unordered_set`：无序集合，元素唯一且哈希存储。
   - `std::unordered_map`：无序键值对容器，键唯一且哈希存储。
   - `std::unordered_multiset`：无序多重集合，元素可重复且哈希存储。
   - `std::unordered_multimap`：无序多重键值对容器，键可重复且哈希存储。

3. **容器适配器（Container Adapters）：**
   - `std::stack`：栈，基于序列容器实现的后进先出（LIFO）数据结构。
   - `std::queue`：队列，基于序列容器实现的先进先出（FIFO）数据结构。
   - `std::priority_queue`：优先队列，基于序列容器实现的优先级队列。

4. **关联容器适配器（Associative Container Adapters）：**
   - `std::priority_queue`：优先队列，基于关联容器实现的优先级队列。

这些容器提供了不同的数据存储和访问方式，开发者可以根据需求选择合适的容器。容器之间提供了一致的接口，使得在代码中可以方便地进行切换和替换，而不需要修改大部分代码。

## std::unorder_map和std::map插入搜索复杂度

`std::unordered_map` 和 `std::map` 是 C++ STL 提供的两种常用的关联容器，它们之间在插入和搜索操作的复杂度上有所不同：

1. **std::unordered_map**：
   - **插入复杂度（Average Insertion Complexity）：** O(1)（常数时间）。
   - **搜索复杂度（Average Search Complexity）：** O(1)（常数时间），但是考虑到哈希冲突的情况，可能会退化为 O(n)，其中 n 是 `std::unordered_map` 中元素的数量。
   
   `std::unordered_map` 是基于哈希表实现的，它通过哈希函数将键映射到存储桶（bucket），并在存储桶中使用链表或其他数据结构来处理哈希冲突。在平均情况下，插入和搜索操作都是常数时间复杂度的，但在最坏情况下，可能会因为哈希冲突导致链表变得很长，搜索的复杂度可能会退化为线性时间复杂度。

2. **std::map**：
   - **插入复杂度（Average Insertion Complexity）：** O(log n)（对数时间）。
   - **搜索复杂度（Average Search Complexity）：** O(log n)（对数时间）。
   
   `std::map` 是基于红黑树实现的，它是一种自平衡的二叉搜索树。在插入和搜索操作时，红黑树会保持平衡，因此插入和搜索的时间复杂度都是对数时间的。

因此，当需要在 C++ 中使用关联容器时，可以根据实际需求选择 `std::unordered_map` 还是 `std::map`。如果对搜索性能有较高的要求，并且可以接受在某些情况下插入性能较差的情况，可以选择 `std::map`；如果对插入和搜索性能都有较高要求，并且可以接受在某些情况下搜索性能略低于 `std::map`，但总体上更为均衡，可以选择 `std::unordered_map`。

## 跳板插入删除复杂度

跳表（Skip List）是一种随机化数据结构，它可以支持快速的插入、删除和搜索操作，其插入和删除的平均时间复杂度为 O(log n)，搜索的时间复杂度也是 O(log n)，其中 n 是跳表中元素的数量。以下是跳表插入和删除操作的详细说明：

1. **插入操作：**
   - 首先，从顶层开始，沿着每一层的链表，找到要插入的位置前面的节点。
   - 然后，为新节点生成随机高度，这个高度决定了新节点的层数。
   - 在每一层中，将新节点插入到前面找到的节点之后，并更新指针。
   - 插入完成后，如果新节点的层数比当前跳表的最大层数要高，则需要更新跳表的最大层数。

2. **删除操作：**
   - 首先，从顶层开始，沿着每一层的链表，找到要删除的节点前面的节点。
   - 然后，从每一层中删除要删除的节点，并更新指针。
   - 删除完成后，如果删除节点后某一层的链表为空，可以将该层的链表删除，并更新跳表的最大层数。

跳表的插入和删除操作需要通过更新指针来调整跳表的结构，因此时间复杂度是 O(log n)，其中 n 是跳表中元素的数量。需要注意的是，由于跳表是一种随机化数据结构，因此插入和删除操作的最坏时间复杂度是 O(n)，但是平均情况下的时间复杂度是 O(log n)。

跳表的搜索操作也是 O(log n) 的时间复杂度，因为每次搜索都是从顶层开始，沿着每一层的链表向右移动，直到找到目标节点或者到达最底层。由于跳表中每一层的节点数量都是有序的，因此可以利用二分查找的思想来加速搜索过程。

## 跳板为什么不用B+树

跳表和 B+ 树是两种不同的数据结构，它们各自适用于不同的场景和需求，因此在某些情况下选择跳表而不是 B+ 树可能是出于以下一些考虑：

1. **实现简单：** 跳表的实现相对较为简单，而 B+ 树的实现则更加复杂。跳表的基本操作（插入、删除、搜索）相对容易理解和实现，不需要复杂的平衡调整过程，而 B+ 树需要考虑到节点分裂、合并、调整等操作。

2. **高效的随机访问：** 跳表支持快速的随机访问，其搜索操作的时间复杂度为 O(log n)，与 B+ 树相比在某些场景下可能更加高效，尤其是在内存中数据存储、高并发的读写操作等方面。

3. **适合有序集合操作：** 跳表的有序特性使得它在有序集合的操作上更加灵活，如范围查找、范围删除等操作更容易实现。

4. **无需频繁的平衡调整：** 跳表在插入和删除操作时不需要频繁地进行平衡调整，而 B+ 树需要保持平衡，可能需要进行频繁的节点分裂、合并等操作，这可能会增加操作的开销。

5. **易于并发处理：** 跳表的节点分布相对简单，节点之间的关系不像 B+ 树那样严格，这使得跳表更容易进行并发处理。

总的来说，虽然 B+ 树在某些方面（如磁盘存储、范围查询等）具有优势，但在一些内存中的场景下，跳表可能更加适合，因为它的实现相对简单、高效的随机访问和更容易的并发处理等特性使得它成为了一种有竞争力的选择。

## 如何通过redis实现一个限流组件，要求限制每秒5个链接

通过 Redis 实现一个限流组件是一个常见的场景，可以使用 Redis 的计数器和过期时间等功能来实现。以下是一种可能的实现方式：

```python
import redis
import time

class RateLimiter:
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_conn = redis.StrictRedis(host=redis_host, port=redis_port)
        self.key = 'rate_limiter'
        self.limit = 5
        self.expiry = 1  # 每秒钟清空计数器

    def is_allowed(self):
        # 获取当前时间戳
        current_time = time.time()

        # 尝试获取计数器的值
        count = self.redis_conn.get(self.key)

        if not count:
            # 如果计数器不存在，则初始化为 1，并设置过期时间
            self.redis_conn.setex(self.key, self.expiry, 1)
            return True

        count = int(count)

        if count < self.limit:
            # 如果计数器未达到限制，则递增计数器的值，并设置过期时间
            self.redis_conn.incr(self.key)
            self.redis_conn.expire(self.key, self.expiry)
            return True

        # 如果计数器达到了限制，则不允许新的连接
        return False

# 使用示例
limiter = RateLimiter()

for i in range(10):
    if limiter.is_allowed():
        print(f"连接 {i+1} 允许访问")
    else:
        print(f"连接 {i+1} 超过限制，不允许访问")

```

在上面的代码中，`RateLimiter` 类通过 Redis 实现了一个基于令牌桶算法的限流组件。每次访问时，会尝试获取计数器的值，如果计数器不存在，则初始化为 1，并设置过期时间；如果计数器存在且未达到限制，则递增计数器的值，并设置过期时间；如果计数器达到了限制，则不允许新的连接。

## redis分布式锁了解多少

Redis 分布式锁是一种在分布式系统中实现互斥访问的机制，它可以确保在多个节点上的不同进程或线程之间对共享资源的安全访问。以下是关于 Redis 分布式锁的一些了解：

1. **实现原理：** Redis 分布式锁的实现通常基于 Redis 的原子操作，使用 SETNX（SET if Not eXists）命令或者 SET key value [NX|XX] 命令来设置锁，并使用 EXPIRE 命令设置锁的过期时间，确保锁在一段时间后自动释放，避免死锁。

2. **使用场景：** Redis 分布式锁适用于需要在分布式系统中保证互斥访问的场景，如分布式任务调度、分布式缓存更新、分布式资源管理等。

3. **实现方式：** 实现 Redis 分布式锁有多种方式，常见的有基于 SETNX 命令的简单锁、基于 Redlock 算法的多实例锁、基于 Lua 脚本的原子操作锁等。

4. **存在问题：** Redis 分布式锁虽然能够实现基本的互斥访问，但也存在一些问题，如死锁问题、误删锁问题、锁过期问题等，需要在实际应用中进行充分考虑和处理。

5. **可靠性考虑：** 在设计和使用 Redis 分布式锁时，需要考虑锁的可靠性和性能，如锁的获取、释放、过期时间等方面的性能，以及在异常情况下的锁的可靠性保证。

总的来说，Redis 分布式锁是一种简单而有效的实现分布式系统中互斥访问的机制，可以在一定程度上保证共享资源的安全访问，但在实际使用中需要充分考虑各种情况下的可靠性和性能问题。

## fork()会发生什么，子进程会拷贝父进程那些数据

`fork()` 是一个创建新进程的系统调用，在调用 `fork()` 时，操作系统会创建一个新的子进程，这个子进程几乎是父进程的完整拷贝，包括代码段、数据段、堆栈等。下面是 `fork()` 的一般行为：

1. **父进程和子进程：** `fork()` 调用成功后，会在当前进程（父进程）中创建一个新的子进程，这两个进程在调用 `fork()` 之后会几乎完全一样，包括代码、数据和程序的执行状态。

2. **父子进程的返回值：** `fork()` 在父进程中返回子进程的 PID（进程ID），在子进程中返回 0。这样可以通过返回值的不同来区分父子进程。

3. **数据拷贝：** 在调用 `fork()` 时，操作系统会复制父进程的地址空间，包括代码段、数据段、堆和栈等。但是，操作系统使用了写时复制（Copy-On-Write，COW）技术，即只有在需要修改数据时才会进行实际的复制，这样可以尽量减少内存的消耗。

4. **文件描述符：** 子进程会继承父进程的文件描述符，包括标准输入、标准输出和标准错误等。

5. **其他资源：** 子进程会继承父进程的其他资源，如文件描述符、信号处理器等。

需要注意的是，尽管子进程是父进程的副本，但父子进程之间是独立运行的，它们各自拥有自己的地址空间，对自己地址空间的修改不会影响对方。在实际编程中，可以利用这个特性实现一些功能，比如使用 `fork()` 创建子进程来并行处理任务。

## bfork() 详解

`bfork()` 并不是标准的系统调用，而是某些特定操作系统或特定环境下的非标准扩展或自定义函数。因此，其行为和用法可能会因操作系统或环境的不同而有所不同。

在一些操作系统或环境中，`bfork()` 可能是一个自定义的函数，其功能类似于标准的 `fork()` 系统调用，用于创建一个新的子进程。但是，由于它不是标准的系统调用，因此具体的行为可能会有所不同，可能会有额外的参数或功能，或者在特定环境中实现了一些特殊的功能。

如果你具体指的是某个特定操作系统或环境下的 `bfork()` 函数，建议查阅相关文档或资料以获取详细的信息和用法说明。

## 程序性能调优有哪些方式

程序性能调优是优化程序以提高其执行效率和资源利用率的过程。下面是一些常见的程序性能调优方式：

1. **分析和测量：** 首先要对程序进行分析和测量，找出性能瓶颈所在。可以使用性能分析工具如`gprof`、`perf`或`Valgrind`等进行程序分析和性能测试，以确定程序的热点代码和性能瓶颈。

2. **算法优化：** 通过改进算法来减少程序的时间复杂度，从而提高程序的执行效率。选择合适的数据结构和算法，尽量减少不必要的计算和数据操作。

3. **代码优化：** 通过改进代码结构和优化代码实现，减少不必要的计算、内存访问和函数调用等开销。可以通过简化算法、减少循环嵌套、提取公共部分等方式来优化代码。

4. **并行和并发：** 利用多线程、多进程和并行计算等技术来提高程序的并发性和并行性，充分利用多核处理器和分布式系统的计算资源。

5. **IO优化：** 减少IO操作的次数和开销，使用缓存、异步IO和批处理等技术来提高IO性能。

6. **内存优化：** 减少内存使用量，尽量减少内存分配和释放的次数，避免内存泄漏和内存碎片等问题。

7. **编译优化：** 使用编译器提供的优化选项来优化代码生成和执行效率，如`-O3`、`-flto`等。

8. **硬件优化：** 针对特定硬件平台进行优化，利用硬件加速器如GPU、FPGA等来加速计算。

9. **缓存优化：** 充分利用CPU缓存和其他级别的缓存，减少缓存失效和数据访问延迟，提高程序的局部性和访问速度。

10. **定位和解决性能瓶颈：** 通过持续的性能测试和监控，及时发现和解决程序的性能瓶颈，优化程序的关键路径和性能热点。

综合利用以上各种调优方式，可以显著提高程序的执行效率和性能，并更好地满足实际需求。

## C++ perf工具 详解

`perf` 是一个性能分析工具，用于在 Linux 系统上对程序的性能进行分析和测量。它可以用来收集各种性能数据，包括 CPU 使用率、内存访问、函数调用图等，并提供了丰富的选项和功能来帮助用户分析程序的性能瓶颈和优化方向。

下面是 `perf` 工具的一些主要特点和用法：

1. **收集性能数据：** `perf` 可以收集各种性能数据，包括 CPU 指令、缓存命中率、内存访问、函数调用次数和耗时、线程和进程的运行状态等。

2. **多种分析模式：** `perf` 提供了多种分析模式，包括 CPU 指令级分析、函数级分析、事件采样分析、事件计数器分析等，可以根据不同的需求选择合适的分析模式。

3. **动态追踪：** `perf` 支持动态追踪，可以在程序执行过程中进行性能分析，而无需修改程序代码或重新编译程序。

4. **交互式界面：** `perf` 提供了交互式命令行界面，用户可以通过简单的命令进行性能分析和数据查看，包括调用图、火焰图、热点函数等。

5. **可视化工具：** 除了命令行界面，`perf` 还支持与其他工具（如`perf report`、`perf annotate`、`perf record`等）配合使用，进行性能数据的可视化分析和展示。

6. **灵活配置：** `perf` 提供了丰富的选项和配置功能，可以根据具体需求定制性能分析的参数和方式，以便更好地理解程序的性能特征和瓶颈。

`perf` 是 Linux 系统自带的性能分析工具，可以通过在命令行中直接输入 `perf` 加上相应的选项来使用。通过 `perf` 工具，开发者可以快速、方便地对程序的性能进行评估和优化，从而提高程序的执行效率和性能。

## cmake perf配置

在 CMake 中配置使用 `perf` 工具进行性能分析并不直接支持，因为 `perf` 是 Linux 系统自带的性能分析工具，与 CMake 的构建系统没有直接关系。但是，你可以在 CMake 构建系统中集成 `perf` 工具的使用，以便在构建和运行程序时进行性能分析。

以下是一种在 CMake 中集成 `perf` 工具的简单方法：

1. **配置编译选项：** 在 CMakeLists.txt 文件中配置编译选项，以便在编译程序时开启性能分析支持。例如，可以通过设置 `-g` 选项开启调试信息，以便在分析时能够获取更多的调试信息。

   ```cmake
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
   ```

2. **使用 perf 命令：** 在构建和运行程序时，使用 `perf` 命令进行性能分析。你可以在 CMakeLists.txt 文件中定义自定义的构建和运行目标，并在其中使用 `perf` 命令来执行性能分析。例如：

   ```cmake
   add_custom_target(run_perf
       COMMAND perf record -o perf.data ./your_program
       COMMAND perf report
       DEPENDS your_program
   )
   ```

   在这个例子中，`run_perf` 目标定义了一个 `perf record` 命令来收集性能数据，并使用 `perf report` 命令来生成性能报告。`DEPENDS` 关键字用于指定 `run_perf` 目标依赖于构建程序的完成。

3. **运行构建目标：** 在使用 `perf` 工具时，可以通过运行相应的构建目标来进行性能分析。例如，在命令行中执行以下命令：

   ```bash
   cmake --build . --target run_perf
   ```

通过以上步骤，你可以在 CMake 构建系统中集成 `perf` 工具的使用，并在构建和运行程序时进行性能分析。需要注意的是，`perf` 工具的具体用法和选项可以根据实际需要进行调整和配置。

## cmake gprof工具使用

在 CMake 中使用 gprof 工具来进行性能分析通常需要以下几个步骤：

1. **编译时启用 gprof 支持：** 首先，需要在编译时启用 gprof 支持。这可以通过在 CMakeLists.txt 文件中设置相应的编译选项来完成。通常，你需要使用 `-pg` 选项来启用 gprof 支持。你可以在 `CMAKE_C_FLAGS` 和 `CMAKE_CXX_FLAGS` 变量中添加 `-pg` 选项，如下所示：

    ```cmake
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -pg")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pg")
    ```

2. **重新编译你的项目：** 一旦在 CMakeLists.txt 中设置了编译选项，你需要重新编译你的项目以确保 gprof 支持已经生效。

3. **运行程序以生成 gmon.out 文件：** 当你的程序运行时，gprof 会收集性能数据并将其存储在一个名为 gmon.out 的文件中。你需要确保在程序执行完毕后能够找到这个文件。你可以通过以下方式运行你的程序：

    ```bash
    ./your_executable
    ```

4. **生成分析报告：** 一旦 gmon.out 文件已经生成，你可以使用 gprof 工具来生成性能分析报告。使用以下命令来执行 gprof：

    ```bash
    gprof ./your_executable gmon.out > analysis.txt
    ```

    这将生成一个名为 analysis.txt 的文本文件，其中包含了程序的性能分析报告。

记住，使用 gprof 进行性能分析时，最好在 release 模式下编译你的代码，以便获得更准确的性能数据。此外，要确保你的代码中包含了足够的符号信息，以便 gprof 能够正确地分析函数调用关系。

这就是在 CMake 中使用 gprof 工具进行性能分析的基本步骤。