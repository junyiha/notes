## 简介

+ C++编程技巧

## C++ std::vector 指定被赋值容器的范围进行赋值

如果你想要在C++中使用`std::vector`，并且想要将一个vector的内容赋值给另一个vector的特定范围，你可以使用`std::copy`算法或者`std::vector`的迭代器来实现。

下面是使用`std::copy`算法的示例代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5};
    std::vector<int> destination(7); // 创建一个有7个元素的目标vector

    // 将source的第2到第4个元素（不包括第4个元素）赋值给destination的第3个位置开始
    std::copy(source.begin() + 1, source.begin() + 4, destination.begin() + 2);

    // 打印destination vector的内容
    std::cout << "destination contains:";
    for (int elem : destination) {
        std::cout << ' ' << elem;
    }
    std::cout << '\n';

    return 0;
}
```

这段代码会输出：

```
destination contains: 0 0 2 3 4 0 0
```

在这个例子中，`std::copy`算法从源vector的第2到第4个元素（不包括第4个元素）复制到目标vector的第3个位置开始。

另一种方法是使用`std::vector`的迭代器来实现。你可以使用`std::vector`的`assign`函数，结合迭代器来指定赋值的范围。

## C++ std::thread 和 std::move 

在 C++ 中，`std::thread` 是一个用于创建和管理线程的类，而 `std::move` 是一个用于移动语义的函数。这两者通常可以结合使用来传递线程的所有权。

在使用 `std::thread` 时，通常需要注意线程对象的所有权问题。当你想要将一个线程对象所有权从一个变量转移给另一个变量时，你可以使用 `std::move` 来实现移动语义，而不是复制线程对象。

以下是一个简单的示例，演示了如何使用 `std::move` 来传递 `std::thread` 对象的所有权：

```cpp
#include <iostream>
#include <thread>

void threadFunction() {
    std::cout << "Inside thread function\n";
}

int main() {
    // 创建一个线程
    std::thread t1(threadFunction);

    // 将线程对象的所有权移动给新的变量 t2
    std::thread t2 = std::move(t1);

    // t1 不再拥有线程，因此在这里无法join
    // 如果尝试 join t1，则会导致程序崩溃或未定义行为
    // t1.join(); 

    // t2 拥有线程，因此可以 join
    t2.join();

    return 0;
}
```

在这个示例中，`t1` 在创建时拥有线程，然后通过 `std::move` 将其所有权转移到了 `t2`。现在 `t1` 不再拥有线程，因此不能调用 `join()` 方法。相反，`t2` 现在拥有线程，可以调用 `join()` 方法。

使用 `std::move` 可以有效地避免资源的复制，而是直接转移资源的所有权，从而提高了性能并避免不必要的资源浪费。

## C++ 表示一个函数不应该出现异常

在C++中，表示一个函数不应该出现异常通常可以通过以下方式来实现：

1. **使用异常说明（Exception Specification）**：C++语言允许在函数声明中使用异常说明，指明函数不会抛出任何异常。例如：

```cpp
void myFunction() throw(); // 表示 myFunction 不会抛出任何异常
```

2. **使用 noexcept 关键字**：C++11 引入了 noexcept 关键字，用于指示函数是否抛出异常。如果函数确实不会抛出异常，应该使用 noexcept 关键字来声明。例如：

```cpp
void myFunction() noexcept; // 表示 myFunction 不会抛出异常
```

3. **编写良好的代码并避免抛出异常**：在编写代码时，可以通过良好的设计和编码实践来避免抛出异常。这可能涉及到使用异常安全的编程技术，如RAII（资源获取即初始化）等。

需要注意的是，尽管可以使用这些方法来表示函数不应该抛出异常，但并不能完全保证函数不会抛出异常。例如，如果函数调用了不受控制的外部库或操作系统函数，它们可能会引发异常。因此，在编写代码时，应该仔细考虑异常安全性，并尽量避免或者明确处理异常。