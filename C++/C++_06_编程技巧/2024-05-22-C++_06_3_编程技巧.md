---
category: C++
date: 2024-05-22 09:00:00 +0800
layout: post
title: C++_06_3_编程技巧
tag: Cpp
---
## 简介

+ C++编程技巧

## c++ 获取当前时间戳 毫秒

在C++中获取当前时间戳（以毫秒为单位）通常需要使用操作系统提供的时间函数。以下是一个使用C++标准库的例子，可以获取当前时间戳（以毫秒为单位）：

```cpp
#include <iostream>
#include <chrono>

int main() {
    // 获取当前时间点
    auto now = std::chrono::system_clock::now();

    // 将当前时间点转换为毫秒
    auto ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);

    // 获取时间戳
    auto timestamp = ms.time_since_epoch().count();

    std::cout << "Current timestamp in milliseconds: " << timestamp << std::endl;

    return 0;
}
```

这段代码使用了 `<chrono>` 头文件中的时间库，以及 `std::chrono::system_clock` 类和 `std::chrono::milliseconds` 类。它获取当前时间点，然后将其转换为毫秒，并输出时间戳。

## C++ std::this_thread::yield()函数后面的语句还会执行吗

`std::this_thread::yield()` 函数是一个线程库提供的函数，用于提示调度器让出当前线程的执行权，以便其他线程有机会执行。调用 `std::this_thread::yield()` 后，当前线程会主动让出 CPU 的执行时间片，但它的执行权并不会立即转移到其他线程上。相反，操作系统调度器会在合适的时机（通常是在同一线程队列中的其他线程都执行完毕后）再次调度当前线程。因此，`std::this_thread::yield()` 后面的语句仍然会执行，只是在稍后的时间点。

考虑以下示例：

```cpp
#include <iostream>
#include <thread>

void foo() {
    std::cout << "Before yield" << std::endl;
    std::this_thread::yield();
    std::cout << "After yield" << std::endl;
}

int main() {
    std::thread t(foo);
    t.join();
    return 0;
}
```

在这个示例中，`foo()` 函数中的 `std::cout << "Before yield" << std::endl;` 和 `std::cout << "After yield" << std::endl;` 语句都会执行，即使在 `std::this_thread::yield();` 被调用后。`std::this_thread::yield()` 只是提示调度器让出 CPU 的执行时间片，而不是中断线程的执行。

## C++ 使用原子操作通知指定线程退出 示例 详解

使用原子操作通知指定线程退出的示例需要借助原子布尔标志（`std::atomic<bool>`）来控制线程的执行状态。下面是一个详细的示例：

```cpp
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<bool> shouldExit(false);

void worker(int id) {
    while (!shouldExit.load(std::memory_order_acquire)) {
        std::cout << "Worker " << id << " is working..." << std::endl;
        // Simulate some work
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    std::cout << "Worker " << id << " exiting." << std::endl;
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    
    // Simulate some work
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    // Set shouldExit to true
    shouldExit.store(true, std::memory_order_release);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

在这个示例中，`shouldExit` 是一个原子布尔变量，用来控制线程是否应该退出。在 `worker` 函数中，线程会在循环中检查 `shouldExit` 变量的值，如果值为 `false`，则继续执行工作，否则退出循环并退出线程。

在 `main` 函数中，首先创建了两个工作线程 `t1` 和 `t2`，然后模拟了一些工作。随后，`shouldExit` 被设置为 `true`，通知工作线程退出。最后，`main` 函数等待两个工作线程退出。

通过使用原子操作，我们可以避免使用额外的同步机制（如互斥锁、条件变量等），从而更加高效地控制线程的退出。

## C++ 使用条件变量通知指定线程退出 示例 详解

使用条件变量（`std::condition_variable`）通知指定线程退出的示例可以通过以下步骤实现：

1. 创建一个标志变量来指示线程是否应该退出。
2. 使用条件变量来等待通知。
3. 当需要退出线程时，设置标志变量，并通知等待线程退出。
4. 等待线程收到通知后退出。

让我们通过一个简单的示例来详细说明这个过程：

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool shouldExit = false;

void worker(int id) {
    std::unique_lock<std::mutex> lock(mtx);
    while (!shouldExit) {
        // Wait until notified or the timeout expires
        cv.wait(lock);
        std::cout << "Worker " << id << " is working..." << std::endl;
        // Simulate some work
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    std::cout << "Worker " << id << " exiting." << std::endl;
}

int main() {
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    
    // Simulate some work
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    {
        // Set shouldExit to true and notify the worker threads to exit
        std::lock_guard<std::mutex> lock(mtx);
        shouldExit = true;
        cv.notify_all();
    }
    
    t1.join();
    t2.join();
    
    return 0;
}
```

在这个示例中，有两个工作线程（`t1` 和 `t2`），它们会等待条件变量 `cv` 的通知。`shouldExit` 是一个标志变量，用于指示线程是否应该退出。

在 `main()` 函数中，首先创建了两个工作线程，然后模拟了一些工作。随后，`shouldExit` 被设置为 `true`，并且通过 `cv.notify_all()` 通知所有等待的线程退出。最后，`main()` 函数等待两个工作线程退出。

这样，通过条件变量和标志变量，我们可以控制线程的退出。当需要退出线程时，只需设置标志变量并通知等待的线程即可。

## C++ std::thread 线程间通信的几种方式 详解

在线程间通信时，C++ 的 `std::thread` 提供了几种常用的方式：

1. **共享内存（Shared Memory）**：
   - 这是最简单和直接的方法之一，多个线程可以访问同一块内存区域。但要小心并发访问的问题，需要使用诸如互斥锁（mutex）或原子操作等机制来确保线程安全。

2. **互斥锁（Mutex）**：
   - 使用 `std::mutex` 来确保一次只有一个线程可以访问共享资源。线程在访问共享资源之前先锁定互斥锁，访问完毕后再解锁。这确保了对共享资源的排他性访问，防止数据竞争。

3. **条件变量（Condition Variable）**：
   - `std::condition_variable` 可以在多线程间进行通信，一般与互斥锁一起使用。一个线程等待条件变量的某个条件为真，而另一个线程在适当的时候发出通知，告诉等待线程条件已经满足。

4. **原子操作（Atomic Operations）**：
   - `std::atomic` 类型提供了一种线程安全的方式来访问共享数据，它们确保在没有互斥锁的情况下执行单个操作时的线程安全性。原子操作通常用于简单的数据类型（如整数、布尔值等）。

5. **消息队列（Message Queue）**：
   - 使用 `std::queue` 或其他自定义队列结构，不同线程可以通过向队列发送消息来进行通信。这种方式一般需要配合互斥锁或原子操作来确保队列操作的线程安全。

6. **管道（Pipe）**：
   - 如果是在不同进程之间进行通信，可以使用管道。在C++中，可以使用 `popen()` 或者在POSIX环境下使用 `pipe()` 函数。

7. **信号量（Semaphore）**：
   - `std::semaphore` 或者第三方库提供的信号量机制可以用于控制同时访问某个共享资源的线程数量。

8. **屏障（Barrier）**：
   - 屏障允许多个线程在某一点上相互等待，直到所有线程都到达后才继续执行。C++中可以使用 `std::barrier`（C++20 引入）或者其他第三方库提供的屏障机制。

选择哪种通信方式取决于具体情况，包括线程之间的关系、共享资源的类型、性能需求等。

## C++ std::for_each() 函数中lambda捕获局部变量是以什么规则捕获的

在 C++ 中，`std::for_each()` 函数通常与 lambda 表达式一起使用。当你在 lambda 表达式中捕获局部变量时，捕获方式是由捕获列表来确定的。捕获列表控制了 lambda 表达式访问外部变量的方式。

捕获列表有两种方式：按值捕获和按引用捕获。

1. **按值捕获：** 按值捕获会在 lambda 表达式内部创建外部变量的副本，这样 lambda 表达式内部的代码就可以使用该副本。即使外部变量的值发生变化，lambda 表达式内部也不会受到影响。

```cpp
int main() {
    int x = 42;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // Lambda 按值捕获 x
    std::for_each(vec.begin(), vec.end(), [x](int n) {
        std::cout << n + x << std::endl;
    });
    
    return 0;
}
```

2. **按引用捕获：** 按引用捕获不会创建变量的副本，而是直接引用外部变量。这意味着 lambda 表达式内部的代码可以访问并修改外部变量的值。

```cpp
int main() {
    int x = 42;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // Lambda 按引用捕获 x
    std::for_each(vec.begin(), vec.end(), [&x](int n) {
        x += n;
    });
    
    std::cout << "x: " << x << std::endl; // 输出：x: 57
    
    return 0;
}
```

在使用 `std::for_each()` 函数时，你可以根据需要选择按值捕获还是按引用捕获，以确保 lambda 表达式的行为符合预期。

## C++ std::vector 指定被赋值容器的范围进行赋值

如果你想要在C++中使用`std::vector`，并且想要将一个vector的内容赋值给另一个vector的特定范围，你可以使用`std::copy`算法或者`std::vector`的迭代器来实现。

下面是使用`std::copy`算法的示例代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> source = {1, 2, 3, 4, 5};
    std::vector<int> destination(7); // 创建一个有7个元素的目标vector

    // 将source的第2到第4个元素（不包括第4个元素）赋值给destination的第3个位置开始
    std::copy(source.begin() + 1, source.begin() + 4, destination.begin() + 2);

    // 打印destination vector的内容
    std::cout << "destination contains:";
    for (int elem : destination) {
        std::cout << ' ' << elem;
    }
    std::cout << '\n';

    return 0;
}
```

这段代码会输出：

```
destination contains: 0 0 2 3 4 0 0
```

在这个例子中，`std::copy`算法从源vector的第2到第4个元素（不包括第4个元素）复制到目标vector的第3个位置开始。

另一种方法是使用`std::vector`的迭代器来实现。你可以使用`std::vector`的`assign`函数，结合迭代器来指定赋值的范围。

## C++ std::thread 和 std::move 

在 C++ 中，`std::thread` 是一个用于创建和管理线程的类，而 `std::move` 是一个用于移动语义的函数。这两者通常可以结合使用来传递线程的所有权。

在使用 `std::thread` 时，通常需要注意线程对象的所有权问题。当你想要将一个线程对象所有权从一个变量转移给另一个变量时，你可以使用 `std::move` 来实现移动语义，而不是复制线程对象。

以下是一个简单的示例，演示了如何使用 `std::move` 来传递 `std::thread` 对象的所有权：

```cpp
#include <iostream>
#include <thread>

void threadFunction() {
    std::cout << "Inside thread function\n";
}

int main() {
    // 创建一个线程
    std::thread t1(threadFunction);

    // 将线程对象的所有权移动给新的变量 t2
    std::thread t2 = std::move(t1);

    // t1 不再拥有线程，因此在这里无法join
    // 如果尝试 join t1，则会导致程序崩溃或未定义行为
    // t1.join(); 

    // t2 拥有线程，因此可以 join
    t2.join();

    return 0;
}
```

在这个示例中，`t1` 在创建时拥有线程，然后通过 `std::move` 将其所有权转移到了 `t2`。现在 `t1` 不再拥有线程，因此不能调用 `join()` 方法。相反，`t2` 现在拥有线程，可以调用 `join()` 方法。

使用 `std::move` 可以有效地避免资源的复制，而是直接转移资源的所有权，从而提高了性能并避免不必要的资源浪费。

## C++ 表示一个函数不应该出现异常

在C++中，表示一个函数不应该出现异常通常可以通过以下方式来实现：

1. **使用异常说明（Exception Specification）**：C++语言允许在函数声明中使用异常说明，指明函数不会抛出任何异常。例如：

```cpp
void myFunction() throw(); // 表示 myFunction 不会抛出任何异常
```

2. **使用 noexcept 关键字**：C++11 引入了 noexcept 关键字，用于指示函数是否抛出异常。如果函数确实不会抛出异常，应该使用 noexcept 关键字来声明。例如：

```cpp
void myFunction() noexcept; // 表示 myFunction 不会抛出异常
```

3. **编写良好的代码并避免抛出异常**：在编写代码时，可以通过良好的设计和编码实践来避免抛出异常。这可能涉及到使用异常安全的编程技术，如RAII（资源获取即初始化）等。

需要注意的是，尽管可以使用这些方法来表示函数不应该抛出异常，但并不能完全保证函数不会抛出异常。例如，如果函数调用了不受控制的外部库或操作系统函数，它们可能会引发异常。因此，在编写代码时，应该仔细考虑异常安全性，并尽量避免或者明确处理异常。