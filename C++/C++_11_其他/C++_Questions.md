## 简介

+ C++面试 问题

## 左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么

+ 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。
  + 左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
  + 右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。

+ 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。
  + 纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值
+ 需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。

## 什么是多态

+ 术语--**多态**，指的是有多种形式，因此函数多态允许函数可以有多种形式。
+ 在了解多态之前，需要了解虚函数
  + 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
  + 虚函数是指**一个类中希望重载的成员函数**，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。
  + 而函数重载，是允许参数不同，但函数名相同。函数重载的关键是函数的参数列表--也称为**函数特征标**(`function signature`)。
  + 如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。
  + **C++允许定义名称相同的函数，条件是它们的特征标不同**。如果参数数目和/或参数类型不同，则特征标也不同。
+ 同一代码可以产生不同效果的特点，称为“多态”

## 虚函数和纯虚函数

+ 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
+ 虚函数是C++中用于实现多态(`polymorphism`)的机制，核心理念就是通过基类访问派生类定义的函数。

+ 注意：在普通的虚函数后面加上`=0`，这样就声明了一个纯虚函数(`pure virtual function`)
+ 纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们**派生类都会有这个函数**

+ 在什么情况下使用纯虚函数？
  - 当想在基类中**抽象出一个方法，且该基类只能被继承，而不能被实例化时**
  - 这个方法**必须在派生类中被实现**
+ 如果满足以上两点，可以考虑将该方法被声明为纯虚函数

+ 当一个类打算被用作其他类的基类时，**它的析构函数必须是虚的**

## 引用和指针的区别

+ 引用变量
  - 引用是已定义的变量的别名（另一个名称）
  - 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的
  - `int rats; int & rodents = rats;  // make rodents an alias for rate`
  - 其中，`&`不是地址运算符，而是类型标识符的一部分。就像声明中的`char*`指的是指向`char`的指针一样，`int&`指的是指向int的引用。
  + 引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量

+ 指针
  - 指针，是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元

+ 区别：
  + 指针是存储变量地址的变量；引用是变量的别名。
  + 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错
  + 指针变量定义时可以初始化为NULL；引用不能初始化为NULL，不然报错。
  + const修饰指针变量，const放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const修饰引用，const放在&之前，不能修改引用所表示的变量的值；const放在&之后，const的作用被忽略，可以修改引用所表示的变量的值。
  + 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名
  + sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
  + 指针可以有多级，引用只有一级。
  + 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。

## 静态链接库与动态链接库

+ 静态链接库：
  + 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
  + 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
  + 创建静态库需要用到一个工具:`AR`

+ 动态链接库：
  + 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
  + 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**

## 静态链接库与动态链接库的区别

静态链接库和动态链接库是两种不同类型的库文件，它们在软件开发中扮演着不同的角色，并且具有一些显著的区别：

### 静态链接库（Static Linking Library）：

1. **链接方式**：
   - **编译时链接**：静态链接库在编译时被链接到可执行文件中，将库的代码和可执行文件合并为一个单独的可执行文件。

2. **文件格式**：
   - **文件大小**：相对较大，因为它包含了被调用的库的完整副本。
   - **扩展名**：通常是`.lib`（在Windows平台）或`.a`（在Unix/Linux平台）。

3. **运行时**：
   - **独立性**：生成的可执行文件独立运行，不需要外部依赖。
   - **移植性**：可能导致较大的可执行文件，并且需要在每个使用相同静态库的应用程序中重新链接和更新。

### 动态链接库（Dynamic Linking Library）：

1. **链接方式**：
   - **运行时链接**：动态链接库在程序运行时被加载到内存中，并且可以被多个程序共享使用。

2. **文件格式**：
   - **文件大小**：相对较小，因为它包含了可共享的代码和数据，被多个程序共享使用。
   - **扩展名**：通常是`.dll`（在Windows平台）或`.so`（在Unix/Linux平台）。

3. **运行时**：
   - **依赖性**：程序在运行时需要正确的动态链接库存在，否则会出现运行错误。
   - **更新和维护**：修改动态链接库可能影响多个程序，但是可以通过单独更新库文件来修复或升级功能，不需要重新编译整个程序。

### 总结区别：

- **静态链接库**在编译时将代码和数据合并到可执行文件中，使得程序独立运行，但增加了可执行文件的大小和每个应用的维护负担。
- **动态链接库**在运行时被加载到内存中，多个程序可以共享它，减少了磁盘空间和内存的占用，但程序需要确保相应的库在运行时存在。

在实际开发中，通常会根据具体需求和考虑因素来选择使用静态链接库或动态链接库。

## 简单介绍一下webserver

+ Web服务器是一种软件或者应用程序，负责接收客户端请求并向其提供响应的资源。它充当客户端和后端服务器之间的中介，通过HTTP协议进行通信。

+ Web服务器的主要功能包括
  + 接收和处理客户端请求：Web服务器监听指定的端口，接收来自客户端(例如浏览器)发送的HTTP请求。它解析请求，识别所需资源，并采取适当的操作来响应请求
  + 资源管理：Web服务器负责管理和提供各种资源，例如HTML文件，图像，CSS样式表，Javascript脚本等。它能够从磁盘上的文件系统中获取这些资源，并将其发送给客户端。
  + 处理动态内容: 除了静态资源外，Web服务器还可以与后端应用程序(例如CGI脚本，PHP脚本，ASP.NET等)交互以生成动态内容。它可以将请求转发给适当的后台处理程序，并将生成的结果返回给客户端。
  + 连接管理: Web服务器需要管理并保持与多个客户端之间的连接。他可以使用不同的策略来处理连接池，线程池或者事件驱动等方式来高效地处理并法请求
  + 安全性和身份验证: 为了保护网站和数据安全，Web服务器通常具有各种安全功能，例如HTTPS支持，SSL证书配置，身份验证和访问控制等。
  + 日志记录: Web服务器可以记录每个请求的详细信息，包括访问时间，客户端IP地址，请求路径，响应状态等。这些日志对于分析和监视网站流量以及故障排除非常有用。

+ 常见的Web服务器软件包括Apache HTTP Server, Nignx, Microsoft IIS等。他们在性能，可靠性和扩展性方便都有不同的特点，开发人员可以根据实际情况需求选择适合自己的项目的Web服务器。

## 这个webserver并发连接多少

+ 这个取决于具体的Web Server的实现和配置。一般来说，web server可以通过多线程，多进程或异步IO等方式处理并发连接。不同的实现方式和硬件环境都会对并发连接数产生影响。
+ 有些服务器可以处理成千上万并发连接，而另一些可能只能处理几百个。因此，并发连接数是相对灵活可调的，取决于特定情况下所使用的服务器架构和配置。

## 线程池和线程个数怎么设置

+ 配置线程池的大小需要考虑多个因素，包括系统资源，任务类型和负载情况等。以下是一些常见的设置原则：
  + CPU核心数： 通常线程池的大小应该与CPU核心数相近或者略大，这样可以最大程序利用CPU资源
  + 任务类型和执行时间: 如果任务属于I/O密集型，即涉及到等待外部资源(例如网络请求，文件读写等),可以设置较大的线程池来充分利用CPU空闲时间。而对于计算密集型任务，由于存在CPU竞争，适当减少线程池大小可能更高效
  + 内存限制：每个线程都需要一定的内存开销，在确定线程池大小时需要考虑系统可用内存。避免过多线程导致内存耗尽和频繁的内存交换。
  + 平均负载：根据当前系统平均负载情况动态调整线程池大小。例如使用指标如CPU利用率，请求处理速度等来监控系统负载，根据阈值自动调整线程池大小。

+ 总的来说，合理设置线程池大小可以提高程序性能和资源利用率。但是要注意避免过渡设置导致资源浪费或者系统性能下降。

## 线程模型怎么搭配epoll进行使用

+ 在线程模型中，可以使用epoll作为事件驱动的I/O多路复用机制，以提高服务器的并发性能。

+ 一种常见的搭配方式是，使用一个主线程负责监听新连接，并将新连接分配给工作线程处理。具体步骤如下: 
  + 创建一个epoll实例，并设置感兴趣的事件类型(例如可读事件)
  + 在主线程中创建监听套接字，并将其加入到epoll实例中
  + 进入循环，调用epoll_wait()函数等待事件发生。
  + 当有新连接到来时，在主线程中接收连接请求，并根据一定的策略选择一个空闲的工作线程。
  + 将新连接的套接字添加到该工作线程的epoll实例中，并设置相应的回调函数或处理逻辑。
  + 工作线程从自己所属的epoll实例中获取就绪事件，并执行响应的操作(例如读取数据，处理业务逻辑等)
  + 回到第三步，继续等待新事件

+ 这样，通过将连接分配给不同的工作线程进行处理，可以提高系统对并发请求的处理能力。

+ 需要注意以下几点:
  + 主线程只负责监听新连接，不直接处理具体请求。工作线程才是真正处理业务逻辑和响应客户端请求的地方
  + 每个工作线程都需要拥有自己的epoll实例，以避免竞争和阻塞。每个工作线程独立负责处理自己所分配的连接
  + 在具体实现时，还需要考虑连接管理，线程池，数据同步等方面的细节。

+ 以上是一种常见的搭配方式，根据实际情况和需求，也可以选择其他线程模型(例如多线程，异步IO等)结合epoll使用。

## 怎么理解io多路服用

+ IO多路复用是一种通过同时监听多个IO事件的机制，使得一个进程能够同时处理多个IO请求。他利用操作系统提供的select, poll, epoll等函数，在一个线程内监听多个文件描述符(socket)上是否有数据刻度或可写，从而避免了使用多线程或多进程来处理并发IO请求的开销。

+ 通过IO多路复用，可以将大量的网络连接集中到少数几个线程或进程上进行管理和处理，提供了系统的并发性能。当某个文件描述符就绪时(例如有数据可读)，应用程序会得到通知并可以立即对其进行读取操作，这样就能更高效地利用CPU资源

## epoll的边沿触发和水平触发

+ 在Linux中，epoll是一种高效的I/O事件通知机制。他提供了两种触发模式：边沿触发(Edge Triggered)和水平触发(Level Triggered)

+ 边沿触发(Edge Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，只会触发一次通知
  + 如果不立即处理该事件，下次调用epoll_wait()时将不再返回该事件直到有新的事件再次发生。
  + 边缘触发适合于非阻塞的，以消息为单位进行处理的场景

+ 水平触发(Level Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，如果没有处理完全部数据，下次调用epoll_wait()时仍然会返回该事件
  + 直到该文件描述符上没有待处理的数据或者被关闭才不再返回该事件
  + 水平触发适合于阻塞式，基于流的传输协议，例如TCP

+ 选择使用边沿触发还是水平触发取决于具体场景和应用需求。一般来说，在高并发且非阻塞的网络服务器中，边缘触发能够更好地控制事件通知频率和减少无效循环检查。而对于普通应用程序或者阻塞式的IO操作，水平触发则是更常见和常用的模式。

## 两种模式都使用过吗？两种使用起来有什么区别吗？

+ 边缘触发(Edge Triggered)模式和水平触发(Level Triggered)模式是在事件驱动系统中常见的两种触发方式

+ 区别：
  + 边缘触发模式：当输入信号从低电平变为高电平或从高电平变为低电平时，会产生一个触发事件只有在状态改变瞬间才会触发事件例如，边缘触发模式可用于处理硬件中断信号。
  + 水平触发模式：只要输入信号保持在指定的电平上，就会持续触发事。无论输入信号处于何种状态，只要满足条件就会持续触发事件。例如，在网络编程中，水平触发模式可用于处理socket数据的读取。

+ 总体而言，边缘触发更适合处理瞬时状态变化的场景，而水平触发则更适合连续性地监测和响应特定状态。

## 有观察过这两种的区别从连接到数据

+ 边缘触发(Edge Triggered)和水平触发(Level Triggered)是指从数字电子系统中用于触发事件的不同方式。

+ 在边缘触发模式下，只有在输入信号的状态从低电平到高电平或者从高电平到低电平的瞬间时，才会触发事件。换句话说，只有在信号变化的边缘时刻才会被触发

+ 而在水平触发模式下，只要输入信号保持为高电平或者低电平状态，就会持续地产生触发事件。无论输入信号是否有变化，在达到预设的水平时都会触发事件。

+ 区别主要体现在连接和传输数据方面：
  + 连接：对于边缘触发模式，通常需要一个外部时钟或者专门的边缘检测器来监测输入信号的变化，并将结果传递给系统。而水平触发模式则可以直接使用输入信号作为事件的条件。
  + 传输数据：在边缘触发模式下，当边缘变化时彩绘进行数据传输。而在水平触发模式下，一旦满足了预设条件，数据传输就会立即开始。

## 有观察过HTTP的包吗

+ HTTP(Hypertext Transfer Protocol)是一种用于在Web浏览器和Web服务器之间传输数据的协议。通过分析HTTP包，我们可以了解请求和响应的头部信息，请求方法，URL，状态买等内容，以及实际传输的数据。这对于网络调试，安全分析和性能优化都非常有用。

## 有看过HTTP的报文的头吗

+ HTTP报文的头部包含了一些重要的信息。通常有以下几个常见的头字段
  + 请求行：包含了请求方法（GET，POST等），URI路径和HTTP协议版本。
  + 响应行：包含了响应状态码和对应的状态描述
  + 请求头：包含了客户端向服务器发送请求时附带的各种信息，例如User-Agent, Accept,Content-Type等
  + 响应头：包含了服务器返回给客户端的响应相关信息，例如Server,Content-Type,Content-Length等。
  + 实体头：包含了实体主体部分(可选)的附加信息，例如Content-Encoding, Last-Modified等。

+ 通过解析这些报文头部可以获得请求或响应的相关信息，以便进行适当的处理和解析。

## 除了GET和POST，其他方法见过吗？

+ 除了常见的GET和POST方法，还有一些其他HTTP请求方法，例如：
  + PUT： 用于创建或更新资源。通常用于向服务器发送数据，并将其存储在指定的URI下
  + DELETE： 用于删除指定的资源
  + PATCH： 用于部分更新资源，与PUT不同，PATCH仅对资源进行部分更改
  + HEAD： 类似于GET请求，但是只返回响应头信息，而不返回实际内容
  + OPTIONS： 获取目标URL所支持的通信选项

+ 这些是HTTP协议中常见的一些请求方法。具体使用哪个方法取决于你要实现的功能和服务端的支持请求

## GET和POST有什么区别吗

+ GET和POST是HTTP协议中两种常见的请求方法，他们在以下几个方面有区别：
  + 参数传递方式：GET请求通过URL参数传递数据，参数会附加在URL的末尾；而POST请求将数据放在请求体中进行传递，不会显示在URL上
  + 数据大小限制：由于GET请求将参数暴露在URL上，因此对于数据大小有限制。而POST请求没有明确的大小限制，可以传递大量的数据
  + 安装性：由于GET请求参数直接暴露在URL上，所以相对来说比较不安全，容易被拦截和篡改。POST请求把参数放在请求体中，相对更安全一些
  + 缓存机制：GET请求默认可缓存结果，浏览器会缓存返回的页面或资源；而POST请求默认不可缓存。

## URL组成，uri是什么

+ URL(Uniform Resource Locator)是统一资源定位符的缩写，他是用来标识和定位互联网上资源的字符串。一个完整的URL通常包括以下几个部分：
  + 协议(Protocol)： 表示要使用的传输协议，例如HTTP， HTTPS，FTP等
  + 主机名(Hostname)： 表示资源所在的主机或服务器的名称
  + 端口号(Port number)： 可选项，指定访问服务器时所使用的端口号，默认根据协议自动确定。
  + 路径(Path)： 指示服务器上特定资源的路径或位置
  + 查询参数(Query parameters)： 可选项，用于传递额外的参数给服务器
  + 锚点(Anchor)：可选项，在HTML中使用锚点进行页面内导航

+ URI(Uniform Resource Identifier)是统一资源标识符的缩写，他是一个用来唯一标识和引用某个资源的字符串。URI包括两种形式：
  + URL(Uniform Resource Locator),可以被用来直接访问并获取某个资源
  + URN(Uniform Resource Name)，仅用于标识资源而不提供直接访问

+ 因此，URI是URL和URN的总称

## 线程池用到哪些线程间通讯

+ 线程池通常使用以下几种线程间通讯方式：
  + 任务队列(Task Queue)： 线程池中的线程从任务队列中获取待执行的任务。通过将任务放入任务队列，可以实现生产者-消费者模型，在多个线程之间传递任务
  + 线程同步机制：在多个工作线程同时处理任务时，可能需要使用互斥锁，条件变量等线程同步机制来保证数据的一致性和避免竞态条件
  + 回调函数(Callback)：当一个任务完成后，可以通过回调函数将结果返回给调用方或者通知其他相关的模块
  + 线程间信号量(Thread Synchronization Primitives)： 通过信号量等同步原语，可以实现多个线程之间的协调和控制
  + 共享内存(Shared Memory)：多个线程可以通过共享内存在进行数据交换，但需要注意对共享数据的访问控制，以避免竞态条件

+ 这些通讯方式可以帮助线程池中的线程协作执行任务，并且能够有效地管理和分配工作负载。具体使用哪种通讯方式取决于应用程序的需求和设计

## C++类型转化

+ 在C++中，类型转换可以通过以下方式进行：
  + 隐式类型转换(Implicit Conversion)：在不需要显示指定的情况下，编译器会自动进行类型转换。例如，将一个整数复制给浮点类型变量时，编译器会自动从整型到浮点型的隐式转换
  + 显式类型转换(Explicit Conversion)：有时需要手动将一个数据类型转换为另一个数据类型。C++提供了几种显示类型转换操作符：
    + static_cast： 用于执行静态类型检查的转换，在合理范围内允许不同但相关的数据类型之间的转换
    + dynamic_cast: 用于执行安全向下造型(downcasting)，主要用于基类和派生类之间的转换
    + const_cast: 用于去除常量属性或者添加常量属性
    + reinterpret_cast: 一种底层强制类型转换，通常用于将指针或引用重新解释为其他指针或引用。

+ 注意，在使用显式类型转换时，请确保转换是安全且符合语义逻辑。错误的使用可能导致运行时错误或未定义行为

## C++中的堆和栈的区别

+ 在C++中，堆(heap)和栈(stack)是两种不同的内存分配方式，它们有以下区别
  + 分配方式：栈上的变量是通过系统自动进行分配和释放的，而堆上的内存则需要手动进行分配和释放。
  + 内存管理：栈内存由编译器自动管理，它在会变量超出作用域时自动释放。而堆内存需要手动分配和释放，在不再使用时必须显式的调用delete或者delete[]进行回收
  + 大小限制：栈通常比较小，并且大小固定，而堆没有固定大小限制，可以动态地分配所需要大小的内存空间
  + 访问速度：由于栈上的变量是连续分配的，因此访问速度相对较快。而堆上的内存分散在各个地址上，访问速度相对较慢
  + 生命周期：栈上的变量生命周期受到作用域控制，当离开作用域时会自动销毁。而堆上的对象在手动释放之前一直存在。

## 指针和引用的区别

+ 指针和引用是C++中的两个重要概念，它们可以用于间接访问对象或变量。下面是他们的区别：
  + 定义和使用方式：指针使用 * 来声明和解引用，而引用使用 & 来声明，不需要解引用
  + 空值：指针可以为空(nullptr)，表示没有指向任何对象或变量，而引用必须始终引用有效的对象
  + 可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象
  + 对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的指；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象
  + 空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。

## 关键字static的使用

+ 关键字 static 在C++中有多种用法，以下是其中几种常见的用法

1. 静态变量(Static Variables) : 在函数内部声明的静态变量具有静态生存期，即他们在整个程序执行期间都存在，并且只会初始化一次

2. 静态成员变量(Static Member Variables) : 静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享，例如：
```cpp
class MyClass {
public:
    static int sharedVariable; // 静态成员变量声明
};

int MyClass::sharedVariable = 10; // 静态成员变量定义

int main() {
    cout << MyClass::sharedVariable << endl; // 访问静态成员变量
    return 0;
}
```

3. 静态成员函数(Static Member Functions) : 静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：
```cpp
class MyClass {
public:
    static void myStaticFunction() { 
        cout << "This is a static member function." << endl;
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态成员函数
    return 0;
}
```

+ 除了以上几种用法，'static' 还可以用于限制变量或函数的作用于为当前文件(称为内部链接)以及在类模板中声明静态数据成员等。具体使用取决于上下文和需求

## webserver出现bug的debug思路

+ 当一个Web服务器出现bug时，以下是一些常见的debug思路：
  + 检查日志：查看服务器日志文件，特别是错误日志，以获取有关bug的更多信息。日志通常会记录请求和响应的详细信息，包括错误消息和异常堆栈跟踪
  + 排查输入数据：检查传递给服务器的输入数据，包括HTTP请求参数，表单数据等。验证输入数据是否符合预期，并确保他们正确解析和处理
  + 分步调试：使用适当的调试工具，在代码中设置断点并逐步执行程序，观察变量值的变化以及程序流程。这可以帮助找到引起bug的特定代码段
  + 异常处理：确保适当地捕获和处理异常。对于抛出异常的部分进行详细调试，并尝试理解异常触发的原因。
  + 代码审查：仔细审查代码逻辑，函数调用和算法实现。检查潜在的逻辑错误，边界情况和不恰当的函数使用
  + 环境配置检查：确认所需软件库和依赖是否正确安装和配置。有时，问题可能与环境相关
  + 测试用例编写：编写针对各种情况的测试用例，包括正常情况和边界条件。这有助于重现bug，并确认修复是否成功
  + 借助工具：使用适当的工具进行性能分析，内存泄漏监测或代码覆盖率分析等。这些工具可以帮助找到隐藏的问题

## linux上ping命令能确认那些内容

+ 在Linux上，使用ping命令可以确认以下内容：
  + 目标主机的可达性：通过发送ICMP Echo请求，ping命令会等待目标主机的回应。如果能够收到回应，则说明目标主机是可达的；否则，表示目标主机不可达。
  + 往返延迟时间（RTT）：ping命令会显示往返延迟时间，也就是从发送请求到接收响应所经过的时间。通过观察RTT可以评估网络的延迟情况。
  + 数据包丢失率：ping命令还会显示数据包丢失率，即发送的请求中未收到响应的比例。高丢包率可能表示网络连接存在问题。
  + TTL（Time to Live）值：每个发送出去的ICMP Echo请求都带有一个TTL值，在经过路由器时逐渐减小。当TTL为0时，路由器将丢弃该数据包并返回一个“Time Exceeded”错误消息。
  + 网络拓扑分析：通过连续向不同IP地址发送ping请求，并观察结果，可以获取一些关于网络拓扑结构和路由路径方面的信息。

+ 这些是ping命令常用来确认的内容，在诊断网络连接和故障排查时非常有用。

## ping的底层实现

+ Ping是一种网络诊断工具，用于测试主机之间的连通性。在底层实现上，Ping使用ICMP协议（Internet Control Message Protocol）来发送探测包并接收目标主机的响应。

+ 具体而言，Ping的底层实现可以分为以下几个步骤：
  + 创建一个原始套接字（Raw Socket）。
  + 构建ICMP报文，其中包括类型字段（通常为8表示请求Echo Request，或0表示回复Echo Reply）、校验和字段、标识符、序列号等信息。
  + 设置IP头部信息，包括源IP地址和目标IP地址。
  + 计算校验和，并将ICMP报文发送到目标主机。
  + 等待目标主机响应，如果收到相应的Echo Reply报文，则表示目标主机可达；如果超时未收到响应，则表示目标主机不可达。
  + 根据收到的响应时间计算往返时间（Round Trip Time, RTT），并显示或记录结果。

+ 需要注意的是，具体操作系统或平台上对Ping命令的实现可能有所差异，但基本原理都是通过ICMP协议进行网络连通性测试。

## C++中map，如果key不存在，使用[]形式遍历能成功吗

+ 在C++中，使用[]操作符形式访问一个map时，如果key不存在，会自动创建该key，并将其与一个默认值关联起来。
+ 因此，遍历一个map并使用[]形式访问时，如果key不存在，会在该位置插入新的键值对。请注意，在使用[]操作符访问时要确保map是可写的（非const）。

## tcp编程常用的api

+ 在C/C++中，进行TCP编程常用的API包括：
  + socket()：创建套接字
  + bind()：将套接字绑定到一个地址和端口
  + listen()：监听传入的连接请求
  + accept()：接受传入的连接请求并返回新的套接字
  + connect()：建立与远程服务器的连接
  + send()/sendto()：发送数据到已连接或未连接的套接字
  + recv()/recvfrom()：从已连接或未连接的套接字接收数据
  + close()：关闭套接字

+ 这些是基本的TCP编程API，可以使用它们来实现TCP服务器和客户端程序

## tcp三次握手、四次挥手

+ TCP三次握手（Three-way Handshake）是建立TCP连接的过程，具体步骤如下：
  + 客户端向服务器发送一个SYN报文段，指示请求建立连接，并选择一个初始序列号。
  + 服务器收到SYN报文段后，回复客户端一个SYN+ACK报文段，表示同意建立连接，并选择自己的初始序列号。
  + 客户端收到服务器的SYN+ACK报文段后，再向服务器发送一个ACK报文段，确认连接建立。此时双方可以开始正式传输数据。

+ TCP四次挥手（Four-way Handshake）是关闭TCP连接的过程，具体步骤如下：
  + 主动关闭方（一般是客户端）发送一个FIN报文段给被动关闭方（一般是服务器），表示要关闭连接。
  + 被动关闭方收到FIN报文段后，回复一个ACK报文段进行确认。
  + 被动关闭方进入TIME_WAIT状态，在等待一段时间（一般为两个最大报文生存时间）后才能彻底关闭连接。
  + 主动关闭方收到ACK报文段后，也进入CLOSED状态。此时连接已经完全关闭。

+ 这样通过三次握手建立连接和四次挥手断开连接，确保了可靠的数据传输和双方对连接状态的准确掌握。

## 输入一个url会出现那些过程

+ 当你输入一个URL（统一资源定位符），通常会经历以下过程：
  + DNS解析：计算机将URL中的域名解析为对应的IP地址，以便进行网络通信。
  + 建立TCP连接：使用IP地址与服务器建立TCP连接，确保可靠的数据传输。
  + 发送HTTP请求：发送HTTP请求报文给服务器，包含请求方法（GET、POST等）、路径、头部信息和可能的请求体。
  + 服务器处理请求：服务器接收到请求后，根据路径找到相应的资源，并执行相关处理逻辑。
  + 返回HTTP响应：服务器将处理结果封装成HTTP响应报文返回给客户端。响应报文包含状态码、头部信息和响应体（可能是HTML、图片、JSON等）。
  + 客户端渲染：客户端接收到响应后，根据响应内容进行页面渲染或其他操作。如果是网页，则浏览器会解析HTML、CSS和JavaScript，并呈现出最终的页面效果。

## 写服务器碰到过死锁吗

+ 死锁在服务器开发中是一个常见的问题。死锁指的是多个线程或进程因为相互等待对方所持有的资源而陷入无限等待的状态。
+ 在服务器编程中，使用多线程或多进程处理并发请求时，如果不正确地管理锁和资源，就容易导致死锁情况的发生。

+ 解决死锁问题可以采取以下几种方法：
  + 避免使用过多的锁：减少并发操作所需要的锁数量，尽量简化代码逻辑。
  + 使用良好的锁策略：合理选择和管理锁，在保证数据安全性的前提下尽量减小临界区范围。
  + 按顺序获取锁：确保每个线程按照相同的顺序获取锁，避免出现循环等待情况。
  + 设置超时时间：为每个请求设置合理的超时时间，并在超时后释放所有占用资源，防止长时间阻塞导致整体性能下降。
  + 使用专门工具进行分析：借助死锁检测工具来识别和解决潜在的死锁问题。

+ 注意，在服务器开发中预防和解决死锁问题需要综合考虑系统架构、并发设计、线程安全等方面，以确保系统的稳定性和性能。

## http和https的区别

+ HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在Web浏览器和服务器之间传输数据的两种协议。
  + 安全性：最显著的区别是安全性。HTTP不加密数据传输，而HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密来保护数据的安全性。
  + 端口号：HTTP默认使用端口号80进行通信，而HTTPS默认使用端口号443进行通信。
  + 数据传输方式：HTTP的数据传输是明文的，可以被拦截并查看内容。而HTTPS通过加密技术保护数据传输，使得拦截者无法轻易解读或修改传输的内容。
  + 证书要求：为了建立HTTPS连接，服务器需要具有数字证书。这个证书由受信任的证书颁发机构（CA）签发，以确认服务器身份和公钥的有效性。

## https的认证是谁认证谁

+ 在 HTTPS 中，认证是由第三方机构颁发的数字证书来实现的。这个机构通常被称为证书颁发机构（Certificate Authority，CA）。
+ 当网站使用 HTTPS 时，它需要向证书颁发机构申请数字证书。证书颁发机构会对网站进行验证，并签发包含公钥及其他信息的数字证书。
+ 当用户访问这个网站时，浏览器会检查该数字证书是否有效并且与域名匹配。如果验证通过，则建立安全连接。如果数字证书无效或不可信，则浏览器会给出警告提示。

+ 因此，HTTPS 认证是由受信任的第三方机构（即证书颁发机构）对网站的身份进行认证，并确保通信过程中数据传输的安全性和完整性。