## 简介

+ C++面试 问题

## 左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么

+ 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。
  + 左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
  + 右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。

+ 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。
  + 纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值
+ 需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。

## 什么是多态

+ 术语--**多态**，指的是有多种形式，因此函数多态允许函数可以有多种形式。
+ 在了解多态之前，需要了解虚函数
  + 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
  + 虚函数是指**一个类中希望重载的成员函数**，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。
  + 而函数重载，是允许参数不同，但函数名相同。函数重载的关键是函数的参数列表--也称为**函数特征标**(`function signature`)。
  + 如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。
  + **C++允许定义名称相同的函数，条件是它们的特征标不同**。如果参数数目和/或参数类型不同，则特征标也不同。
+ 同一代码可以产生不同效果的特点，称为“多态”

## 虚函数和纯虚函数

+ 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
+ 虚函数是C++中用于实现多态(`polymorphism`)的机制，核心理念就是通过基类访问派生类定义的函数。

+ 注意：在普通的虚函数后面加上`=0`，这样就声明了一个纯虚函数(`pure virtual function`)
+ 纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们**派生类都会有这个函数**

+ 在什么情况下使用纯虚函数？
  - 当想在基类中**抽象出一个方法，且该基类只能被继承，而不能被实例化时**
  - 这个方法**必须在派生类中被实现**
+ 如果满足以上两点，可以考虑将该方法被声明为纯虚函数

+ 当一个类打算被用作其他类的基类时，**它的析构函数必须是虚的**

## 引用和指针的区别

+ 引用变量
  - 引用是已定义的变量的别名（另一个名称）
  - 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的
  - `int rats; int & rodents = rats;  // make rodents an alias for rate`
  - 其中，`&`不是地址运算符，而是类型标识符的一部分。就像声明中的`char*`指的是指向`char`的指针一样，`int&`指的是指向int的引用。
  + 引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量

+ 指针
  - 指针，是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元

+ 区别：
  + 指针是存储变量地址的变量；引用是变量的别名。
  + 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错
  + 指针变量定义时可以初始化为NULL；引用不能初始化为NULL，不然报错。
  + const修饰指针变量，const放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const修饰引用，const放在&之前，不能修改引用所表示的变量的值；const放在&之后，const的作用被忽略，可以修改引用所表示的变量的值。
  + 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名
  + sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
  + 指针可以有多级，引用只有一级。
  + 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。

## 静态链接库与动态链接库

+ 静态链接库：
  + 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
  + 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
  + 创建静态库需要用到一个工具:`AR`

+ 动态链接库：
  + 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
  + 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**

## 静态链接库与动态链接库的区别

静态链接库和动态链接库是两种不同类型的库文件，它们在软件开发中扮演着不同的角色，并且具有一些显著的区别：

### 静态链接库（Static Linking Library）：

1. **链接方式**：
   - **编译时链接**：静态链接库在编译时被链接到可执行文件中，将库的代码和可执行文件合并为一个单独的可执行文件。

2. **文件格式**：
   - **文件大小**：相对较大，因为它包含了被调用的库的完整副本。
   - **扩展名**：通常是`.lib`（在Windows平台）或`.a`（在Unix/Linux平台）。

3. **运行时**：
   - **独立性**：生成的可执行文件独立运行，不需要外部依赖。
   - **移植性**：可能导致较大的可执行文件，并且需要在每个使用相同静态库的应用程序中重新链接和更新。

### 动态链接库（Dynamic Linking Library）：

1. **链接方式**：
   - **运行时链接**：动态链接库在程序运行时被加载到内存中，并且可以被多个程序共享使用。

2. **文件格式**：
   - **文件大小**：相对较小，因为它包含了可共享的代码和数据，被多个程序共享使用。
   - **扩展名**：通常是`.dll`（在Windows平台）或`.so`（在Unix/Linux平台）。

3. **运行时**：
   - **依赖性**：程序在运行时需要正确的动态链接库存在，否则会出现运行错误。
   - **更新和维护**：修改动态链接库可能影响多个程序，但是可以通过单独更新库文件来修复或升级功能，不需要重新编译整个程序。

### 总结区别：

- **静态链接库**在编译时将代码和数据合并到可执行文件中，使得程序独立运行，但增加了可执行文件的大小和每个应用的维护负担。
- **动态链接库**在运行时被加载到内存中，多个程序可以共享它，减少了磁盘空间和内存的占用，但程序需要确保相应的库在运行时存在。

在实际开发中，通常会根据具体需求和考虑因素来选择使用静态链接库或动态链接库。

## 简单介绍一下webserver

+ Web服务器是一种软件或者应用程序，负责接收客户端请求并向其提供响应的资源。它充当客户端和后端服务器之间的中介，通过HTTP协议进行通信。

+ Web服务器的主要功能包括
  + 接收和处理客户端请求：Web服务器监听指定的端口，接收来自客户端(例如浏览器)发送的HTTP请求。它解析请求，识别所需资源，并采取适当的操作来响应请求
  + 资源管理：Web服务器负责管理和提供各种资源，例如HTML文件，图像，CSS样式表，Javascript脚本等。它能够从磁盘上的文件系统中获取这些资源，并将其发送给客户端。
  + 处理动态内容: 除了静态资源外，Web服务器还可以与后端应用程序(例如CGI脚本，PHP脚本，ASP.NET等)交互以生成动态内容。它可以将请求转发给适当的后台处理程序，并将生成的结果返回给客户端。
  + 连接管理: Web服务器需要管理并保持与多个客户端之间的连接。他可以使用不同的策略来处理连接池，线程池或者事件驱动等方式来高效地处理并法请求
  + 安全性和身份验证: 为了保护网站和数据安全，Web服务器通常具有各种安全功能，例如HTTPS支持，SSL证书配置，身份验证和访问控制等。
  + 日志记录: Web服务器可以记录每个请求的详细信息，包括访问时间，客户端IP地址，请求路径，响应状态等。这些日志对于分析和监视网站流量以及故障排除非常有用。

+ 常见的Web服务器软件包括Apache HTTP Server, Nignx, Microsoft IIS等。他们在性能，可靠性和扩展性方便都有不同的特点，开发人员可以根据实际情况需求选择适合自己的项目的Web服务器。

## 这个webserver并发连接多少

+ 这个取决于具体的Web Server的实现和配置。一般来说，web server可以通过多线程，多进程或异步IO等方式处理并发连接。不同的实现方式和硬件环境都会对并发连接数产生影响。
+ 有些服务器可以处理成千上万并发连接，而另一些可能只能处理几百个。因此，并发连接数是相对灵活可调的，取决于特定情况下所使用的服务器架构和配置。

## 线程池和线程个数怎么设置

+ 配置线程池的大小需要考虑多个因素，包括系统资源，任务类型和负载情况等。以下是一些常见的设置原则：
  + CPU核心数： 通常线程池的大小应该与CPU核心数相近或者略大，这样可以最大程序利用CPU资源
  + 任务类型和执行时间: 如果任务属于I/O密集型，即涉及到等待外部资源(例如网络请求，文件读写等),可以设置较大的线程池来充分利用CPU空闲时间。而对于计算密集型任务，由于存在CPU竞争，适当减少线程池大小可能更高效
  + 内存限制：每个线程都需要一定的内存开销，在确定线程池大小时需要考虑系统可用内存。避免过多线程导致内存耗尽和频繁的内存交换。
  + 平均负载：根据当前系统平均负载情况动态调整线程池大小。例如使用指标如CPU利用率，请求处理速度等来监控系统负载，根据阈值自动调整线程池大小。

+ 总的来说，合理设置线程池大小可以提高程序性能和资源利用率。但是要注意避免过渡设置导致资源浪费或者系统性能下降。

## 线程模型怎么搭配epoll进行使用

+ 在线程模型中，可以使用epoll作为事件驱动的I/O多路复用机制，以提高服务器的并发性能。

+ 一种常见的搭配方式是，使用一个主线程负责监听新连接，并将新连接分配给工作线程处理。具体步骤如下: 
  + 创建一个epoll实例，并设置感兴趣的事件类型(例如可读事件)
  + 在主线程中创建监听套接字，并将其加入到epoll实例中
  + 进入循环，调用epoll_wait()函数等待事件发生。
  + 当有新连接到来时，在主线程中接收连接请求，并根据一定的策略选择一个空闲的工作线程。
  + 将新连接的套接字添加到该工作线程的epoll实例中，并设置相应的回调函数或处理逻辑。
  + 工作线程从自己所属的epoll实例中获取就绪事件，并执行响应的操作(例如读取数据，处理业务逻辑等)
  + 回到第三步，继续等待新事件

+ 这样，通过将连接分配给不同的工作线程进行处理，可以提高系统对并发请求的处理能力。

+ 需要注意以下几点:
  + 主线程只负责监听新连接，不直接处理具体请求。工作线程才是真正处理业务逻辑和响应客户端请求的地方
  + 每个工作线程都需要拥有自己的epoll实例，以避免竞争和阻塞。每个工作线程独立负责处理自己所分配的连接
  + 在具体实现时，还需要考虑连接管理，线程池，数据同步等方面的细节。

+ 以上是一种常见的搭配方式，根据实际情况和需求，也可以选择其他线程模型(例如多线程，异步IO等)结合epoll使用。

## 怎么理解io多路服用

+ IO多路复用是一种通过同时监听多个IO事件的机制，使得一个进程能够同时处理多个IO请求。他利用操作系统提供的select, poll, epoll等函数，在一个线程内监听多个文件描述符(socket)上是否有数据刻度或可写，从而避免了使用多线程或多进程来处理并发IO请求的开销。

+ 通过IO多路复用，可以将大量的网络连接集中到少数几个线程或进程上进行管理和处理，提供了系统的并发性能。当某个文件描述符就绪时(例如有数据可读)，应用程序会得到通知并可以立即对其进行读取操作，这样就能更高效地利用CPU资源

## epoll的边沿触发和水平触发

+ 在Linux中，epoll是一种高效的I/O事件通知机制。他提供了两种触发模式：边沿触发(Edge Triggered)和水平触发(Level Triggered)

+ 边沿触发(Edge Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，只会触发一次通知
  + 如果不立即处理该事件，下次调用epoll_wait()时将不再返回该事件直到有新的事件再次发生。
  + 边缘触发适合于非阻塞的，以消息为单位进行处理的场景

+ 水平触发(Level Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，如果没有处理完全部数据，下次调用epoll_wait()时仍然会返回该事件
  + 直到该文件描述符上没有待处理的数据或者被关闭才不再返回该事件
  + 水平触发适合于阻塞式，基于流的传输协议，例如TCP

+ 选择使用边沿触发还是水平触发取决于具体场景和应用需求。一般来说，在高并发且非阻塞的网络服务器中，边缘触发能够更好地控制事件通知频率和减少无效循环检查。而对于普通应用程序或者阻塞式的IO操作，水平触发则是更常见和常用的模式。

## 两种模式都使用过吗？两种使用起来有什么区别吗？

+ 边缘触发(Edge Triggered)模式和水平触发(Level Triggered)模式是在事件驱动系统中常见的两种触发方式

+ 区别：
  + 边缘触发模式：当输入信号从低电平变为高电平或从高电平变为低电平时，会产生一个触发事件只有在状态改变瞬间才会触发事件例如，边缘触发模式可用于处理硬件中断信号。
  + 水平触发模式：只要输入信号保持在指定的电平上，就会持续触发事。无论输入信号处于何种状态，只要满足条件就会持续触发事件。例如，在网络编程中，水平触发模式可用于处理socket数据的读取。

+ 总体而言，边缘触发更适合处理瞬时状态变化的场景，而水平触发则更适合连续性地监测和响应特定状态。

## 有观察过这两种的区别从连接到数据

+ 边缘触发(Edge Triggered)和水平触发(Level Triggered)是指从数字电子系统中用于触发事件的不同方式。

+ 在边缘触发模式下，只有在输入信号的状态从低电平到高电平或者从高电平到低电平的瞬间时，才会触发事件。换句话说，只有在信号变化的边缘时刻才会被触发

+ 而在水平触发模式下，只要输入信号保持为高电平或者低电平状态，就会持续地产生触发事件。无论输入信号是否有变化，在达到预设的水平时都会触发事件。

+ 区别主要体现在连接和传输数据方面：
  + 连接：对于边缘触发模式，通常需要一个外部时钟或者专门的边缘检测器来监测输入信号的变化，并将结果传递给系统。而水平触发模式则可以直接使用输入信号作为事件的条件。
  + 传输数据：在边缘触发模式下，当边缘变化时彩绘进行数据传输。而在水平触发模式下，一旦满足了预设条件，数据传输就会立即开始。

## 有观察过HTTP的包吗

+ HTTP(Hypertext Transfer Protocol)是一种用于在Web浏览器和Web服务器之间传输数据的协议。通过分析HTTP包，我们可以了解请求和响应的头部信息，请求方法，URL，状态买等内容，以及实际传输的数据。这对于网络调试，安全分析和性能优化都非常有用。

## 有看过HTTP的报文的头吗

+ HTTP报文的头部包含了一些重要的信息。通常有以下几个常见的头字段
  + 请求行：包含了请求方法（GET，POST等），URI路径和HTTP协议版本。
  + 响应行：包含了响应状态码和对应的状态描述
  + 请求头：包含了客户端向服务器发送请求时附带的各种信息，例如User-Agent, Accept,Content-Type等
  + 响应头：包含了服务器返回给客户端的响应相关信息，例如Server,Content-Type,Content-Length等。
  + 实体头：包含了实体主体部分(可选)的附加信息，例如Content-Encoding, Last-Modified等。

+ 通过解析这些报文头部可以获得请求或响应的相关信息，以便进行适当的处理和解析。