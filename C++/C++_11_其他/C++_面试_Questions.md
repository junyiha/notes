## 简介

+ C++面试 问题

## 左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么

+ 要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。
  + 左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
  + 右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。

+ 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。
  + 纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值
+ 需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。

## 什么是多态

+ 术语--**多态**，指的是有多种形式，因此函数多态允许函数可以有多种形式。
+ 在了解多态之前，需要了解虚函数
  + 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
  + 虚函数是指**一个类中希望重载的成员函数**，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。
  + 而函数重载，是允许参数不同，但函数名相同。函数重载的关键是函数的参数列表--也称为**函数特征标**(`function signature`)。
  + 如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。
  + **C++允许定义名称相同的函数，条件是它们的特征标不同**。如果参数数目和/或参数类型不同，则特征标也不同。
+ 同一代码可以产生不同效果的特点，称为“多态”

## 虚函数和纯虚函数

+ 虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，**由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数**
+ 虚函数是C++中用于实现多态(`polymorphism`)的机制，核心理念就是通过基类访问派生类定义的函数。

+ 注意：在普通的虚函数后面加上`=0`，这样就声明了一个纯虚函数(`pure virtual function`)
+ 纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们**派生类都会有这个函数**

+ 在什么情况下使用纯虚函数？
  - 当想在基类中**抽象出一个方法，且该基类只能被继承，而不能被实例化时**
  - 这个方法**必须在派生类中被实现**
+ 如果满足以上两点，可以考虑将该方法被声明为纯虚函数

+ 当一个类打算被用作其他类的基类时，**它的析构函数必须是虚的**

## 引用和指针的区别

+ 引用变量
  - 引用是已定义的变量的别名（另一个名称）
  - 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的
  - `int rats; int & rodents = rats;  // make rodents an alias for rate`
  - 其中，`&`不是地址运算符，而是类型标识符的一部分。就像声明中的`char*`指的是指向`char`的指针一样，`int&`指的是指向int的引用。
  + 引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量

+ 指针
  - 指针，是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元

+ 区别：
  + 指针是存储变量地址的变量；引用是变量的别名。
  + 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错
  + 指针变量定义时可以初始化为NULL；引用不能初始化为NULL，不然报错。
  + const修饰指针变量，const放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const修饰引用，const放在&之前，不能修改引用所表示的变量的值；const放在&之后，const的作用被忽略，可以修改引用所表示的变量的值。
  + 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名
  + sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
  + 指针可以有多级，引用只有一级。
  + 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。

## 静态链接库与动态链接库

+ 静态链接库：
  + 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
  + 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
  + 创建静态库需要用到一个工具:`AR`

+ 动态链接库：
  + 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
  + 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**

## 静态链接库与动态链接库的区别

静态链接库和动态链接库是两种不同类型的库文件，它们在软件开发中扮演着不同的角色，并且具有一些显著的区别：

### 静态链接库（Static Linking Library）：

1. **链接方式**：
   - **编译时链接**：静态链接库在编译时被链接到可执行文件中，将库的代码和可执行文件合并为一个单独的可执行文件。

2. **文件格式**：
   - **文件大小**：相对较大，因为它包含了被调用的库的完整副本。
   - **扩展名**：通常是`.lib`（在Windows平台）或`.a`（在Unix/Linux平台）。

3. **运行时**：
   - **独立性**：生成的可执行文件独立运行，不需要外部依赖。
   - **移植性**：可能导致较大的可执行文件，并且需要在每个使用相同静态库的应用程序中重新链接和更新。

### 动态链接库（Dynamic Linking Library）：

1. **链接方式**：
   - **运行时链接**：动态链接库在程序运行时被加载到内存中，并且可以被多个程序共享使用。

2. **文件格式**：
   - **文件大小**：相对较小，因为它包含了可共享的代码和数据，被多个程序共享使用。
   - **扩展名**：通常是`.dll`（在Windows平台）或`.so`（在Unix/Linux平台）。

3. **运行时**：
   - **依赖性**：程序在运行时需要正确的动态链接库存在，否则会出现运行错误。
   - **更新和维护**：修改动态链接库可能影响多个程序，但是可以通过单独更新库文件来修复或升级功能，不需要重新编译整个程序。

### 总结区别：

- **静态链接库**在编译时将代码和数据合并到可执行文件中，使得程序独立运行，但增加了可执行文件的大小和每个应用的维护负担。
- **动态链接库**在运行时被加载到内存中，多个程序可以共享它，减少了磁盘空间和内存的占用，但程序需要确保相应的库在运行时存在。

在实际开发中，通常会根据具体需求和考虑因素来选择使用静态链接库或动态链接库。

## 简单介绍一下webserver

+ Web服务器是一种软件或者应用程序，负责接收客户端请求并向其提供响应的资源。它充当客户端和后端服务器之间的中介，通过HTTP协议进行通信。

+ Web服务器的主要功能包括
  + 接收和处理客户端请求：Web服务器监听指定的端口，接收来自客户端(例如浏览器)发送的HTTP请求。它解析请求，识别所需资源，并采取适当的操作来响应请求
  + 资源管理：Web服务器负责管理和提供各种资源，例如HTML文件，图像，CSS样式表，Javascript脚本等。它能够从磁盘上的文件系统中获取这些资源，并将其发送给客户端。
  + 处理动态内容: 除了静态资源外，Web服务器还可以与后端应用程序(例如CGI脚本，PHP脚本，ASP.NET等)交互以生成动态内容。它可以将请求转发给适当的后台处理程序，并将生成的结果返回给客户端。
  + 连接管理: Web服务器需要管理并保持与多个客户端之间的连接。他可以使用不同的策略来处理连接池，线程池或者事件驱动等方式来高效地处理并法请求
  + 安全性和身份验证: 为了保护网站和数据安全，Web服务器通常具有各种安全功能，例如HTTPS支持，SSL证书配置，身份验证和访问控制等。
  + 日志记录: Web服务器可以记录每个请求的详细信息，包括访问时间，客户端IP地址，请求路径，响应状态等。这些日志对于分析和监视网站流量以及故障排除非常有用。

+ 常见的Web服务器软件包括Apache HTTP Server, Nignx, Microsoft IIS等。他们在性能，可靠性和扩展性方便都有不同的特点，开发人员可以根据实际情况需求选择适合自己的项目的Web服务器。

## 这个webserver并发连接多少

+ 这个取决于具体的Web Server的实现和配置。一般来说，web server可以通过多线程，多进程或异步IO等方式处理并发连接。不同的实现方式和硬件环境都会对并发连接数产生影响。
+ 有些服务器可以处理成千上万并发连接，而另一些可能只能处理几百个。因此，并发连接数是相对灵活可调的，取决于特定情况下所使用的服务器架构和配置。

## 线程池和线程个数怎么设置

+ 配置线程池的大小需要考虑多个因素，包括系统资源，任务类型和负载情况等。以下是一些常见的设置原则：
  + CPU核心数： 通常线程池的大小应该与CPU核心数相近或者略大，这样可以最大程序利用CPU资源
  + 任务类型和执行时间: 如果任务属于I/O密集型，即涉及到等待外部资源(例如网络请求，文件读写等),可以设置较大的线程池来充分利用CPU空闲时间。而对于计算密集型任务，由于存在CPU竞争，适当减少线程池大小可能更高效
  + 内存限制：每个线程都需要一定的内存开销，在确定线程池大小时需要考虑系统可用内存。避免过多线程导致内存耗尽和频繁的内存交换。
  + 平均负载：根据当前系统平均负载情况动态调整线程池大小。例如使用指标如CPU利用率，请求处理速度等来监控系统负载，根据阈值自动调整线程池大小。

+ 总的来说，合理设置线程池大小可以提高程序性能和资源利用率。但是要注意避免过渡设置导致资源浪费或者系统性能下降。

## 线程模型怎么搭配epoll进行使用

+ 在线程模型中，可以使用epoll作为事件驱动的I/O多路复用机制，以提高服务器的并发性能。

+ 一种常见的搭配方式是，使用一个主线程负责监听新连接，并将新连接分配给工作线程处理。具体步骤如下: 
  + 创建一个epoll实例，并设置感兴趣的事件类型(例如可读事件)
  + 在主线程中创建监听套接字，并将其加入到epoll实例中
  + 进入循环，调用epoll_wait()函数等待事件发生。
  + 当有新连接到来时，在主线程中接收连接请求，并根据一定的策略选择一个空闲的工作线程。
  + 将新连接的套接字添加到该工作线程的epoll实例中，并设置相应的回调函数或处理逻辑。
  + 工作线程从自己所属的epoll实例中获取就绪事件，并执行响应的操作(例如读取数据，处理业务逻辑等)
  + 回到第三步，继续等待新事件

+ 这样，通过将连接分配给不同的工作线程进行处理，可以提高系统对并发请求的处理能力。

+ 需要注意以下几点:
  + 主线程只负责监听新连接，不直接处理具体请求。工作线程才是真正处理业务逻辑和响应客户端请求的地方
  + 每个工作线程都需要拥有自己的epoll实例，以避免竞争和阻塞。每个工作线程独立负责处理自己所分配的连接
  + 在具体实现时，还需要考虑连接管理，线程池，数据同步等方面的细节。

+ 以上是一种常见的搭配方式，根据实际情况和需求，也可以选择其他线程模型(例如多线程，异步IO等)结合epoll使用。

## 怎么理解io多路服用

+ IO多路复用是一种通过同时监听多个IO事件的机制，使得一个进程能够同时处理多个IO请求。他利用操作系统提供的select, poll, epoll等函数，在一个线程内监听多个文件描述符(socket)上是否有数据刻度或可写，从而避免了使用多线程或多进程来处理并发IO请求的开销。

+ 通过IO多路复用，可以将大量的网络连接集中到少数几个线程或进程上进行管理和处理，提供了系统的并发性能。当某个文件描述符就绪时(例如有数据可读)，应用程序会得到通知并可以立即对其进行读取操作，这样就能更高效地利用CPU资源

## epoll的边沿触发和水平触发

+ 在Linux中，epoll是一种高效的I/O事件通知机制。他提供了两种触发模式：边沿触发(Edge Triggered)和水平触发(Level Triggered)

+ 边沿触发(Edge Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，只会触发一次通知
  + 如果不立即处理该事件，下次调用epoll_wait()时将不再返回该事件直到有新的事件再次发生。
  + 边缘触发适合于非阻塞的，以消息为单位进行处理的场景

+ 水平触发(Level Triggered)模式：
  + 当文件描述符上有可读/可写事件发生时，如果没有处理完全部数据，下次调用epoll_wait()时仍然会返回该事件
  + 直到该文件描述符上没有待处理的数据或者被关闭才不再返回该事件
  + 水平触发适合于阻塞式，基于流的传输协议，例如TCP

+ 选择使用边沿触发还是水平触发取决于具体场景和应用需求。一般来说，在高并发且非阻塞的网络服务器中，边缘触发能够更好地控制事件通知频率和减少无效循环检查。而对于普通应用程序或者阻塞式的IO操作，水平触发则是更常见和常用的模式。

## 两种模式都使用过吗？两种使用起来有什么区别吗？

+ 边缘触发(Edge Triggered)模式和水平触发(Level Triggered)模式是在事件驱动系统中常见的两种触发方式

+ 区别：
  + 边缘触发模式：当输入信号从低电平变为高电平或从高电平变为低电平时，会产生一个触发事件只有在状态改变瞬间才会触发事件例如，边缘触发模式可用于处理硬件中断信号。
  + 水平触发模式：只要输入信号保持在指定的电平上，就会持续触发事。无论输入信号处于何种状态，只要满足条件就会持续触发事件。例如，在网络编程中，水平触发模式可用于处理socket数据的读取。

+ 总体而言，边缘触发更适合处理瞬时状态变化的场景，而水平触发则更适合连续性地监测和响应特定状态。

## 有观察过这两种的区别从连接到数据

+ 边缘触发(Edge Triggered)和水平触发(Level Triggered)是指从数字电子系统中用于触发事件的不同方式。

+ 在边缘触发模式下，只有在输入信号的状态从低电平到高电平或者从高电平到低电平的瞬间时，才会触发事件。换句话说，只有在信号变化的边缘时刻才会被触发

+ 而在水平触发模式下，只要输入信号保持为高电平或者低电平状态，就会持续地产生触发事件。无论输入信号是否有变化，在达到预设的水平时都会触发事件。

+ 区别主要体现在连接和传输数据方面：
  + 连接：对于边缘触发模式，通常需要一个外部时钟或者专门的边缘检测器来监测输入信号的变化，并将结果传递给系统。而水平触发模式则可以直接使用输入信号作为事件的条件。
  + 传输数据：在边缘触发模式下，当边缘变化时彩绘进行数据传输。而在水平触发模式下，一旦满足了预设条件，数据传输就会立即开始。

## 有观察过HTTP的包吗

+ HTTP(Hypertext Transfer Protocol)是一种用于在Web浏览器和Web服务器之间传输数据的协议。通过分析HTTP包，我们可以了解请求和响应的头部信息，请求方法，URL，状态买等内容，以及实际传输的数据。这对于网络调试，安全分析和性能优化都非常有用。

## 有看过HTTP的报文的头吗

+ HTTP报文的头部包含了一些重要的信息。通常有以下几个常见的头字段
  + 请求行：包含了请求方法（GET，POST等），URI路径和HTTP协议版本。
  + 响应行：包含了响应状态码和对应的状态描述
  + 请求头：包含了客户端向服务器发送请求时附带的各种信息，例如User-Agent, Accept,Content-Type等
  + 响应头：包含了服务器返回给客户端的响应相关信息，例如Server,Content-Type,Content-Length等。
  + 实体头：包含了实体主体部分(可选)的附加信息，例如Content-Encoding, Last-Modified等。

+ 通过解析这些报文头部可以获得请求或响应的相关信息，以便进行适当的处理和解析。

## 除了GET和POST，其他方法见过吗？

+ 除了常见的GET和POST方法，还有一些其他HTTP请求方法，例如：
  + PUT： 用于创建或更新资源。通常用于向服务器发送数据，并将其存储在指定的URI下
  + DELETE： 用于删除指定的资源
  + PATCH： 用于部分更新资源，与PUT不同，PATCH仅对资源进行部分更改
  + HEAD： 类似于GET请求，但是只返回响应头信息，而不返回实际内容
  + OPTIONS： 获取目标URL所支持的通信选项

+ 这些是HTTP协议中常见的一些请求方法。具体使用哪个方法取决于你要实现的功能和服务端的支持请求

## GET和POST有什么区别吗

+ GET和POST是HTTP协议中两种常见的请求方法，他们在以下几个方面有区别：
  + 参数传递方式：GET请求通过URL参数传递数据，参数会附加在URL的末尾；而POST请求将数据放在请求体中进行传递，不会显示在URL上
  + 数据大小限制：由于GET请求将参数暴露在URL上，因此对于数据大小有限制。而POST请求没有明确的大小限制，可以传递大量的数据
  + 安装性：由于GET请求参数直接暴露在URL上，所以相对来说比较不安全，容易被拦截和篡改。POST请求把参数放在请求体中，相对更安全一些
  + 缓存机制：GET请求默认可缓存结果，浏览器会缓存返回的页面或资源；而POST请求默认不可缓存。

## URL组成，uri是什么

+ URL(Uniform Resource Locator)是统一资源定位符的缩写，他是用来标识和定位互联网上资源的字符串。一个完整的URL通常包括以下几个部分：
  + 协议(Protocol)： 表示要使用的传输协议，例如HTTP， HTTPS，FTP等
  + 主机名(Hostname)： 表示资源所在的主机或服务器的名称
  + 端口号(Port number)： 可选项，指定访问服务器时所使用的端口号，默认根据协议自动确定。
  + 路径(Path)： 指示服务器上特定资源的路径或位置
  + 查询参数(Query parameters)： 可选项，用于传递额外的参数给服务器
  + 锚点(Anchor)：可选项，在HTML中使用锚点进行页面内导航

+ URI(Uniform Resource Identifier)是统一资源标识符的缩写，他是一个用来唯一标识和引用某个资源的字符串。URI包括两种形式：
  + URL(Uniform Resource Locator),可以被用来直接访问并获取某个资源
  + URN(Uniform Resource Name)，仅用于标识资源而不提供直接访问

+ 因此，URI是URL和URN的总称

## 线程池用到哪些线程间通讯

+ 线程池通常使用以下几种线程间通讯方式：
  + 任务队列(Task Queue)： 线程池中的线程从任务队列中获取待执行的任务。通过将任务放入任务队列，可以实现生产者-消费者模型，在多个线程之间传递任务
  + 线程同步机制：在多个工作线程同时处理任务时，可能需要使用互斥锁，条件变量等线程同步机制来保证数据的一致性和避免竞态条件
  + 回调函数(Callback)：当一个任务完成后，可以通过回调函数将结果返回给调用方或者通知其他相关的模块
  + 线程间信号量(Thread Synchronization Primitives)： 通过信号量等同步原语，可以实现多个线程之间的协调和控制
  + 共享内存(Shared Memory)：多个线程可以通过共享内存在进行数据交换，但需要注意对共享数据的访问控制，以避免竞态条件

+ 这些通讯方式可以帮助线程池中的线程协作执行任务，并且能够有效地管理和分配工作负载。具体使用哪种通讯方式取决于应用程序的需求和设计

## C++类型转化

+ 在C++中，类型转换可以通过以下方式进行：
  + 隐式类型转换(Implicit Conversion)：在不需要显示指定的情况下，编译器会自动进行类型转换。例如，将一个整数复制给浮点类型变量时，编译器会自动从整型到浮点型的隐式转换
  + 显式类型转换(Explicit Conversion)：有时需要手动将一个数据类型转换为另一个数据类型。C++提供了几种显示类型转换操作符：
    + static_cast： 用于执行静态类型检查的转换，在合理范围内允许不同但相关的数据类型之间的转换
    + dynamic_cast: 用于执行安全向下造型(downcasting)，主要用于基类和派生类之间的转换
    + const_cast: 用于去除常量属性或者添加常量属性
    + reinterpret_cast: 一种底层强制类型转换，通常用于将指针或引用重新解释为其他指针或引用。

+ 注意，在使用显式类型转换时，请确保转换是安全且符合语义逻辑。错误的使用可能导致运行时错误或未定义行为

## C++中的堆和栈的区别

+ 在C++中，堆(heap)和栈(stack)是两种不同的内存分配方式，它们有以下区别
  + 分配方式：栈上的变量是通过系统自动进行分配和释放的，而堆上的内存则需要手动进行分配和释放。
  + 内存管理：栈内存由编译器自动管理，它在会变量超出作用域时自动释放。而堆内存需要手动分配和释放，在不再使用时必须显式的调用delete或者delete[]进行回收
  + 大小限制：栈通常比较小，并且大小固定，而堆没有固定大小限制，可以动态地分配所需要大小的内存空间
  + 访问速度：由于栈上的变量是连续分配的，因此访问速度相对较快。而堆上的内存分散在各个地址上，访问速度相对较慢
  + 生命周期：栈上的变量生命周期受到作用域控制，当离开作用域时会自动销毁。而堆上的对象在手动释放之前一直存在。

## 指针和引用的区别

+ 指针和引用是C++中的两个重要概念，它们可以用于间接访问对象或变量。下面是他们的区别：
  + 定义和使用方式：指针使用 * 来声明和解引用，而引用使用 & 来声明，不需要解引用
  + 空值：指针可以为空(nullptr)，表示没有指向任何对象或变量，而引用必须始终引用有效的对象
  + 可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象
  + 对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的指；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象
  + 空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。

## 关键字static的使用

+ 关键字 static 在C++中有多种用法，以下是其中几种常见的用法

1. 静态变量(Static Variables) : 在函数内部声明的静态变量具有静态生存期，即他们在整个程序执行期间都存在，并且只会初始化一次

2. 静态成员变量(Static Member Variables) : 静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享，例如：
```cpp
class MyClass {
public:
    static int sharedVariable; // 静态成员变量声明
};

int MyClass::sharedVariable = 10; // 静态成员变量定义

int main() {
    cout << MyClass::sharedVariable << endl; // 访问静态成员变量
    return 0;
}
```

3. 静态成员函数(Static Member Functions) : 静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：
```cpp
class MyClass {
public:
    static void myStaticFunction() { 
        cout << "This is a static member function." << endl;
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态成员函数
    return 0;
}
```

+ 除了以上几种用法，'static' 还可以用于限制变量或函数的作用于为当前文件(称为内部链接)以及在类模板中声明静态数据成员等。具体使用取决于上下文和需求

## webserver出现bug的debug思路

+ 当一个Web服务器出现bug时，以下是一些常见的debug思路：
  + 检查日志：查看服务器日志文件，特别是错误日志，以获取有关bug的更多信息。日志通常会记录请求和响应的详细信息，包括错误消息和异常堆栈跟踪
  + 排查输入数据：检查传递给服务器的输入数据，包括HTTP请求参数，表单数据等。验证输入数据是否符合预期，并确保他们正确解析和处理
  + 分步调试：使用适当的调试工具，在代码中设置断点并逐步执行程序，观察变量值的变化以及程序流程。这可以帮助找到引起bug的特定代码段
  + 异常处理：确保适当地捕获和处理异常。对于抛出异常的部分进行详细调试，并尝试理解异常触发的原因。
  + 代码审查：仔细审查代码逻辑，函数调用和算法实现。检查潜在的逻辑错误，边界情况和不恰当的函数使用
  + 环境配置检查：确认所需软件库和依赖是否正确安装和配置。有时，问题可能与环境相关
  + 测试用例编写：编写针对各种情况的测试用例，包括正常情况和边界条件。这有助于重现bug，并确认修复是否成功
  + 借助工具：使用适当的工具进行性能分析，内存泄漏监测或代码覆盖率分析等。这些工具可以帮助找到隐藏的问题

## linux上ping命令能确认那些内容

+ 在Linux上，使用ping命令可以确认以下内容：
  + 目标主机的可达性：通过发送ICMP Echo请求，ping命令会等待目标主机的回应。如果能够收到回应，则说明目标主机是可达的；否则，表示目标主机不可达。
  + 往返延迟时间（RTT）：ping命令会显示往返延迟时间，也就是从发送请求到接收响应所经过的时间。通过观察RTT可以评估网络的延迟情况。
  + 数据包丢失率：ping命令还会显示数据包丢失率，即发送的请求中未收到响应的比例。高丢包率可能表示网络连接存在问题。
  + TTL（Time to Live）值：每个发送出去的ICMP Echo请求都带有一个TTL值，在经过路由器时逐渐减小。当TTL为0时，路由器将丢弃该数据包并返回一个“Time Exceeded”错误消息。
  + 网络拓扑分析：通过连续向不同IP地址发送ping请求，并观察结果，可以获取一些关于网络拓扑结构和路由路径方面的信息。

+ 这些是ping命令常用来确认的内容，在诊断网络连接和故障排查时非常有用。

## ping的底层实现

+ Ping是一种网络诊断工具，用于测试主机之间的连通性。在底层实现上，Ping使用ICMP协议（Internet Control Message Protocol）来发送探测包并接收目标主机的响应。

+ 具体而言，Ping的底层实现可以分为以下几个步骤：
  + 创建一个原始套接字（Raw Socket）。
  + 构建ICMP报文，其中包括类型字段（通常为8表示请求Echo Request，或0表示回复Echo Reply）、校验和字段、标识符、序列号等信息。
  + 设置IP头部信息，包括源IP地址和目标IP地址。
  + 计算校验和，并将ICMP报文发送到目标主机。
  + 等待目标主机响应，如果收到相应的Echo Reply报文，则表示目标主机可达；如果超时未收到响应，则表示目标主机不可达。
  + 根据收到的响应时间计算往返时间（Round Trip Time, RTT），并显示或记录结果。

+ 需要注意的是，具体操作系统或平台上对Ping命令的实现可能有所差异，但基本原理都是通过ICMP协议进行网络连通性测试。

## C++中map，如果key不存在，使用[]形式遍历能成功吗

+ 在C++中，使用[]操作符形式访问一个map时，如果key不存在，会自动创建该key，并将其与一个默认值关联起来。
+ 因此，遍历一个map并使用[]形式访问时，如果key不存在，会在该位置插入新的键值对。请注意，在使用[]操作符访问时要确保map是可写的（非const）。

## tcp编程常用的api

+ 在C/C++中，进行TCP编程常用的API包括：
  + socket()：创建套接字
  + bind()：将套接字绑定到一个地址和端口
  + listen()：监听传入的连接请求
  + accept()：接受传入的连接请求并返回新的套接字
  + connect()：建立与远程服务器的连接
  + send()/sendto()：发送数据到已连接或未连接的套接字
  + recv()/recvfrom()：从已连接或未连接的套接字接收数据
  + close()：关闭套接字

+ 这些是基本的TCP编程API，可以使用它们来实现TCP服务器和客户端程序

## tcp三次握手、四次挥手

+ TCP三次握手（Three-way Handshake）是建立TCP连接的过程，具体步骤如下：
  + 客户端向服务器发送一个SYN报文段，指示请求建立连接，并选择一个初始序列号。
  + 服务器收到SYN报文段后，回复客户端一个SYN+ACK报文段，表示同意建立连接，并选择自己的初始序列号。
  + 客户端收到服务器的SYN+ACK报文段后，再向服务器发送一个ACK报文段，确认连接建立。此时双方可以开始正式传输数据。

+ TCP四次挥手（Four-way Handshake）是关闭TCP连接的过程，具体步骤如下：
  + 主动关闭方（一般是客户端）发送一个FIN报文段给被动关闭方（一般是服务器），表示要关闭连接。
  + 被动关闭方收到FIN报文段后，回复一个ACK报文段进行确认。
  + 被动关闭方进入TIME_WAIT状态，在等待一段时间（一般为两个最大报文生存时间）后才能彻底关闭连接。
  + 主动关闭方收到ACK报文段后，也进入CLOSED状态。此时连接已经完全关闭。

+ 这样通过三次握手建立连接和四次挥手断开连接，确保了可靠的数据传输和双方对连接状态的准确掌握。

## 输入一个url会出现那些过程

+ 当你输入一个URL（统一资源定位符），通常会经历以下过程：
  + DNS解析：计算机将URL中的域名解析为对应的IP地址，以便进行网络通信。
  + 建立TCP连接：使用IP地址与服务器建立TCP连接，确保可靠的数据传输。
  + 发送HTTP请求：发送HTTP请求报文给服务器，包含请求方法（GET、POST等）、路径、头部信息和可能的请求体。
  + 服务器处理请求：服务器接收到请求后，根据路径找到相应的资源，并执行相关处理逻辑。
  + 返回HTTP响应：服务器将处理结果封装成HTTP响应报文返回给客户端。响应报文包含状态码、头部信息和响应体（可能是HTML、图片、JSON等）。
  + 客户端渲染：客户端接收到响应后，根据响应内容进行页面渲染或其他操作。如果是网页，则浏览器会解析HTML、CSS和JavaScript，并呈现出最终的页面效果。

## 写服务器碰到过死锁吗

+ 死锁在服务器开发中是一个常见的问题。死锁指的是多个线程或进程因为相互等待对方所持有的资源而陷入无限等待的状态。
+ 在服务器编程中，使用多线程或多进程处理并发请求时，如果不正确地管理锁和资源，就容易导致死锁情况的发生。

+ 解决死锁问题可以采取以下几种方法：
  + 避免使用过多的锁：减少并发操作所需要的锁数量，尽量简化代码逻辑。
  + 使用良好的锁策略：合理选择和管理锁，在保证数据安全性的前提下尽量减小临界区范围。
  + 按顺序获取锁：确保每个线程按照相同的顺序获取锁，避免出现循环等待情况。
  + 设置超时时间：为每个请求设置合理的超时时间，并在超时后释放所有占用资源，防止长时间阻塞导致整体性能下降。
  + 使用专门工具进行分析：借助死锁检测工具来识别和解决潜在的死锁问题。

+ 注意，在服务器开发中预防和解决死锁问题需要综合考虑系统架构、并发设计、线程安全等方面，以确保系统的稳定性和性能。

## http和https的区别

+ HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在Web浏览器和服务器之间传输数据的两种协议。
  + 安全性：最显著的区别是安全性。HTTP不加密数据传输，而HTTPS通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密来保护数据的安全性。
  + 端口号：HTTP默认使用端口号80进行通信，而HTTPS默认使用端口号443进行通信。
  + 数据传输方式：HTTP的数据传输是明文的，可以被拦截并查看内容。而HTTPS通过加密技术保护数据传输，使得拦截者无法轻易解读或修改传输的内容。
  + 证书要求：为了建立HTTPS连接，服务器需要具有数字证书。这个证书由受信任的证书颁发机构（CA）签发，以确认服务器身份和公钥的有效性。

## https的认证是谁认证谁

+ 在 HTTPS 中，认证是由第三方机构颁发的数字证书来实现的。这个机构通常被称为证书颁发机构（Certificate Authority，CA）。
+ 当网站使用 HTTPS 时，它需要向证书颁发机构申请数字证书。证书颁发机构会对网站进行验证，并签发包含公钥及其他信息的数字证书。
+ 当用户访问这个网站时，浏览器会检查该数字证书是否有效并且与域名匹配。如果验证通过，则建立安全连接。如果数字证书无效或不可信，则浏览器会给出警告提示。

+ 因此，HTTPS 认证是由受信任的第三方机构（即证书颁发机构）对网站的身份进行认证，并确保通信过程中数据传输的安全性和完整性。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

## 动态多态的实现原理

+ 动态多态是面向对象编程中的一个重要概念，它通过基类指针或引用调用派生类对象的虚函数实现。其实现原理主要涉及虚函数表(vtable)和虚函数指针(vptr)

+ 在C++中，当一个类声明了虚函数时，编译器会为该类生成一个隐藏的指向虚函数表的指针--虚函数指针(vptr)。该指针位于每个对象的内存布局开头或者继承体系的最顶层基类对象中。而对应每个带有虚函数的类编译器还会创建一个虚函数表，其中存储着该类所有虚函数的地址。
+ 当使用基类指针或引用调用某个派生类对象的虚函数时，首先通过基类指针/引用找到对应对象中存储的vptr，然后根据vptr找到对应的虚函数表，在虚函数表中查找需要调用的虚函数，并执行相应代码

+ 这种机制使得在运行时能够动态地选择适当的派生类版本进行调用。通过动态多态可以实现面向对象编程中的封装，继承和多态等特性，提高代码灵活性和可扩展性。

## 虚函数表是属于类的还是类对象的

+ 虚函数表(vtable)是属于类的，而不是类对象的。每个带有虚函数的类都会在编译过程中生成一个对应的虚函数表。这个表存储了该类所有虚函数的地址，并且在编译时确定。

+ 每个类对象都包含一个指向其所属类的虚函数表的指针--虚函数指针(vptr)，他是隐藏在对象内存布局开头或继承体系最顶层基类对象中的成员。通过这个指针，可以在运行时动态地找到并调用正确的虚函数。

+ 因此，所有同一类类型的对象共享同一个虚函数表，而不是每个对象都拥有自己独立的虚函数表。这种设计节省了内存空间，并且保证了同一类型对象调用相同虚函数时能够得到正确结果。

## 静态成员函数可以是虚函数吗

+ 静态成员函数不能声明为虚函数。虚函数是通过动态绑定来实现的，他需要在运行时根据对象的类型来确定调用的函数，但静态成员函数属于类本身而不是对象，没有动态绑定的需求

+ 虚函数依赖于对象的内存布局和虚函数表来进行动态分配，而静态成员函数并不依赖于任何具体对象的状态或特征，所以不适合使用虚函数机制。静态成员函数是属于整个类而非某个具体对象的，并且他们可以直接通过类名访问，无需创建对象实例。

+ 因此，在C++中，将静态成员函数声明为虚函数是无效且错误的。

## 为什么析构函数默认不是虚函数

+ C++中析构函数默认不是虚函数的原因是为了避免额外的开销和复杂性

+ 在设计类继承关系时，当基类指针指向派生类对象并通过该指针进行delete操作时，如果基类的析构函数时虚函数，那么会触发动态绑定，从而调用到正确的派生类析构函数。这样可以确保在删除基类指针时，正确地释放派生类对象的资源。

+ 然而，将所有的析构函数都声明为虚函数会导致额外的开销。每个对象都需要额外存储一个虚函数表指针(vptr)，增加了对象的内存消耗，对于大规模或频繁创建和销毁对象的场景来说，这种额外开销可能是不可接受的。

+ 因此，在C++中，默认情况下将析构函数声明为非虚函数。如果在父类中定义了虚析构函数，并且希望在继承体系中正确地释放资源，那么需要手动将派生类的析构函数声明为虚函数。

## 内存对齐的作用

+ 内存对齐是指在分配和使用内存时，数据对象的起始地址需按照一定规则对齐的原则。具体而言，就是要求某些特定类型的数据在内存中的地址必须是某个值(通常是他自身大小)的整数倍

+ 内存对齐的作用主要有以下几点：
  + 提高访问效率： 许多计算机体系结构要求特定类型的数据从特定地址开始读取或写入。如果为满足对齐要求，会导致额外的CPU周期来处理这种非对齐访问，从而降低程序性能
  + 减少内存碎片： 当不同大小的数据对象按照自然字节对齐方式进行排列时，可能会出现内存碎片问题。通过按照特定规则进行对齐，可以减少内存碎片，提高空间利用率
  + 支持硬件操作： 一些硬件设备(如网络卡，图形加速器等)要求数据在内存中按照固定格式排列以支持高效地传输和处理。通过正确进行内存对齐，可以确保数据符合硬件设备所需的格式要求

## vector 和 map 用迭代器一遍遍历容器一边删除元素，迭代器会失效吗

+ 是的，当使用迭代器遍历容器并删除元素时，迭代器可能会失效。

+ 对于vector来说，如果使用普通迭代器(例如 std::vector<int>::iterator)进行遍历和删除操作，当你删除一个元素后，后面的元素会向前填补空缺，导致当前迭代器指向的位置已经不再有效。此时继续使用该迭代器将产生为定义行为

+ 对于map来说，使用普通迭代器或者逆向迭代器进行遍历并删除操作同样存在迭代器失效的问题。因为在删除某个键值对后，其他键值对的位置可能发生变化，导致当前迭代器无法正确指向下一个要访问的元素。

+ 解决这个问题的一种常见的方式是使用 erase-remove 惯用法。即通过调用容器提供的成员函数 erase() 来移除需要删除的元素，并保持正确的迭代器位置。例如，在 std::vector 中可以使用 erase-remove idiom
  + vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end());

+ 而在map中可以配合使用返回下一个有效迭代器的 erase() 成员函数:
```cpp
for (auto it = map.begin(); it != map.end(); )
{
    if (condition)
        it = map.erase(it);
    else
        ++it;
}
```

+ 注意：
  + C++11 引入了范围循环 for-each，但不适用于在迭代过程中删除元素的情况，因为他使用的是临时迭代器并不允许修改容器。

## map是有序的还是无序的，底层实现是什么

+ std::map 是有序的关联容器，底层实现通常是红黑树(Red-Black Tree)

+ 红黑树是一种自平衡二叉查找树，它能够保持键值对按照键的大小顺序进行排序。这意味着当你遍历 std::map 时，会按照键的升序顺序返回元素。
+ 红黑树具有以下性质：
  + 每个节点要么是红色，要么是黑色
  + 根节点和叶子节点(空节点)都被认为是黑色的。
  + 如果一个节点是红色的，则其子节点必须是黑色的。
  + 对于任意一个节点而言，从该节点到其所有后代叶子节点的简单路径上，包含相同数量的黑色节点。

+ 这些性质保证了红黑树的平衡性，并且在最坏情况下仍然能够保持较高的插入，删除和查找操作效率。因此，在std::map中插入，删除和查找元素的平均时间复杂度为O(logN)，其中N是元素数量。

+ 需要注意的是，在C++11引入之前，C++标准库中还提供了一个无序关联容器 std::unordered_map，它使用哈希表作为底层实现，并且不保持元素按照特定的顺序。在 std::unordered_map 中，插入，删除和查找元素的平均时间复杂度为O(1)，但是哈希表可能会占用更多的内存，并且无法保证元素顺序。

## map为什么底层实现是红黑树而不是AVL

+ 在C++标准库中，std::map底层实现选择红黑树而不是AVL树是因为红黑树相对于AVL树有一些优势：
  + 插入和删除操作更高效： 红黑树的插入和删除操作比AVL树要快。这是因为红黑树通过旋转和颜色调整来保持平衡，不需要进行严格的平衡修复。AVL树则需要在每次插入或删除后执行可能多次的旋转以保持平衡，这导致了更多的开销。
  + 更好的空间利用率： 红黑树通常比AVL树占用更少的内存。AVL树每个节点都需要存储额外的平衡因子信息，而红黑树只需要一个额外位表示节点颜色即可
  + 查找操作性能相似： 在查找元素方面，红黑树和AVL树具有类似的性能。他们都具有O(logN)的时间复杂度，并且提供了快速的查找能力。

+ 综合考虑这些因素，C++标准库选择了选择使用红黑树作为 std::map 的底层实现，然后，在某些特定场景下，如果对插入和删除操作频繁，对空间要求较高且查找操作相对较少，可以考虑使用AVL树或者其他数据结构来满足特定需求

## IP层有MTU报文分段策略，那TCP是不是可以不需要MSS分段策略

+ 在网络通信中，IP层负责将数据分成小块(报文段)进行传输，而TCP层则使用MSS(最大报文段长度)来确定每个TCP报文段的大小。MSS是TCP连接双方协商得出的一个值，表示在不发生分片的情况下能够发送的最大数据量

+ 虽然IP层已经实现了报文分段策略，但TCP仍然需要进行MSS分段策略。这是因为MTU(最大传输单元)代表了链路层能够传输的最大数据大小，而IP层根据MTU进行报文分段以适应链路层要求。然而，在经过不同网络设备和路径时，MTU可能会变化，导致某些链路上无法承载完整的TCP报文段。因此，TCP需要根据当前路径上的MTU值动态调整MSS，并将数据分成合适MTU大小的片段进行发送

+ 通过MSS分段策略，TCP可以确保在各种网络环境下可靠地传输数据，并避免发生IP层进一步对数据进行分片的情况。这有助于提高网络传输效率和可靠性。

## C++多线程编程用过哪些锁来实现同步或互斥

+ 互斥锁(Mutex) : 最常见的锁机制之一，通过lock()和unlock()函数来保护临界区，确保只有一个线程可以进入临界区执行操作

+ 递归锁(Recursive Mutex) : 类似于互斥锁，但允许同一线程多次枷锁。这种情况通常在嵌套函数调用时需要使用

+ 条件变量(Condition Variable) : 用于线程间的等待与唤醒机制。一个线程可以等待某个条件满足后再继续执行，另一个线程则可以发送信号来唤醒等待中的线程。

+ 读写锁(Read-Write Lock) : 也称为共享-独占锁，允许多个线程同时读取共享资源，但只允许一个线程独占写入

+ 自旋锁(Spinlock) : 在获取锁时不会主动阻塞线程，而是通过不断尝试获取直到成功。适用于对临界其的竞争非常短暂的情况

+ 屏障(Barrier) : 用于控制多个线程并行执行，在所有线程都达到屏障点后再继续执行后续操作

+ 这些锁都可以在C++标准库中找到对应的实现，例如 std::mutex, std::recursive_mutex, std::condition_variable, std::shared_mutex等。选择合适场景的锁机制是多线程编程中重要的技巧之一，需要根据具体需求和性能考虑作出选择。

## C和C++的区别

+ 设计思想上
  + C++是面向对象的语言，C是面向过程的语言

+ 语法上：
  + C++ 具有封装，继承，多态三种特性
  + C++ 相比C，增加了类型安全的功能，比如强制类型转换
  + C++ 支持范式编程，比如模板类，函数模板等。

## const 限定符

+ 作用
  + 修饰变量：表明该变量的值不可以被改变
  + 修饰指针：区分指向常量的指针和常量指针
  + 修饰引用：用于形参，既避免了拷贝，又避免了函数对值的修改
  + 修饰成员函数：表示函数不能修改成员变量(实际上是修饰this指针)

+ 补充：
  + 对于局部对象，常量存放在栈区
  + 对于全局对象，常量存放在全局/静态存储区
  + 对于字面值常量，常量存放在常量存储区(代码段)

## 指向常量的指针 VS 常量指针

+ 指向常量的指针(pointer to const):
  + 具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针(底层const)
  + const int * p 或者 int const * p

+ 常量指针(const pointer):
  + 常量指针是指 指针所指向的位置不能改变，即指针本身是一个常量(顶层const)，但是指针所指向的内容可以改变
  + 常量指针必须在声明的同时对其初始化，不允许先声明一个指针常量随后在对其赋值，这和声明一般的常量是一样的。
  + `int * const p = &a;`

## constexpr

+ 常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式
+ 一般来说，如果认定变量是一个常量表达式，那就把它声明成 constexpr 类型
+ 一个 constexpr 指针的初始值必须是 nullptr 或者 0， 或者是存储于某个固定地址中的对象
+ constexpr 函数是指能用于常量表达式的函数
+ 函数的返回类型及所有的形参的类型都得是字面值类型
+ 函数体中必须有且仅有一条return语句。

## #define VS const

+ #define
  + 宏定义，相当于字符替换
  + 预处理器处理
  + 无类型安全检查
  + 不分配内存
  + 存储在代码段(.text)
  + 可用 #undef 取消

+ const
  + 常量声明
  + 编译器处理
  + 有类型安全检查
  + 要分配内存
  + 存储在数据段(.data, .bbs)
  + 不可取消

## sizeof 运算符

+ sizeof 运算符的结果部分地依赖于其作用的类型
  + 对char或者类型为char的表达式执行sizeof运算，结果的1
  + 对引用类型执行sizeof运算符得到被引用对象所占空间的大小
  + 对指针执行sizeof运算得到指针本身所占空间的大小
  + 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小
  + 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素个执行一次sizeof运算并将所得结果求和
  + 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小。

+ 定义一个空类型，里面没有成员变量和成员函数，求sizeof结果为1.空类型的实例中不包括任何信息，本来求sizeof得到0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例，至于占用多少内存，由编译器决定，一般有一个char类新的内存
+ 如果该类型中添加一个构造函数和析构函数，再对该类型求sizeof结果仍为1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的类型只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数在实例内添加任何额外的信息
+ 如果把析构函数标记为虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位的机器上，一个指针占4个字节的空间，因此求sizeof得到4；在64位机器上，一个指针占8个字节的空间，因此求sizeof得到8

## 显式转换

+ static_cast ：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast
+ dynamic_cast ： 用于(动态)堕胎类型转换，只能用于含有虚函数的类，用于类层次间的向上向下转化
+ const_cast ： 去除”指向常量的指针“的const性质
+ reinterpret_cast ：为运算对象的位模式提供较低层次的重新解释，常用于函数指针的转换

## 形参和实参

+ 实参是形参的初始值

## static

+ 修饰局部变量 ： 使得被修饰的变量变为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序推出时销毁，默认初始化为0

+ 修饰全局变量 ： 限制了链接属性，是的全局变量只能在声明它的源文件中访问

+ 修饰普通函数 ： 使得函数只能在声明它的源文件中访问

+ 修饰类的成员变量和成员函数 ：使其只属于类而不是属于某个对象，对多个对象来说，静态数据成员只存储一处，供所有对象共用

+ 静态成员调用格式 ： <类名>::<静态成员>

+ 静态成员函数调用格式 ： <类名>::<静态成员函数名>(<参数表>)

## 参数传递

+ 指针参数传递本质上是值传递，所传递的是一个地址值

+ 一般情况下，输入用传值或者传const reference, 输出传引用(或指针)

## 内联函数的使用

+ 将函数指定为内联函数(inline)，通常就是将它在每个调用点上内联地展开
+ 一般来说，内联机制用于优化规模小(Google C++ Style 建议10行以下)，流程直接，频繁调用的函数
+ 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数

## 编译器对inline函数的处理步骤

+ 将inline函数体复制到inline函数调用点处
+ 为所用inline函数中的局部变量分配内存空间
+ 将inline函数的输入参数和返回值映射到调用方法的局部变量空间中
+ 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支(使用goto)

## 内联函数的优缺点

+ 优点：
  + 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高了程序运行速度
  + 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换(同普通函数)，而宏定义则不会
  + 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能
  + 内联函数在运行时可以调试，而宏定义不可以

+ 缺点
  + 代码膨胀，内敛是以代码膨胀(复制)为代价，消除函数调用带来的开销，如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
  + inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接
  + 是否内敛，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

## 返回类型和return语句

+ 调用一个返回引用的函数得到左值，其他返回类型得到右值

## 调试帮助

+ assert是一种预处理器宏。使用一个表达式作为它的条件 ： assert(expr)
+ 首先对expr求值，如果 表达式为false，assert输出信息并终止程序的执行。如果表达式为true，assert什么也不做

## 函数指针

+ 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关
+ C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址
+ 有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样
+ 用途：调用函数和做函数的参数，比如回调函数
```cpp
char *fun(char *p){...}  // 函数fun
char *(*pf)(char *p);    // 函数指针pf
pf = fun;                // 函数指针pf指向函数fun
pf(p);                   // 通过函数指针pf调用函数fun
```

## this 指针

+ this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象
+ this的目的总是指向”这个“对象，所以this是一个常量指针，被隐含地声明为 ClassName *const this，这意味着不能给this指针赋值
+ 当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据时，都隐式使用this指针
+ 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针
+ this并不是一个常规变量，而是个右值，所以不能取得this的地址(不能&this)
+ 在以下场景中，经常需要显式引用this指针
  + 为实现对象的链式引用
  + 为避免对同一对象进行赋值操作
  + 在实现一些数据结构时，例如list

## 拷贝函数

+ C++深拷贝与浅拷贝
  + 在未定义显式拷贝构造函数的情况下，系统会调用默认的拷贝函数：即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但是当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以此时必须采用深拷贝
  + 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝

## 析构函数

+ 整理析构函数的特性
  + 析构函数与构造函数的构造顺序相反
  + 当对象结束声明周期时，系统会自动执行析构函数
  + 析构函数声明时在函数名前加取反符号，不带任何参数，也没有返回值
  + 如果用户没有声明析构函数，系统会自动生成一个缺省的析构函数。
  + 如果类中有指针，且在使用的过程总动态申请了内存，那么需要显示构造析构函数，在销毁类指针，释放掉申请的内存空间，避免内存泄漏

## 访问控制与封装  public/private/protected

+ 定义在public说明符之后的成员在整个程序内可被访问，public成员定义接口
+ 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节
+ 基类希望它的派生类有权访问该成员，同时禁止其他用户访问，我们用受保护的(protected)访问运算符说明这样的成员

## struct与class的区别

+ struct与class定义的唯一区别就是默认的访问权限(struct默认是public,class默认是private)
+ 使用习惯上，只有少量成员变量的，使用struct定义

## 友元

+ 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元(friend)

## 构造函数的初始化顺序

+ 成员变量的初始化顺序与他们在类定义中的出现顺序一致： 构造函数初始值列表中初始值的前后位置关系不会影响

## explicit

+ 用于类的构造函数，阻止其执行隐式类型转换，但是仍可以被用来进行显式类型转换

## 迭代器

+ 迭代器(iterator)模式，又称游标(Cursor)模式，用于提供一种方法顺序访问一个聚合对象中各种元素，而又不需要暴露该对象的内部表示
+ 迭代器本质上是类模板，只是表现的像指针

## 顺序容器操作 emplace

+ 当调用push或者insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素

## resize / reserve

+ resize : 改变容器内含有元素的数量
+ reserve : 改变容器的最大容量

## 容器操作可能使迭代器失效

+ 在向容器中添加元素后：
  + 如果容器是vector或者string，且存储空间被重新分配，则指向容器的迭代器，指针和引用都会失效
  + 对于deque，插入到除首尾之外的任何位置都会导致迭代器，指针和引用失效
  + 对于list，指向容器的迭代器，指针和引用仍然有效。

+ 从容器删除元素后：
  + 对于list，指向容器的迭代器指针和引用仍然有效
  + 对于deque，在首尾之外的任何位置删除元素，其他元素的迭代器也会失效。
  + 对于关联式容器(例如 std::set / std::map)，插入元素不会使任何迭代器失效
  + 对于无序关联式容器(例如 std::unordered_set / std::unordered_map)，插入元素之后如果发生了rehash(新元素的个数大于max_load_factor() * bucket_count())，则所有迭代器失效

## vector对象是如何增长的

+ 当不得不获取新的内存空间时，vector和string的实现通常会分配一个比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以用来保存更多的新元素。这样，就需要每次添加新元素都重新分配容器和内存空间了

+ capacity 操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素，reserve操作允许我们通知容器它应该准备保存多少个元素
+ 初始时刻 vector的capacity为0，塞入第一个元素后capacity增加为1
+ 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容
+ 从空间上分析，扩容因子越大，意味着预留空间越大，浪费的空间也越多，所以从空间考虑，扩容因子越小越好
+ 从时间上分析，如果预留空间不足的话，就需要重新开辟一段空间，把原有的数据复制到新空间，如果扩容因子无限大的话，那显然就不在需要额外开辟空间了，所以从时间角度看，扩容因子越大越好

## 容器适配器

+ 除了顺序容器外，标准库还定义了三个顺序容器适配器：stack, queue和priority_queue
+ 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样
+ 默认情况下，stack和queue时基于deque实现的，priority_queue是在vector之上实现的

## lambda 表达式

+ 一个lambda表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。一个lambda表达式具有如下形式
```cpp
[capture list](parameter list)->return type (function body)
```
+ 其中capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)
+ return type, parameter list和function body与任何普通函数一样，分别表示返回类型，参数列表和函数体。但是与普通函数不同，lambda必须使用尾置返回来指定返回类型

+ 我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体:
```cpp
auto f = [] (return 42);
```

## 关联容器

+ map ： 关键字-值对；
+ set ： 关键字即值
+ map ： 按关键字有序保存元素(底层为红黑树)；unordered_map：无序集合(底层为哈希表)
+ map : 关键字不可重复出现；multimap : 关键字可重复出现

## 智能指针

+ 智能指针的行为类似常规指针，重要的区别在于它负责自动释放所指向的对象

+ shared_ptr
  + 允许多个指针指向同一个对象
  + 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。一旦一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象

+ unique_ptr
  + 独占所指向的对象

+ weak_ptr
  + weak_ptr是一种弱引用，指向shared_ptr所管理的对象
  + 可打破环状引用(cycles of reference，两个其实已经没有被使用的对象彼此互相指向，使之看似还在被使用的状态)的问题

+ make_shared
  + make_shared 在动态内存中分配一个对象并初始化它，返回执行此对象的shared_ptr

## 拷贝控制 对象移动

+ 右值引用：所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获的右值引用。右值引用有一个重要的性质：只能绑定到一个将要销毁的对象
+ 左值持久，右值短暂：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时对象
+ 通过调用std::move来获得绑定到左值上的右值引用
```cpp
int &&rr1 = 42;   // 正确：字面常量是右值
int &&rr2 = rr1;  // 错误：表达式rr1是左值
int &&rr3 = std::move(rr1);  // ok
```