### 模块

模块的概念:
+ 在C++中可以认为每个二进制文件为一个模块.

接口/跨模块接口:
+ 模块自己内部调用比较简单,因为编译环境和平台都一致,不存在不兼容的问题
+ 如果想把我们的功能提供给其他人使用,就需要导出接口和动态库文件了
+ 每种语言有自己的接口定义形式,**接口在C或C++里就是一些头文件(.h)**,头文件里定义了结构体,函数等,供其他模块调用
+ 可以认为:模块由接口和二进制文件组成
    + windows编译出来的dll肯定不能在linux上调用,32位编译出的dll又不能被64位程序调用,Debug模式和Release模式也存在很多差异
    + C++不像Java,Java是编译一次在任意操作系统和平台都能跑起来;C++则是,不同操作系统,不同CPU,不同系统位数,甚至不同优化参数,编译出来的二进制文件都不能通用

动态库:
+ 一个"程序函数库"简单的说:就是一个文件包含了一些编译好的代码和数据,这些编译好的代码和数据可以在事后供其他的程序使用
+ 动态库就是编译好的,可供其他模块调用的二进制文件.在windows是dll形式,在类Unix是so形式
+ 动态库相比源码和静态库有以下优势:
      1. 若以源码或静态库方式提供给别人使用,如果后期有一个bug需要修改,那么所有调用者都需要重新编译,测试,打包发布,成本很高.
      2. 以动态库方式提供,使用者只需要替换dll或so即可,简单高效
+ 动态库的劣势:
      + 动态库版本维护比较麻烦,需要思考如何避免"dll地狱"

### 链接

+ 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程,这个文件可被**加载(复制)**到内存并执行.
+ 链接可以执行于编译时(compile time),也就是在源代码被翻译成机器代码时;也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时;甚至执行于运行时(run time),也就是由应用程序来执行

为了构造可执行文件,链接器必须完成两个主要任务:
1. 符号解析(symbol resolution). 目标文件定义和引用符号,每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是讲每个符号**引用**正好和一个符号**定义**关联起来
2. 重定位(relocation). 编译器和汇编器生成从地址0开始的代码和数据节. 链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位

关于链接器的一些基本事实:
+ 目标文件纯粹是字节块的集合
+ 这些块中,有些包含程序代码,有些包含程序数据,而其他的则包含引导链接器和加载器的数据结构
+ 链接器将这些块连接起来,确定被连接块的运行时位置,并且修改代码和数据块中的各种位置
+ 链接器对目标机器了解甚少,产生目标文件的编译器和汇编器已经完成了大部分工作

目标文件有三种形式:
1. 可重定位目标文件.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件
2. 可执行目标文件. 包含二进制代码和数据,其形式可以被直接复制到内存并执行
3. 共享目标文件,一种特殊类型的可重定位目标文件,可以再加载或者运行时被动态地加载进内存并链接.

+ 编译器和汇编器生成可重定位目标文件(包含共享目标文件),链接器生成可执行目标文件.
+ 从技术上来说,一个目标模块(object module)就是一个字节序列,而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块.(不过,一般会互换地使用这些术语)
+ 目标文件是按照特定的目标文件格式来组织的,各个系统的目标文件格式都不相同.现代x86-64Linux和Unix系统使用**可执行可链接格式(Executable and Linkable Format, ELF)**

静态库:
+ "迄今为止,我们都是假设链接器读取一组可重定位目标文件,并把它们链接起来,形成一个输出的可执行文件"
+ 实际上,所有的编译系统都提供一种机制,**将所有相关的目标模块打包成为一个单独的文件,称为静态库(static library)**
+ 静态库可以用做链接器的输入,当链接器构造一个输出的可执行文件时,它只复制静态库里被应用程序引用的目标模块.
+ 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
+ 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
+ 创建静态库需要用到一个工具:`AR`

链接器如何使用静态库来解析引用?
+ 在符号解析阶段,链接器**从左到右**按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(驱动程序自动将命令行中所有的.c文件翻译为.o文件).
  + 在这次扫描中,链接器维护一个**可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)**
  + 一个**未解析的符号集合U**(即引用了但是尚未定义的符号)
  + 一个在前面输入文件中**已定义的符号集合D**.(初始时,E,U和D均为空)
+ 解析的工作原理:
  1. 对于命令行上的每个输入文件`f`,链接器会判断`f`是一个目标文件还是一个存档文件.如果`f`是一个目标文件,那么链接器把`f`添加到`E`,修改`U`和`D`来反应`f`中的符号定义和引用,并继续下一个输入文件
  2. 如果`f`是一个存档文件,那么链接器就尝试匹配`U`中未解析的符号和由存档文件成员定义的符号.如果某个存档文件成员`m`,定义了一个符号来解析`U`中的一个引用,那么就将`m`加到`E`中,并且链接器修改`U`和`D`来反应`m`中的符号定义和引用.对存档文件中所有的成员目标文件都依次进行这个过程,直到`U`和`D`都不再发生变化.此时,任何不包含在`E`中的成员目标文件都简单地被丢弃,而链接器将继续处理下一个输入文件.
  3. 如果当链接器完成对命令行上输入文件的扫描后,`U`是非空的,那么链接器就会输入一个错误并终止.否则,它会合并和重定位`E`中的目标文件,构建输出的可执行文件.
+ 关于库的一般准则是将它们放在命令行的结尾

加载可执行目标文件:`linux> ./program`
+ 因为`program`不是一个内置的shell命令,所以shell会认为`program`是一个可执行目标文件,通过调用某个驻留在存储器中称为**加载器(loader)**的操作系统代码来运行它.任何Linux程序都可以通过调用`execve函数`来调用加载器
+ 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或入口点来运行该程序,这个将程序复制到内存并运行的过程叫做**加载**

共享库(shared library)
+ 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
+ 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**
+ 调用编译器驱动程序,给编译器和链接器相关指令:`linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c`
  + `-shared`选项:指示链接器创建一个共享的目标文件
  + `-fpic`  选项:指示编译器生成与位置无关的代码
+ 在程序中调用共享库:`linux> gcc -o prog21 main2.c ./libvector.so`. 
+ 基本的思路是当创建可执行文件时,静态执行一些链接,然后在程序加载时,动态完成链接过程.**认识到这一点是很重要的**:此时,没有任何`libvector.so`的代码和数据节真的被复制到可执行文件`prog21`中.反之,链接器复制了一些重定位和符号表信息,它们使得运行时可以解析对`libvector.so`中代码和数据的引用.

位置无关代码
+ 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码,因而节约宝贵的内存资源.
+ 可以接在而无需重定位的代码称为**位置无关代码(Position-Independent Code, PIC)**,用户对GCC使用`-fpic`选项指示GNU编译系统生成PIC代码,共享库的编译必须总是使用该选项.

**处理目标文件的工具(GNU binutils包)**
1. AR: 创建静态库,插入,删除,列出和提取成员
2. STRINGS: 列出一个目标文件中所有可打印的字符串
3. STRIP: 从目标文件中删除符号表信息
4. NM:列出一个目标文件的符号表中定义的符号
5. SIZE: 列出目标文件中节的名字和大小
6. READELF:显示一个目标文件的完整结构,包括ELF头中编码的所有信息,包含SIZE和NM的功能
7. OBJDUMP:所有二进制工具之母,能够显示一个目标文件中所有的信息,它最大的作用是反汇编`.text`节中的二进制指令
8. LDD:列出了一个可执行文件在运行时所需要的共享库.

### 小结
+ 链接可以在编译时由静态编译期来完成,也可以在加载时和运行时由动态链接器来完成.
+ 链接器处理称为目标文件的二进制文件,它有三种不同的形式:可重定位的,可执行的和共享的.
  1. 可重定位的目标文件由静态链接器合并成一个可执行的目标文件,它可以加载到内存中并执行
  2. 共享目标文件(共享库)是在运行时由动态链接器链接和加载的,或者隐含地在调用程序被加载和开始执行时,或者根据需要在程序调用`dlopen库`的函数时
+ 链接器的两个主要任务是符号解析和重定位.
  1. 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义,
  2. 重定位确定每个符号的最终内存地址,并修改对那些目标的引用
+ 静态链接器是由像GCC这样的编译驱动程序调用的,它们将多个可重定位目标文件合并成一个单独的可执行目标文件.多个目标文件可以定义相同的符号,而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误
+ 多个目标文件可以被连接到一个单独的静态库中,链接器用库来解析其他目标模块中的符号引用,许多链接器通过从左到右的顺序扫描来解析符号引用,这是另一个引起令人迷惑的链接时错误的来源
+ 加载器将可执行文件的内容映射到内存,并运行这个程序.链接器还可能生成部分链接的可执行目标文件,这样的文件中有对定义在共享库中的例程和数据的未解析的引用.在加载时,加载器将部分链接的可执行文件映射到内存,然后调用动态链接器,它通过加载共享库和重定位程序中的引用来完成链接任务