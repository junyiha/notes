# 第一章 预备知识

## C++简介

+ C++融合了三种不同的编程方式：
  + C语言代表的过程性语言
  + C++在C语言基础上添加的类代表的面向对象语言
  + C++模板支持的泛型编程

## C++简史

+ 汇编语言，依赖于计算机的内部机器语言。
+ 它是低级语言(low-level)，即直接操作硬件，例如直接访问CPU寄存器和内存单元。因此，汇编语言针对于特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写程序

+ 高级语言(high-level)，致力于解决问题，而不针对特定的硬件。
+ 一种被称为**编译器**的特殊程序将高级语言翻译成特定计算机的内部语言。这样，就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了

+ 一般来说，计算机语言要处理两个概念--数据和算法
  + 数据，是程序使用和处理的信息
  + 算法，是程序使用的方法

+ 结构化编程，将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。
+ C语言的词汇表中就包含了这些结构：for循环，while循环，do while循环，if else语句
+ **结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序**

+ 面向对象编程(OOP)，与强调算法的过程性编程不同的是，OOP强调的是数据。它不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图**让语言来满足问题的要求**。其理念是设计与问题的本质特性相对应的数据格式。

+ **在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。**
+ OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。类定义描述了对每个类可执行的操作，然后便可以设计一个使用这些类的对象的程序。
+ 从低级组织（如类）到高级组织（如程序）的处理过程，叫做自下向上(bottom-up)的编程
+ OOP编程并不仅仅是将数据和方法合并为类定义。
  + 它还有助于创建可重用的代码，这将减少大量的工作。
  + 信息隐藏可以保护数据
  + 多态能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义
  + 继承能够使用旧类派生出新类
+ OOP引入了很多新的理念，使用的编程方法不同于过程性编程。它不是将重点放在任务上，而是放在表示概念上。

+ 泛型编程(generic programming)是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。
+ 不过OOP强调的是编程的数据方便，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。
+ OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（例如对数据排序或合并链表）的工具。
+ 术语泛型(generic)指的是，创建独立于类型的代码。
  + C++的数据表示有多种类型--整数，小数，字符，字符串，用户定义的，由多种类型组成的符合结构。
  + 例如，要对不同类型的数据进行排序，通常必需为每种类型创建一个排序函数。
  + 泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。
  + C++模板提供了完成这种任务的机制。

## 第二章 开始学习C++

+ 语句，是要执行的操作。
+ 为理解源代码，编译器需要直到一条语句何时结束，另一条语句何时开始。有些语句使用语句分隔符。
+ C++与C一样，使用终止符(terminator)，而不是分隔符。
+ 终止符是一个分号，它是语句的结束标记，是语句的组成部分，而不是语句之间的标记
+ 结论：在C++中，不能省略分号

+ 通常，C++函数可被其他函数激活或调用
+ 函数头描述了函数与调用它的函数之间的接口。
+ 位于函数名前面的部分叫做函数返回类型，**它描述的是从函数返回给调用它的函数的信息**。
+ 函数名后括号中的部分叫做形参列表(argument list)或参数列表(parameter list)。它描述的是从调用函数传递给被调用的函数的信息。

+ C++注释以双斜杠(`//`)打头，到行尾结束。注释可以位于单独的一行上，也可以和代码位于同一行
+ C-风格注释，包括在符号`/*`和`*/`之间。由于C-风格注释以`*/`结束，而不是到行尾结束，因此可以跨越多行。事实上，C99标准也在C语言中添加了`//`注释

+ 源代码中的标记和空白
  + 一行代码中不可分隔的元素叫做标记(token)。
  + 通常，必需用空格，制表符或回车将两个标记分开。空格，制表符和回车统称为空白(white space)。
+ C++源代码风格
  + 每条语句占一行
  + 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行
  + 函数中的语句都相对于花括号进行缩进
  + 与函数名称相关的圆括号周围没有空白。

+ C++程序是一组函数，而每个函数又是一组语句

+ 计算机是一种精确的，有条理的机器。要将信息项存储在计算机中，必须指出信息的存储位置和所需的内存空间。
+ 在C++中，完成这种任务的一种相对简便的方法，是使用声明语句来指出存储类型并提供位置标签。
+ 程序中的声明语句叫做定义声明(defining declaration)语句，简称为定义(definition)。这意味着它将导致编译器为变量分配内存空间。在较为复杂的情况下，还可能有引用声明(reference declaration)

+ 总结
  + C++程序由一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值的类型和函数期望通过参数传递给它的信息的类型。函数体由一系列位于花括号`{}`中的C++语句组成
  + 有多种类型的C++语句，包括：
    + 声明语句，定义函数中使用的变量的名称和类型
    + 赋值语句，使用赋值运算符`=`给变量赋值
    + 消息语句，将消息发送给对象，激发某种行为
    + 函数调用，执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句
    + 函数原型，声明函数的返回类型，函数接受的参数数量和类型
    + 返回语句，将一个值从被调用的函数那里返回到调用函数中。

## 第三章 处理数据

+ 计算机内存的基本单元是位(bit)。
+ 可以将位看作电子开关，可以开，也可以关。关表示值0，开表示值1。
+ 8为的内存块可以设置出256中不同的组合，因为每一位都可以有两种设置，所以8位的总组合数为256。
+ 字节(byte)，**通常指的是8位的内存单元**。从这个意义上来说，**字节指的就是描述计算机内存量的度量单位**，1KB等于1024字节，1MB等于1024KB。


## 第四章 复合类型

### 指针与C++基本原理

+ 面向对象编程与传统的过程性编程的区别在于，OOP强调的是在**运行阶段（而不是编译阶段）进行决策**。
  + 运行阶段，指的是程序正在运行时
  + 编译阶段，指的是编译器将程序组合起来时。
+ 运行阶段决策，就好比度假时，选择参观那些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。
+ 运行阶段决策提供了灵活性，可以根据当时的情况进行调整

### 指针小结

+ 声明指针
+ 给指针赋值。应将内存地址赋给指针。**可以对变量名应用`&`运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址**。
+ 对指针解除引用。
  + 对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符(`*`)来解除引用。
  + 另一种对指针解除引用的方法是**使用数组表示法**。例如，`pn[0]`与`*pn`是一样的。一定不要对未被初始化为适当地址的指针解除引用。
+ 区分指针和指针所指向的值
+ 数组名。在多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度（单位为字节）
+ 指针算术
+ 数组的动态联编和静态联编
  + 使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置
  + 使用`new[]`运算符创建数组时，将采用动态联编(动态数组),即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应该使用`delete[]`释放其占用的内存
+ 数组表示法和指针表示法
  + 使用方括号数组表示法等同于对指针解除引用
  + 数组名和指针变量都是如此，因此对于指针和数组名，即可以使用指针表示法，也可以使用数组表示法

### 自动存储，静态存储和动态存储

+ 自动存储
  + 在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生，在该函数结束时小王
  + 实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。
  + 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出(LIFO)。因此，在程序执行过程中，栈将不断地增大和缩小。

+ 静态存储
  + 静态存储是整个程序执行期间都存在的存储方式。
  + 使变量成为静态的方式有两种：一种是在函数外面定义它，另一种是在声明变量时使用关键字`static`

+ 动态存储
  + new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。
  + 它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。
  + 该内存池同用于静态变量和自动变量的内存是分开的。new和delete能够在一个函数中分配内存，而在另一个函数中释放它。因此数据的生命周期不完全受程序或函数的生存时间控制。

+ 栈，堆和内存泄漏
  + 如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。
  + 实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。
  + 极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。

## 第八章

+ 内联函数是C++为提供程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。
+ 编译过程的最终产品是可执行程序--由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。

+ 引用变量
  + 引用是已定义的变量的别名（另一个名称）
  + 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的
  + `int rats; int & rodents = rats;  // make rodents an alias for rate`
  + 其中，`&`不是地址运算符，而是类型标识符的一部分。就像声明中的`char*`指的是指向`char`的指针一样，`int&`指的是指向int的引用。
  + 引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量

### 实例化和具体化

+ 为进一步了解模板，必需理解术语：实例化和具体化
+ 谨记：在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例(instantiation)
  + 例如，函数调用`Swap(i, j)`导致编译器生成`Swap()`的一个实例，该实例使用int类型。模板并非函数定义，但是使用int的模板实例是函数定义。**这种实例化方式被称为隐式实例化(implicit instantiation),因为编译器之所以知道需要进行定义，是由于程序调用`Swap()`函数时提供了int参数。
  + 最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但是现在C++还允许显式实例化(explicit instantiation)。这意味着可以直接命令编译器创建特定的实例，例如`Swap<int>()`。其语法是，声明所需要的种类--使用`<>`符号指示类型，并在声明前加上关键字`template` -- `template void Swap<int>(int, int);  // explicit instantiation`

### 小结

+ 引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。
+ 通常，被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类是从另一个类派生出来的，则基类引用可以指向派生类对象

+ 函数的特征标是它的参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。
+ **通常，通过重载函数来为不同的数据类型提供相同的服务**。

+ 函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义 

## 第九章 内存模型和名称空间

### 头文件管理

+ 在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。
  + 例如，可能使用包含了另一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个文件。
+ 它是基于预处理编译指令`#ifndef`（即if not defined)

### 自动变量和栈

+ 了解典型的C++编译器如何实现自动变量，有助于更深入地了解自动变量
+ 由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。

+ 常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一个内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。
+ 程序使用两个指针来跟踪栈，一个指针指向栈底--栈的开始位置，另一个指针指向栈顶--下一个可用内存单元。当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。

+ 栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。

### 寄存器变量

+ 关键字`register`最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，这样的目的是--提高访问变量的速度。

### 说明符和限定符

+ 有些被称为存储说明符(storage class specifier)或cv-限定符(cv-qualifier)的C++关键字提供了其他有关存储的信息

+ 存储说明符
  + `auto`（在C++11中不再是说明符）
    + 在C++11之前，可以在声明中使用关键字`auto`指出变量为自动变量
    + 在C++11中，`auto`用于自动类型推断。
  + `register`
    + 用于在声明中指示寄存器存储，
    + 在C++11中，它只是显式地指出变量是自动的
  + `static`
    + 它被用在作用域为整个文件的声明中时，表示内部链接性
    + 被用于局部声明中，表示局部变量的存储持续性为静态的
  + `extern`
    + 它表明是引用声明，即声明引用在其他地方定义的变量
  + `thread_local`（C++11新增加的，可与`static`或`extern`结合使用）
    + 它指出变量的持续性与其所属线程的持续性相同
    + `thread_local`变量之于线程，犹如常规静态变量之于整个程序
  + `mutable`
    + 它的含义将根据const来解释
    + 可以用它来指出，即时结构（或类）变量为const，其某个成员也可以被修改

+ cv-限定符(cv表示const volatile)
  + `const` 
    + 它是最常用的cv-限定符，它表明--内存被初始化后，程序便不能再对它进行修改
  + `volatile`
    + 它表明，即时程序代码没有对内存单元进行修改，其值也可能发生变化；该关键字的作用是为了改善编译器的优化能力
    + 例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为`volatile`，则编译器将进行这种优化；将变量声明为`volatile`，相当于告诉编译器，不要进行这种优化。

### 小结

+ C++鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵给用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将`main()`和其他使用这些函数的函数放在第三个文件中


## 第十章 对象和类

+ 过程性编程方法 -- 首先考虑要遵循的步骤，然后考虑如何表示这些数据（并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据）

+ OOP方法 -- 首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。

+ 指定基本类型完成了三项工作
  + 决定数据对象需要的内存数量
  + 决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）
  + 决定可使用数据对象执行的操作或方法

+ 类，是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包
+ 类规范由两个部分组成
  + 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口
  + 类方法定义：描述如何实现类成员函数
  + 简单地说，类声明提供了类的蓝图，而方法定义则提供了细节

### 什么是接口？

+ 接口，是一个共享框架，供两个系统（例如在计算机和打印机之间或者用户和计算机程序之间）交互时使用

+ 对于类，我们说公共接口。在这里，公共(public)是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。
+ 接口，让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。

+ 为开发一个类并编写一个使用它的程序，需要完成多个步骤。这里将开发过程分成多个阶段，而不是一次性完成。
+ 通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。

### 访问控制

+ 使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数来访问对象的私有成员。
+ 因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏

+ 类设计尽可能将公有接口与实现细节分开。
  + 公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。
  + 数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装
  + 封装的另一个例子是，将类函数定义和类声明放在不同的文件中

+ 类和结构
  + 类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。
  + 实际上，C++对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据结构）

### 实现类成员函数

+ 创建类描述的第二个部分：为那些由类声明中的原型表示的成员函数提供代码。
+ 成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：
  + **定义成员函数时，使用作用域解析运算符(`::`)来表示函数所属的类**
  + **类方法可以访问类的`private`组件**

+ 成员函数的函数头使用作用域运算符解析(`::`)来指出函数所属的类。因此，作用域解析运算符确定了方法定义对应的类的身份。

### 内联方法

+ 定义位于类声明中的函数都将自动成为内联函数

+ 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的，最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）

### 方法使用哪个对象

+ 所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。
  + 例如，假设kate和joe都是Stock对象，则`kate.shares`将占据一个内存块，而`joe.shares`占用另一个内存块，但`kate.show()`和`joe.show()`都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。

+ 在OOP中，调用成员函数被成为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但是该方法被用于两个不同的对象。

### 类作用域

+ 在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
+ 另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必需通过对象
+ 同样，在定义成员函数时，必需使用作用域解析运算符
  
+ 总之，在类声明或成员函数定义中，可以使用未修饰的成员名称。
+ 构造函数名称在被调用时，才能被识别，因为它的名称与类名相同
+ 其他情况下，使用类成员名时，必需根据上下文使用直接成员运算符(`.`)，间接成员运算符(`->`)或作用域解析运算符(`::`)

### 小结

+ 面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏

+ 类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量。例如由new按类描述分配的内存


## 第十一章 使用类

+ 学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践经验之前，根本不可能全部记住这些东西。
+ 掌握知识的好的方法是，在自己开发的C++程序中使用其中的新特性。对这些新特性有了充分的认知后就可以添加其他C++特性

+ 正如C++创始人`Bjarne Stroustrup`在一次C++专业程序员大会上所建议的：**轻松地使用这种语言。不要觉得必须使用所有的特性，不要在第一次学习时就试图使用所有的特性**

## 第十二章 类和动态内存分配

### 指针和对象小结

+ 使用常规表示法来声明指向对象的指针 -- `String* gla;`

+ 可以将指针初始化为指向已有的对象 -- `String* first = &saying[0];`

+ 可以使用new来初始化指针，这将创建一个新的对象 -- `String* favorite = new String(sayings[choice])`

+ 对类使用new将调用相应的类构造函数来初始化新创建的对象

+ 可以使用`->`运算符通过指针访问类方法 -- `shortest->length()`

+ 可以对对象指针应用解除引用运算符(`*`)来获得对象 -- `first = &saying[i];`