# 如何分析和解决一个任务：思维方式
1. 先从整体上有一个总体思路，比如各个模块之间如何通信、依赖等，然后从一个点开始，照着调用路径分析下去，不要看一个类中的每个方法，而是只看用到的方法。
2. 把所想要完成的目标分步实现，如果思路不清晰，不知道如何去做，可以模拟现实中的步骤。
   1. 要把想实现的东西转换成代码，不要想着最终结果好难，不知道怎么做。
   2. 先分步，一步一步完成，然后分别去想每一步是怎么实现的。第一次写完之后肯定是缺陷的，仔细反复调试，慢慢修改优化，不要看着目标就被吓到。
3. 函数最主要的作用就是将一个大型程序分解成多个易于管理的小部分，这一过程称为分解（decomposition）。而你所需做的应是将一个高层次问题细分为一系列低层次的函数，每一个函数有其自己独立的功能。然而，找到问题正确的细分方法有很大的挑战，需要不断练习、思考和尝试。编程是一门艺术，好的问题分解策略主要来源于实际经验。
4. 然而，作为一种通用的规则，问题的分解过程一般从程序的主程序开始。此时，我们将整个程序视为一个整体，并尝试从中分析并抓取出其主要部分。一旦程序的最主要部分被识别出来，就可以将它们定义为一些相互独立的函数。由于某些函数可能本身依然复杂，因此通常需要将他们再分解为更小的部分。我们可以不断重复这一分解过程直到每个问题足够简单明了以便于解决。上述分解过程称为**自顶向下的程序设计（top-down design）**或**逐步求精的方法（ste[wose refinement）**

## 深入理解计算机操作系统

过程是软件中一种很重要的抽象
+ 它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.然后,可以再程序中不同的地方调用这个函数,设计良好的软件用过程作为抽象机制,隐藏某个行为的具体实现,同时又提供清晰简洁的接口定义,说明要计算的是哪些值,过程会对程序状态产生什么样的影响.
+ 不同编程语言中,过程的形式多样:函数(function),方法(method),子例程(subroutine),处理函数(handle)等等

数据对齐
+ 许多计算机系统对基本数据类型的合法地址做出了一些限制,要求某种类型对象的地址必须是某个值K(通常是2,4或8)的倍数,这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计
+ 强制对齐:
    + 对于大多数x86-64指令来说,保持数据对其能够提高效率,但是它不会影响程序的行为
    + 另一方面,如果数据没有对齐,某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令,就无法正确执行.

理解指针
+ 指针以一种统一方式,对不同数据结构中的元素产生引用
+ 每个指针都对应一个类型,这个类型表明该指针指向的是哪一类对象
  + `int* ip`表示变量ip是一个指向int类型对象的指针,`char** cpp`表示cpp指针指向的对象自身就是一个指向char类型对象的指针
  + 通常,如果对象类型为`T`,那么指针的类型为`T*`;特殊的, `void *`类型代表通用指针.比如说,malloc函数返回一个通用指针,然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换,将它转换成一个有类型的指针.
  + 指针类型不是机器代码中的一部分,它们是C语言提供的一种抽象,帮助程序员避免寻址错误
  + 每个指针都有一个值,这个值是某个指定类型的对象的地址.特殊的NULL(0)值表示该指针没有指向任何地方
  + 指针用`&`运算符创建.这个运算符可以应用到任何`lvalue`类的C表达式上,`lvalue`表示可以出现在赋值语句左边的表达式
  + `*`操作符用于间接引用指针,其结果是一个值,它的类型与该指针的类型一致,**间接引用**是用内存引用来实现的,要么是存储到一个指定的地址,要么是从指定的地址读取
  + 数组与指针紧密联系.一个数组的名字可以像一个指针变量一样引用(但是不能修改).数组引用(例如`a[3]`)与指针运算和间接引用(例如`*(a + 3)`)有一样的效果.数组引用和指针运算都需要用对象大小对偏移量进行伸缩
  + 将指针从一种类型强制转换成另一种类型,只改变它的类型,而不改变它的值.强制类型转换的一个效果是改变指针运算的伸缩
  + 指针也可以指向函数.这提供了一个很强大的存储和向代码传递引用的功能,这些引用可以被程序的某个其他部分调用

内存越界引用和缓冲区溢出

   
1. 模型相关的,b站视频
2. 多看项目(github),多练
3. 大厂的代码,main中变量的声明(amlogic, nvidia)
4. shell 不必花费太多精力,推荐:python,php(现在不要去学,单点击穿,现在主要学习C++)

## 如何阅读大型项目的代码？

+ 目的性：读代码的时候如果有目的性是最好的。
+ 时间：总体来讲，阅读大型项目的代码需要时间。
+ 方法论：抽象地说，阅读代码有两种方向，自底向上和自顶向下。
  + 自底向上，从具体的文件到子模块，从子模块到功能集，再到整个项目，强调的是从具体实现出发总结出一般抽象。
  + 自顶向下，从项目的顶层设计到责任分发，从责任分发到功能分发，再到具体的实现代码，强调的是从抽象设计出发落实到具体实现。
  + 两种方法是两个不同的视角。实践中经常需要结合两种方向随时切换地采用，当对大方向了解不足的时候自顶向下的看，当对实现细节不够明确的时候自底向上的看