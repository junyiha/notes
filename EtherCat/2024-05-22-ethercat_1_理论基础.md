---
category: EtherCat
date: 2024-05-22 09:00:00 +0800
layout: post
title: ethercat_1_理论基础
---
## 简介

+ ethercat的理论基础知识

## EtherCAT

+ `EtherCAT`是`Ethernet for Control Automation Technolog`的简称，是一个实时控制的开放标准。

+ `ETG`, `EtherCAT技术小组`，该组织是`Beckhoff`为支持和推广`EtherCAT`而成立的。`ETG`网站是关于`EtherCAT`的信息来源。

### EtherCAT xenomai 安装

+ ~~`notes/PDF/EtherCAT（ubuntu18.04，linux4.9.38，xenomai3.1，igh1.52）配置完整流程.docx`~~ 
+ pdf文档配置menuconfig时步骤不完整，坑！！！
+ 另一个地址:`https://www.icode9.com/content-3-916631.html`

### 固定`RxPDOs` 

+ `notes/PDF/AP系列驱动器+EtherCAT+手册V1.0.pdf -- P12`

+ **对于`CSP`(循环同步位置)**0x6060的操作方式=8：
  + 接收PDO 4 ： 0x1700
    + `0x6040` -- 控制字
    + `0x607A` -- 轨迹目标位置
    + `0x60B1` -- 速度偏移
    + `0x60B2` -- 转矩偏移

+ 对于`CSV`(循环同步速度)0x6060的操作模式=9：
  + 接收PDO 5：0x1701
    + `0x6040` -- 控制字
    + `0x60FF` -- 目标速度
    + `0x60B2` -- 转矩偏移量

+ 对于`CST`(循环同步转矩)0x6060的操作方式=10：
  + 接收PDO 6：0x1702
    + `0x6040` -- 控制字
    + `0x60FF` -- 目标速度
    + `0x60B2` -- 转矩偏移量

### 固定`TxPDO`

+ 发送PDO 5：0x1B00
  + `0x6041` -- 16 -- 状态字
  + `0x6064` -- 32 -- 实际电机位置
  + `0x60F4` -- 32 -- 位置循环错误（跟随错误）
  + `0x606C` -- 32 -- 实际电机速度
  + `0x6077` -- 16 -- 转矩实际值

### 请求主站

+ 用户程序通过`ecrt_request_master`请求主站设备，该函数调用`ecrt_request_master_err()`，取得`master`设备，并执行`ec_master_enter_operation_phase()`函数

+ 请求主站设备完成后，开始**创建数据域**，调用`ecrt_master_create_domain()`

+ 创建数据域成功后，分别完成对各从站设备的配置，配置内容包括：`PDO`映射，`SM`配置，`FFMU`配置和`DC`配置

+ 用户程序调用的入口是`ecrt.h`和相关的库文件，通过`ioctl`以驱动的形式实现，与`master`文件夹中的部分函数稍有区别

### 从站配置

+ 从站配置是应用层通过`ecrt_master_slave_config()`函数添加到主站的`config`链表中

## PDO

+ 过程数据对象(`Process Data Object, PDO`)，是用来传输实时数据的，提供对设备应用对象的直接访问通道，它用来传输实时短帧数据，具有较高的优先权。
  
+ `PDO`传输的数据必须少于或等于8个字节，`PDO`的**CAN报文数据域**中每个字节都用作数据传输，因此，在应用层上不包含传输控制信息，报文利用率极高。

+ `PDO`通信是基于生产者/消费者的通讯模式，每个`PDO`有一个唯一的标识符且可以通过一个节点发送，但有多个节点可以接收。`PDO`的接收不需要消费者确认。
  - 由生产者发送的`PDO`称为发送PDO`(TPDO)`
  - 由消费者接收的`PDO`称为接收PDO`(RPDO)`

+ 每个`PDO`在对象字典中由两个对象描述： 通信参数和映射参数
  - `PDO`通信参数指明使用哪个`COB-ID`，传输类型，禁用时间和定时时间
  - `PDO`映射参数用于设定`PDO`报文中的数据的映射关系，确定要传输的数据在`CAN`报文数据域中的定位。该参数允许`PDO`的生产者和消费者知道正在传输什么信息，而不需要在`CAN`报文中增加额外的协议控制信息，使传输的效率达到最高。一个`PDO`最多可以映射64个对象

+ `PDO`通讯具有三种出发模式：内部事件驱动或内部定时器触发，同步触发，远程请求触发
  - **内部事件驱动或内部定时触发。**通讯由某一事件触发。例如数字I/O口状态改变，超过预先设定的值，定时器中断等都会触发节点发送一个`PDO`。这种模式可使总线负载达到最小，在相对低的波特率下获得比较高的通讯特性。
  - **同步触发。**同步触发`PDO`是指`CANopen`节点收到由管理节点发出的同步报文（同步对象Sync）之后，根据触发报文条件向总线发出`PDO`报文。同步传输又分为周期性和非周期性。周期性是指`CANopen`节点收到一定数量的同步报文之后才开始发送；非周期性`PDO`是指`PDO`触发条件成立之后，当收到下一个同步对象后马上发送`PDO`
  - **远程请求触发。**`PDO`消费者可以给`PDO`生产者发送远程`PDO`请求，相应`PDO`生产者将对远程帧作出相应，向总线上发送相应的`PDO`数据。

+ `PDO`通讯时的触发模式由`PDO`通信参数中的传输类型来确定，传输类型是一个8位无符号整数，这个传输类型值的大小与`PDO`触发方式的对应关系

+ 主站和从站`PDO`通信的机制
  + `PDO`的基本概念及其在对象字典中的索引，在主站和从战采用`PDO`通信方式时，思路是 -- 先配置主站的`PDO`的通信参数(COB-ID,数据传输类型)，再配置从站的通信参数与主站一致，这样就建立了主站与从站的`PDO`通信的关系。然后再通过字典配置主站`PDO`映射参数，配置完成后从主站就可以通过`PDO`通信传输数据。

+ `PDO`传输的“总指挥”就是对象字典。`PDO`发送什么数据，接收什么数据，什么时候发送和接收，发送和接收的数据都放在哪儿，都是由对象字典配置。

## CAN

+ CAN是控制器局域网络(`Controller Area Network, CAN`)的简称，是由以研发和生产汽车电子产品著称的德国`BOSCH`公司开发的，并最终称为国际标准，是国际上应用最广泛的**现场总线**之一

## EtherCAT 使用与解析--关于ethercat应用层使用

+ url -- `https://blog.csdn.net/lswdcyy/article/details/105441470`
  
+ 下载`ethercat`源码并且安装好之后，测试`ethercat`使用可以遵循以下步骤

+ 开启`ethercat`系统 -- `sudo /etc/init.d/ethercat start`
  + 执行这一步需要确保一点 -- 按照`ethercat`源码中的`README`指导将一些需要的文件复制以及创建软连接到`/opt/init.d/ethercat`以及`/opt/sysconfig/ethercat`两个文件，前者是系统启动文件，后者是系统配置文件
  + 系统配置文件，是一份变量定义文件，在系统启动脚本中执行，定义两类变量，一个是主站MAC地址(`MASTER0_DEVICE`)，一个是使用的模块驱动名称(`DEVICE_MODULES`)

+ 开启系统后，要在应用层进行对主站模块的使用，本质上是通过开启`/dev/EtherCAT`字符设备，而后基于`ioctl`方式调用内核主站模块各种功能
  + 开启系统后，用户主要需要进行从站配置与PDO映射，域操作功能，然后就可以进行PDO交换了
  + **主站程序运行在内核空间，应用层需要一种方式实现对内核调用。通过打开主站创建的字符设备`/dev/EtherCAT`就是这个作用**
  + 主要用到的函数
    - `ec_master_t *ecrt_request_master(unsigned int master_index);` -- 
      - **负责打开字符设备文件，传入参数为使用主站索引**（使用`/etc/init.d/ethercat`开启系统的时候可以一次性传入多个MAC地址从而开启多个主站，不同主站创建不同的字符设备，例如`/dev/EtherCAT0, /dev/EtherCAT1...`），
      - 而这个索引就是用于开启对应的字符设备，从而使用不同的主站，使用`open接口`打开，然后返回文件描述符，该文件描述符用于`ioctl`调用对应主站功能。另外在申请到主站后就不再允许进行总线的重新扫描，固化了主站连接的从站链表，而且设置从站状态当前申请状态为`PREOP`
    - `ec_domain_t *ecrt_master_create_domain(ec_master_t* master);`
      - **负责创建域，**`domain`与`PDO`映射有密切联系，在激活的位置详谈
      - 这个函数具体内容就是直接在内核空间中创建一块`ec_domain`空间并且将该空间连接到主站`domain`链表尾部
    - `ec_slave_config_t *ecrt_master_slave_config(ec_master_t* master, uint16_t alias, uint16_t position, uint32_t vendor_id, uint32_t product_code);`
      - **从站配置函数**，
      - 主站模块中的从站链表，它们之间的关系为：从站配置是应用层通过`ecrt_master_slave_config()`函数添加到主站的`configs`链表中的，而从站链表`slaves`则是通过`ethercat`主站状态机通过扫描`ethercat`总线得到的，两者的共同之处在于**从站配置过程的`alias, position, VID, PID`，这些在主站扫描到的从站链表中都是有一份参数的，当应用层设置配置和主站扫描到从站信息相匹配的时候，那就将从站与从站配置相联系**（这时候会将主站扫描的`SII`信息关于`sync`关联的`PDO`信息复制到从站配置中，也就是默认`PDO`配置）；这样，就可以通过从站配置寻找到主站模块中从站配置信息，进而获取到从站信息。
    - `int ecrt_slave_config_reg_pdo_entry(ec_slave_config_t *sc, uint16_t index, uint8_t subindex, ec_domain_t *domain, unsigned int *bit position);`
      - **从站配置`PDO`函数**
      - 需要注意的一点 -- 在主站正式激活之前，所有配置`PDO`相关的其实并没有相对应的空间申请操作，一切都是进行的计算，计算`PDO`需要多大空间，计算`domains`的逻辑位置，计算`FMMU`的逻辑位置，计算`PDO`的逻辑位置，直到主站正式激活，主站会根据自身已经申请的域链表`domains`，获取所有域所需要的空间大小，而后对每个域进行逻辑地址分配，每个域中再对每个`FMMU`进行逻辑地址分配。
      - 接口参数
        - `uint16_t index` -- 对象字典索引
        - `uint8_t subindex` -- 对象字典子索引
        - `ec_domain_t *domain` -- 使用的域
        - `unsigned int* bit_position` -- 一个Byte中的偏移量，当PDO映射逻辑地址不是完整的Byte时有用
      - 首先，通过从站应用层配置索引可以获取到主站的从站配置链表中对应的从站配置，而后根据配置目标domain的索引获取到主站的domains链表对应的域，这样就可以实现应用层的从站配置和domain切换到主站对应的从站配置和domain，然后进行pdo映射操作。
      - 每次进行PDO映射的时候，并不是只对设置的一个对象进行处理，而是直接将整个sync关联的PDO都进行批次化处理。所以，本质上来讲，PDO配置映射就是确定PDO的逻辑地址位置
    - `int ecrt_master_activate(ec_master_t *master);`
      - **函数为正式激活的函数**
      - 主站注册的domains链表整体大小计算；经过PDO注册映射之后，对主站中关联的每个domains都是相互独立的，并且每个domains都只是一个计算得到的值，其实并没有需要的空间申请，因此在主站激活的时候会将全部domians需要的空间进行统一申请。具体申请到的PDO映射逻辑空间存放在字符设备打开文件的priv指针处，关于字符设备的file->priv在字符设备打开eccdev_open的时候进行指定。然后按照主站连接的domains链表顺序对每个domian起始地址进行设置：主要是domain的逻辑起始地址，domain的大小，以及domain中的FMMU的逻辑地址重新设置，最终，domain和FMMU的逻辑起始地址都是在主站全部domains环境下的逻辑起始地址。为了进行PDO映射，在主站激活过程中还对每个domain需要的子报文进行空间申请。在计算子报文需要个数的时候，各个domain计算各自需要的子报文需要，这样就可以满足不同domain的PDO交换周期是可以单独设置的；在domain计算自己需要的子报文个数的时候，计算是以FMMU为一个基本单位进行计算的，每个子报文可承载的数据大小为1486Byte，然后根据一个子报文中FMMU的输入输出情况设置子报文类型，也就是EC_DATAGRAM_LRD类型子报文，EC_DATAGRAM_LRR类型子报文以及EC_DATAGRAM_LRW类型子报文。然后将这些子报文添加到domain的datagram_pairs链表中。当然，整体过程中，domain映射空间和子报文使用的数据空间都是同一段空间。
      - 完成主站的domains域空间处理，之后就停止主站的空闲阶段线程（等待空间阶段线程退出）
      - 开启主站的操作阶段线程，该线程和空闲阶段线程相比不同之处--在于将主站子报文队列组合发送移动到用户手中进行处理
    - `uint8_t *ecrt_domain_data(ec_domain_t *domain);`
      - **返回domain在逻辑空间的逻辑地址**
    - `void ecrt_domain_queue(ec_domain_t *domain);`
      - **将对应domain空间使用的子报文排列到主站子报文发送链表中**
    - `void ecrt_master_send(ec_master_t *master);`
      - **将主站的子报文发送链表的子报文进行发送**，在发送过程中，默认的会将从站状态机子报文和主站状态机子报文进行排队发送

## `ecrt.h`头文件接口

+ `ecrt_master_receive()`
  + 功能：从硬件获取接收到的帧并处理数据报。通过调用中断服务例程查询网络设备接收到的帧。提取收到的数据报并将结果发送到队列中的数据报对象。接收到的数据报和超时的数据报将被标记并退出队列
  + 函数原型：`void ecrt_master_receive(ec_master_t* master);`
  + 参数：`master` -- `ethercat`主机
  + 返回值：无

+ `ecrt_domain_process()`
  + 功能：确定域数据报的状态。评估接收到的数据报的工作计数器，并在必要时输出统计信息。必须在`ecrt_master_receive()`接收域数据报之后调用此函数，以便`ecrt_domain_state()`返回上一次进程数据交换的结果。
  + 函数原型：`void ecrt_domain_process(ec_domain_t *domain);`
  + 参数：`domain` -- 域
  + 返回值：无

+ `EC_READ_U16()`
  + 功能：宏函数，计算整数数据，同样还有`EC_READ_U32()`

+ `EC_WRITE_U16()`
  + 功能：宏函数，将整型数据写入内存。内存大小是`ecrt_slave_config_create_sdo_request()`的参数。

+ `ecrt_master_sync_reference_clock()`
  + 功能：将DC参考时钟偏移补偿数据报排队发送，参考时钟将上次取消`ecrt_master_application_time()`提供的应用程序时间同步
  + 函数原型：`void ecrt_master_sync_reference_clock(ec_master_t *master)`
  + 参数：`master` -- `ethercat`主机
  + 返回值：无

+ `ecrt_master_sync_slave_clocks()`
  + 功能：将DC时钟偏移补偿数据报排队发送，所有的子时钟与基准时钟同步
  + 函数原型：`void ecrt_master_sync_slave_clocks(ec_master_t* master);`
  + 参数：`master` -- `ethercat`主机
  + 返回值：无

+ `ecrt_domain_queue()`
  + 功能：**将主数据报队列中的所有域数据报排队**。调用此函数可标记域的数据报以便在`ecrt_master_send()`的下一次调用
  + 函数原型：`void ecrt_domain_queue(ec_domain_t* domain);`
  + 参数：`domain` -- 域
  + 返回值：无

+ `ecrt_master_send()`
  + 功能：**发送队列中的所有数据报**。该方法接收所有排队等待传输的数据报，将他们放入帧中，并将他们传递给以太网设备进行发送
  + 函数原型：`void ecrt_master_send(ec_master_t* master);`
  + 参数：`master` -- `ethercat`主机
  + 返回值：无

+ `ecrt_master_application_time()`
  + 功能：设置应用程序时间。在使用分布式时钟操作从机时，主机必须知道应用程序的时间。时间不是由主机本身增加的，因此必须循环调用此方法
  + 函数原型：`void ecrt_master_application_time(ec_master_t* master, uint64_t app_time);`
  + 参数：`master` -- `ethercat`主机；`app_time` -- 应用时间
  + 返回值：无

+ `ecrt_release_master()`
  + 功能：释放请求的`ethercat`主机
  + 函数原型：`void ecrt_release_master(ec_master_t* master);`
  + 参数：`master` -- `ethercat`主机
  + 返回值：无

## 关于PDO映射

+ `https://www.codeleading.com/article/95113301360/#:~:text=%E5%BD%93%E7%84%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8ecrt_slave_config_pdos,%28%29%E5%87%BD%E6%95%B0%E5%AF%B9%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E5%8E%9F%E6%9C%ACSII%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9A%84%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84sync%E8%BF%9B%E8%A1%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BE%9D%E6%8D%AE%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%9A%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A`

+ 对于PDO映射，首先它是已经有了一个sync中关联PDO的链表的前提下才进行的PDO映射。
+ 使用`ecrt_slave_config_pdos()`函数进行PDO的在`sync`中的配置
  + 之所以有这样一个步骤，是因为主站状态部分，主站状态机在扫描SII信息时会提取`TxPDO`和`RxPDO`到从站的同步管理器(SII信息中有PDO和sync相关的信息)；然后再使用`ecrt_master_slave_config()`进行函数配置的时候会将对应从站的sync相关的PDO(`master->slaves->sync`)复制到从站配置部分，这样即使不去人为的配置同步管理器和PDO的映射关系，也没有什么影响

+ `ecrt_slave_config_pdos()`
  + 函数对从站配置进行设置，会将原本SII复制到从站配置中的sync进行清除，而后依据新的配置进行设置，（目的就是为了对从站同步管理器的自定义设置）
  + 需要使用到的参数分别是`sync, pdo, pdo_entry`结构体，三者关系是`sync`索引`PDO`， `PDO`索引`PDO_entry`
  + 从站如何获取PDO配置，可以使用`sudo ethercat cstruct`命令进行该信息的提取
  + 针对每个`ec_sync_info_t`输入结构数组进行PDO映射处理，分为三个层次
    + sync层次 -- sync层次主要配置同步管理器的方向和看门狗设置
    + PDO层次 -- 处理PDO的时候需要两个过程，一个是对之前的PDO配置进行清除，另一个是将自定义配置的`PDO`设置到从站配置的同步管理器链表中，这个过程还会查询之前的默认配置，将之前`PDO`中的`PDO_entry`复制到`PDO`中

+ 以上两种PDO配置并不冲突，可以理解为前者是从站的默认配置，后者是用户为了个性化自定义配置（有无均可，只不过自定义的化可能会有冗余信息）

## 主站和从站

+ 参考：
  + `https://blog.csdn.net/qq923433160/article/details/83781812`

---

+ 主站的实现可采用嵌入式和PC机两种方式，均需配备标准以太网MAC控制器，传输介质可使用100BASE-TX规范的5类UTP线缆。
+ EtherCAT从站设备除了具备通信功能外，还需具备对从站设备的控制功能。常见的从站设备有I/O端子、伺服设备、微处理器等。

+ EtherCAT主站运行需具备以下几个基本功能：
  + 读取从站设备描述XML文件并对其进行解析，获取其中配置参数
  + 捕获和发送EtherCAT数据帧，完成EtherCAT子报文解析、打包等
  + 管理从站设备状态，运行状态机，完成主从站状态机设置和维护
  + 可进行非周期性数据通信，完成系统参数配置，处理通讯过程中突发事件
  + 实现周期性过程数据通信，实现数据实时交换，实时监控从站状态，从站反馈 信号实时处理等功能。

## 控制卡

+ 参考：
  + `https://www.cnblogs.com/cariohu/p/15508175.html`

### 控制卡分类

+ 控制器或者控制卡的性能主要取决于控制算法，不同厂家控制卡的性能差别可能非常大。
+ 目前常见工业应用中比较高端的有以色列ACS，美国Aerotech，这是属于第一梯队的，其他国外的流行品牌还有elmo、PMAC、Galil、欧姆龙等。国内的有固高、雷赛、正运动、柏楚等，与国外产品相比仍然有一定差距，但也在不断突破。

+ 根据控制器传递命令给驱动器的方式，可以分为：总线型、模拟量型、PWM型、脉冲型控制卡。
+ 目前，总线型控制卡是最主流的，各大厂家的口号都是一网到底，这个网就是指的总线，就是通过一根总线把所有模块都接上去，确实方便。其他三种类型控制卡也有各自的特色，所以都并行存在于主流市场

### 总线控制卡

+ 常见的总线接口有，**EtherCAT**、CAN、Modbus、Profinet、EPA、SERCOS-Ⅲ等。
+ 总线有这么多种，他们之间是否有联系，又有哪些区别呢？这是我们学习总线之前需要搞清楚的问题，不然总是会心里没底，或者是错误的把总线混搭一起，这些是新手的必经之路。

+ 要想搞清楚不同总线之间的区别与联系，我们就得从总线通讯的组成或者是框架去看
  + 通讯的概念出现的很早，早期的电话电报就是一种通讯方式，但工业上的通讯应用都是OSI七层模型。OSI(open system interconnect)即开放系统的互连，这个是二十世纪七十年代的产物，当时就是为了解决各系统之间通讯的问题。
  + OSI七层模型图，从模型中我们可以看到，通讯最终是转化为比特流发送出去，我们说的通讯速率就是比特流的速率，比如百兆网络100Mbit/s。比特流的传输载体是物理层，是我们看的见摸得着的线缆以及接口芯片等。
  + 物理层往上是数据链路层，数据链路层的职责是负责将具体的数据转化成比特流，然后通过物理层的硬件发送。可以简单理解为，硬件的编码与解码，比如要发送数字8，那么数字8的比特流高低电平是怎样的；当收到一串比特流后，应该转换为哪个数字，这个就靠数据链路层完成的，数据链路层也是硬件。 
  + 数据链路层再往上，还有五层。这五层都有一个特点，他们都是软件层，是运行在处理器上的软件代码，这五层完成数据报的解析，编组，归类，最终到显示。
+ 当我们用因特网看视频时，这些层就在周而复始发送请求，解析数据，并最终刷新到显示界面。这五层搞起来确实有点复杂，有些时候其实是不需要的，比如我们知道数据的具体含义，我们就不需要再去分组整理数量，直接使用即可，工业通讯应用正是符合这个特点。
+ 尤其是针对运动控制或者过程控制总线，层太多不仅没用，反而会增加成本，并且运动控制或者过程控制这种专用总线上数据的含义都是严格一一对应的，不需各种分组分段解析啥的。所以，将五层压缩为一层，叫应用层。

+ 物理层，数据链路层，应用层都有各自的功能，三层功能没有重叠部分。
+ 发送工作流程是当数据到达后应用层后把数据放到对应的存储区，数据需要发送时到对应区域取出数据，交给数据链路层，比特流经物理层发送出去；
+ 接收工作流程就是反过来，物理层上的比特流被数据链路层解析为正确的数值，放到对应的存储区域，应用层需要数据的时候取走数据即可。
+ 所以，运动控制或者过程控制总线，这种专用总线都是三层模型，三层模型的功能：
  + 应用层：搬运数据，完成控制功能
  + 数据链路层：承上启下，生成比特流，以及解析比特流
  + 物理层：比特流传输载体

+ 当我们接触或者学习新的总线时，主要是搞清楚总线的框架，即这三层的情况是怎样的。只有搞清楚了这三层，你才不会被各种新鲜名词所吓倒，你才不会去随便混搭总线。搞清楚了总线通讯模型后，我们看下当前最火的两个总线，EtherCAT和CAN总线。
+ 为什么EtherCAT和CAN总线这么火？

#### CAN总线

+ 首先，是CAN总线起步早，博世公司1986年推出，当时主要是面向汽车行业。注意这里我说的是CAN总线，不是CANOPEN总线，CANOPEN只是基于CAN总线的应用层协议，汽车行业基于CAN总线的应用层协议是J1939。经过汽车行业的多年应用，大家发现这个总线的优点很多，速度快，1Mbit在现在看确实不快，但在那个年代还是非常牛的；有COB-ID，有仲裁机制，高优先级的数据可以先传输，低优先级是数据后发送，排队的数据在总线空闲的时候会自动发送，无需人为干预；差分传输，数据传输可靠性高；理论上可以在总线上挂任意多节点；成本低，几块钱的MCU就自带CAN控制器，现在一般同时支持CAN2.0A和2.0B。
+ 既然CAN总线有这么多优点，那就得充分利用上，紧接着有个组织叫CIA(CAN in Automation)起草了基于CANopen的设备及通讯子协议定义DS 301(Draft Standard 301)，也就是我们经常说的301协定。DS301只是CANopen的一个基础规范，具体到细分领域有，I/O模组的DS401，运动控制的DS402。讲到这里就出现了我们期盼已久的CANopen协议，之所以火就是因为起步早，又赶上了电机运动控制的蓬勃发展时期，靠谱好用，便宜，易上手。其实基于CAN总线的应用层协议还有北美船舶行业通讯协议，广州周立功公司的iCAN，但这个两个协议都不在运动控制系统中出现。其实协议就是这么简单，你也可以基于CAN总线创立自己的协议，只要有人用，你就很了不起。
+ 这里简单讲下CANopen DS402的相关知识，方便我们后面的理解。DS402里面有一些概念，对象字典，Node-ID，COB-ID，SDO，PDO，NMT，Heartbeat，状态机，Master，Slave，我们都简单介绍下。
  + DS402中规定网络中各设备是主从关系，即Master-Slave模式，原则上只能有一个Master，负责整个网络的管理。其实CAN总线上的都是节点，没有主从的概念，主从的概念是在DS402中规定的，这一点我们要清楚。
  + **对象字典我们可以理解为寄存器表**，只不过DS402已经规定了这个寄存器表的组织结构，包括一部分地址必须给协议使用，如0x6040,0x6041这些都是规定好的。有了对象字典我们就知道每个对象代表的是什么意思，每个厂家都按这个去设计。传输数据的时候我们得知道这个是哪个从站设备的数据，就需要有个Node-ID，简单说就是设备的编号。
  + 假如不同设备同时要传输同样对象字典的数据，那我们该怎样区分呢？这个时候就有COB-ID，COB-ID是对应的编码加上Node-ID，如0x600表示SDO读，对应节点1组合后的COB-ID就是0x600+0x01=0x601，节点2则为0x602，以此类推。这样我们就可以通过COB-ID来直接操作数据了，而无需关心是哪个节点的，如果数据同时需要发送，那么总线的仲裁机制就会起作用，COB-ID越小的优先级越高，优先发送，等待的数据在前面的数据发送完之后会自动重发。

+ 数据的传输分为两种
  + 一种是SDO，就是有问才有答，查询一次回复一次，类似服务生一样。
  + 另一种是PDO，叫过程数据，提前配置好了数据的传输方式后数据就会自动上传，如可以设置数据的最小间隔时间，同步、异步、RTR等。
+ SDO和PDO都是为了传输数据，但PDO传输的是过程数据，更精简，传输数据的效率会更高，**如循环同步模式肯定是PDO传输数据**
+ NMT是网络管理的意思，主站负责管理整个网络，如各节点的状态切换等。
+ 状态机是控制节点切换的，如在非使能状态到使能状态应该怎么响应，这个是状态机管理的。
+ 最后一个是Hearbeat，当然也有NodeGuarding，这两个都是反馈节点的状态。当总线在工作的时候我们得知道节点是否还在线，Hearbeat就类似我们的心跳，间隔多长时间必须收到一次心跳，超出设定时间没收到心跳则表示该节点已死亡。
+ NodeGuarding是另外一种监测方式，它有主站和从站的互动，这是不同于Hearbeat的，就是主站要发命令给从站，从站也要回应命令，也是要求在规定的时间内，目前Hearbeat用的更多一些。

#### EtherCAT总线

+ EthterCAT的字面意思就是以太网自动化控制技术。简单点说就是基于以太网，完成自动化控制功能，但肯定与普通以太网还是有区别的。
+ 他们的传输介质是一样的，都是RJ45网口+网线，但EtherCAT网络的数据链路层芯片是专门设计的，其目的是为了提高总线的性能。比如，增加了DC同步单元，数据自动转发，还有FMMU单元，SM单元，详细的情况可以去查询相关资料。
+ DC同步单元的时钟都是ns为单位，可以满足非常高的同步要求，然后以太网的通讯速度又非常快，现在1000Mbit/s都已经不是事了，在每个传输周期可以有非常大量的数据交互。这些都是基于硬件的，做应用的人可以不用关心，我们还是讲讲上层协议。
+ 对硬件感兴趣的可以参考AX58100、ET1100芯片的数据手册，山东大学李正军教授的《EtherCAT工业以太网应用技术》非常不错，里面有详细的介绍，值得一看，这里就不展开讲了。

+ 基于EtherCAT总线的应用层协议有FoE、CoE、SoE、EoE、AoE、VoE，各个协议的具体描述如下表2-2：
  + FoE, File over EtherCAT     --  在EtherCAT总线上传输文件的协议
  + CoE, CANopen over EtherCAT  --  在EtherCAT总线上执行CANopen协议
  + SoE, SERCOS over EtherCAT   --  在EtherCAT总线上执行SERCOS协议
  + EoE, Ethernet over EtherCAT --  在EtherCAT总线上执行Ethernet协议
  + AoE  --  访问底层现场总线的从站设备的对象字典，如对连接到EtherCAT-CAN网关设备的CAN从站
  + VoE  --  供应商自定义协议，基于邮箱
+ 这些都是运行在EhterCAT总线基础上的应用层协议，各个协议分管与自己相关的工作。
+ 我们现在常用的EtherCAT伺服驱动器，说白了就是把CANopen应用层协议搬到了EtherCAT总线之上。由于EhterCAT总线的高传输速度，所以这个时候可以有更高的控制信号频率，就会有更好的控制效果。
+ 讲到这里，我们可以发现，同样的协议可以在不同的总线上，同样的总线也可以用不同的协议。所以，**当我们讨论总线的时候也要讨论总线的应用层协议**，即我们前文提到的三层模型，只有三层模型都一样的系统才能完美对接。对总线就介绍这么多，原理都是一样的，其他总线可以按照这个方法学习，事半功倍。
+ 有了这样可靠性高，同步性好，控制频率可以很高的总线，现在控制指令的频率到8Khz已经不是问题了。控制卡的指令就可以很快很准的发送给总线上的驱动单元，最终达到好的控制效果。总线型控制系统的所有指令，位置反馈，指示状态，错误代码等等，都是由通讯来完成交互的，这一点和传统的控制方式有很大的区别。

## 驱动支持的各种模式详解

+ 早期非总线的驱动器一般是支持三个工作模式，位置模式，速度模式和电流模式，这个都比较简单，配置好模式，给对应的指令即可工作。
+ 这些模式一般都可以接收模拟量和PWM命令，位置模式还可以接收脉冲命令，这个就不展开讲了，参对应驱动的手册即可知道特定模式支持哪些类型的命令输入。这种驱动最大的缺点就是接线复杂，控制卡离驱动不能太远，还需要考虑控制线缆抗干扰，不利于分布式现场的情况。这种一般是应用于小型独立式设备，设备相对比较小，线缆不会太长，干扰问题比较好解决。

+ 随着总线型驱动器的出现，驱动器的工作模式增加了好几个。没有特殊说明的话，这里的总线指的是CAN总线和EtherCAT总线。
+ 基于这两个总线的驱动器一般都支持如表3-1所示的模式，当然还有PVT模式，IPM模式，但这些现在已经都不太常见了，有需要的可以查阅相关资料。   
  + HM   --  回零模式
  + PVM  --  带规划的速度模式
  + PPM  --  带规划的位置模式
  + CSP  --  循环同步的位置模式
  + CSV  --  循环同步的速度模式
  + CST  --  循环同步的转矩模式

+ HM模式是回零模式，驱动器已经内置好了各种回零方式。如先找负限位再找index方式；用限位作为回零原点方式；碰到硬限位回零方式等等。这些回零方式的程序已经在驱动器内部实现好了，我们只需要配置好相关参数，启动回零即可，回零过程都是驱动器内部程序完成。同时，也有状态变量可以监控当前的回零状态，是否完成，是否有报错等。
+ PVM和PPM是带规划的速度和位置模式，规划的意思就是根据用户设定的加减速度去启动和停止运动。这个两个模式很简单，有点像非总线伺服驱动器的速度模式和位置模式，这里不详细介绍了。
+ 我们重点介绍下循环同步模式，循环同步的意思就是以一个固定的时间间隔，周而复始的发送数据和同步指令。为什么要搞这个玩法呢？PVM PPM不香吗？这是我们学习新知识前需要考虑的问题，搞清楚了背景，理解起来会更有帮助。
  + 我们先想下，控制卡+非总线伺服驱动器是怎样实现多轴同步的，是多个驱动的控制命令在同一个DSP中运算，这样时间上就不会有偏差，确保每次都是几乎同一时间把指令发送给驱动器。如果是多个DSP有各自控制的驱动器，这些驱动器之间做同步运动，比如插补，效果都会差于一个DSP内部轴同步的效果，除非你把多个DSP任一时刻都同步起来，同样的时间做同样的运算，这样也许会是一样的效果。
  + 而我们这里说的循环同步就是干这个事情，总线型驱动器与控制卡或者叫master之间的连接只有一条通讯线，无论这条通讯线是CAN总线的半双工，或是EtherCAT总线的全双工，再加100Mbit/s的带宽，数据传输总会有先后顺序，这个事实没法改变。假如总线上的所有驱动器都以收到指令数据的那一刻去执行指令，那么驱动器之间就无法很好同步了。
  + 那么应该怎么办呢？人是真的聪明，总会想办法去解决问题，天才的工程师提出了一个解决方案。所有驱动器都先收指令数据，但不要立马执行，等待一个命令再执行，这个就是同步命令，这样就完美的解决了总线上数据传输有先后顺序的问题。大家都是先把数据准备好，然后等待同步命令，这个就好比百米赛跑一样，大家都先准备好，等待发令枪再跑，这样就是公平的。至于最终跑的结果怎样看个人水平，驱动器最终执行的效果怎样也是看驱动器的性能，感觉这个启发真是源于生活，最终又服务于生活。

+ 讲完什么是循环同步后，我们看下循环同步的三个模式到底是啥。
+ 首先说CSP，循环同步的位置模式：
  + 这个模式接收的是控制卡下发的位置指令，但这个位置不是随便发的，需要根据位置轨迹解算为一个一个点，这个是需要上位机解算的。
  + 上位解算点的这个过程叫粗插，就是粗线条的给出一些点，这些点不是驱动伺服环路能直接使用的，驱动器在接收到这些点后需要再进行精插，最终变成伺服环路能直接执行的位置点。
  + 精插是相对于粗插来说的，精插是以伺服周期为基准时间单位，精细的将轨迹分成很多个位置点，形成一个位置表，每个伺服周期去这个表中取一个值执行即可。
  + 我们以一个T形加减速，有匀速过程的点到点运动为例来剖析CSP模式的细节。如图3-15，是一个点到点运动，位置—时间和速度—时间关系图，加速和减速阶段的轨迹是曲线，匀速阶段是直线。再看下位置图中的插值点，这些点之间的时间是均匀间隔的，每到一个时间点位置轨迹与时间轴围成一个面积，这个面积就是我们在CSP模式发送给驱动器的位置指令，随着时间的增加，这个面积会越来越大。
  + 只要这些插值点是均匀的，指令发送的时间是准确的，满足这两个条件的情况下，电机的转动必然是平滑的。这两个条件中的任何一个不满足，电机的转动都是会顿挫的。
  + 如果插值点不均匀，比如有的时候插值点是间隔10ms，有的时候插值点是20ms。最明显的结果就是电机运动不平滑，那么为什么会不平滑呢？我们知道位置轨迹连续则位置轨迹的导数或者叫曲线的曲率才不会有突变，位置轨迹导数对应着的是速度，速度不突变则电机运转平稳。如果我的插值点时间突然增加或者缩短，则必然会导致曲率突变，这是上位在解算轨迹点需要注意的问题。
  + 尤其是任意轨迹曲线，曲率的突变非常厉害，即使在均匀的插值情况下，电机运转可能都会抖动明显。所以，对任意曲线的插值，还有需要针对锐角以及曲率突变的点做优化，比如用圆弧过度锐角，或者降低运动速度。
  + 到这里我们对CSP的整个细节基本讲完了，在使用过程中，我们还需注意循环同步指令的周期以及指令到达是否准时。指令的周期不应过短，要让驱动器有精插的空间，比如驱动伺服环路400us，那么你就不要给低于400us的同步周期，当然很多驱动也不支持这么短的同步周期，即使支持也不要这样给。同步指令要有硬时性，或者实时性好，我们一般以us为单位，尽可能的准时，指令不准时同样会导致电机运动的时候顿挫严重，甚至驱动器报错。
  + 到这里我们讲完了整个CSP模式的要点，在使用CSP模式的时候如果电机运转不平滑，该怎样去找问题，这才是我们要关注的核心。看到这里应该有一种豁然开朗的感觉，就证明你完全理解了循环同步位置模式的精髓。

+ 讲完CSP模式，后面的CSV和CST模式就简单了，我们先看看CSV模式：
  + CSV是循环同步的速度模式，控制卡下发的是速度指令，这个速度指令和位置指令一样，也不是随便给的。需要对速度曲线进行插值，解算每个周期应该给驱动的速度指令，对位置轨迹求导数就是速度，也就有了速度曲线。
  + 同CSP一样，控制卡或者上位也只是粗插，伺服环路还会根据指令和周期的时间进行精插，最终就变成了伺服环路可以执行的指令。
  + 同样，CSV模式对指令的实时性要求同CSP一样，不准时的指令就会导致电机运转的时候顿挫，顿挫就是速度突变造成的，分析方法和CSP模式一样，这里不再赘述

+ 看完CSV，我们再看看CST：
  + 这个模式和前面两个的共同之处是都为循环同步模式，不同之处是CST模式的指令直接被伺服环路所用，中间没有精插的过程。由于这个不同，CST模式的指令实时性不好的时候我们也很难发现，因为CST模式对应的是电机的电流，电流对应的是电机的输出转矩，电流的突变就是转矩的突变。
  + 转矩的是突变对应三种情况：
    + 一种是电机输出转矩大于负载转矩，电机加速
    + 另一种是电机输出转矩等于负载转矩，电机还是静止；
    + 甚至是电机输出转矩小于负载转矩，电机被负载拖动，运动控制中这种一般很少
  + 指令实时性不好很难被发现，并不是说CST模式对指令实时性没有要求，既然叫循环同步模式，那就是有这个要求。

+ 总结下三个循环同步模式，循环同步模式的出现，使得我们对任意轨迹的指令规划变得非常方便，就是对曲线插值，获得各时刻应该下发的指令。它使我们更加靠近了伺服环路的工作原理，伺服环路其实也是一直在插，不断的解算各个伺服周期的命令，然后算法以读表的方式不断的读取各个周期的指令。
+ 讲到这里，整个驱动器的相关知识就介绍完了。简单总结就是，驱动器有硬件和固件两部分，硬件部分负责控制电机的换向，电流调节，反馈信号采集等；固件部分或者叫软件部分，则是通过硬件的各种反馈信号，周而复的运算，并将运算结果输出到硬件。其实整个伺服系统工作的过程，就是一个不断纠偏的过程，大了就小点，小了就大点，没有真正的静止，一直运动，只是在几个脉冲来回移动，这才是伺服系统的精髓，没有真正的静止。

## EtherCAT 配置流程

1. init master
2. init slave
3. init pdo
4. init pdo_entry
5. config pdo_entry
6. config pdo
7. config slave 
8. config master
9.  config sdo
10. lock memory
11. start master
12. start slave

## EtherCAT 通讯流程

1. master receive 
2. slave receive 
3. pdo read update
4. control strategy
5. pdo write update
6. master sync
7. slave send 
8. master send

## PDO 

+ pdo 可以分为三级
  + SM(sync manager)，每个SM可以同步多个 pdo
  + pdo，每个 pdo 包含多个 pdo entry
  + pdo entry，每个 pdo entry 对应一个 index 和 subindex
