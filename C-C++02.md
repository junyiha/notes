## C/C++判断变量的类型

+ C++判断变量类型：利用`typeid()`来判断变量类型
  + `#include <typeinfo>  typeid(var).name()`

+ C语言中，**没有判断变量类型的函数**
+ 可以简单利用`sizeof()`或者`ASCII`码辅助判断
  + 表达式`sizeof()`可以得到对象或类型的存储字节大小，但是不同操作系统可能存在差异

## __sync_fetch_and_add系列

+ 作用：提供多线程下变量的加减和逻辑运算的原子操作  
+ 存在原因：
  + `count++`这种操作不是原子的。一个自加操作，本质上是分成三步的：
    + 从缓存取到寄存器
    + 在寄存器加1
    + 存入缓存
  + 由于时序的因素，多个线程操作同一个全局变量，会出现问题。这也是并发编程的难点。在目前多核条件下，这种困境会越来越彰显出来
  + 最简单的处理办法就是加锁保护。
  + 使用`__sync_fetch_and_add`，对于多线程对全局变量进行自加，就不用线程锁了
  + `__sync_fetch_and_add`系列的处理速度是线程锁的6-7倍
+ `__sync_fetch_and_add`系列一共有是十二个函数，有加/减/与/或/异或/等函数的**原子性操作函数**
+ `__sync_fetch_and_add`，顾名思义，先fetch，然后自加，返回的是自加之前的数值。
  + 以`count = 4`为例，调用`__sync_fetch_and_add(&count, 1)`之后，返回值是4，然后，count变成了5
+ 全部函数：
  ```
    type __sync_fetch_and_add (type *ptr, type value);
    type __sync_fetch_and_sub (type *ptr, type value);
    type __sync_fetch_and_or (type *ptr, type value);
    type __sync_fetch_and_and (type *ptr, type value);
    type __sync_fetch_and_xor (type *ptr, type value);
    type __sync_fetch_and_nand (type *ptr, type value);
    type __sync_add_and_fetch (type *ptr, type value);
    type __sync_sub_and_fetch (type *ptr, type value);
    type __sync_or_and_fetch (type *ptr, type value);
    type __sync_and_and_fetch (type *ptr, type value);
    type __sync_xor_and_fetch (type *ptr, type value);
    type __sync_nand_and_fetch (type *ptr, type value);
  ```
+ 这些都是在**C++11**以后支持的

+ 由一个概念叫做：**无锁化编程**，知道Linux支持的哪些操作是具有原子特性的是理解和设计无锁化编程算法的基础
+ 如果是想使用全局变量来做统计操作，而又不得不考虑多线程间的互斥访问的话，最好使用编译器支持的原子操作函数。在满足互斥访问的前提下，编程最简单，效率最高
+ `lock-free`，无锁编程方式确实能够比传统加锁方式效率高。所以在**高并发程序中采用无锁编程的方式可以进一步提高程序效率。但是得对无锁方式有足够熟悉的了解，不然效率反而会更低而且容器出错。**

+ 无锁编程与分布式编程
  + 无锁编程主要是使用原子操作替代锁来实现对共享资源的访问保护
  + 在多核系统中，因为多个CPU核在物理上是并行的，可能发生同时写的现象；所以必须保证一个CPU核在对共享内存进行写操作时，其他CPU核不能写这块内存。因此在多核系统中和单核有区别，即时只有一条执行，也需要加锁保护
  + 在无锁编程环境中(Lock-free)，主要使用的原子操作为`CAS(Compare and Swap)`操作。使用这种原子操作替代锁的最大的一个好处是**它是非阻塞的**。
  + 分布式编程设计的主要特征是**分布和通信**。
    + 采用分布式程序设计方法设计程序时，一个程序由若干个可独立执行的程序模块组成。这些程序模块分布于一个分布式计算机系统的几台计算机上同时执行。
    + 分布在各台计算机上的程序模块是相互关联的，它们在执行中需要交换数据，即**通信**。只有通过通信，各程序模块才能协调地完成一个共同的计算任务。
    + 采用分布式程序设计方法解决计算问题，必须提供用以进行分布式程序设计的语言和设计相应的分布式算法。
    + 分布式程序设计语言与常用的各种程序设计语言的主要区别：在于它具有程序分布和通信的功能。**因此，分布式程序设计语言，往往可以由一种程序设计语言增加分布和通信的功能而构成**。
    + 分布式算法和适用于多处理器系统的并行算法，都具有并行执行的特点，但它们是有区别的。
      + 设计分布算法时，必须保证实现算法的各程序模块间不会有公共变量，它们只能通过通信来交换数据。此外，设计分布式算法时，往往需要考虑坚定性，即**当系统中几台计算机失效时，算法仍然是v有效的。

## C++字符串和数字的拼接

+ `std::to_string()`
  + 通过`std::to_string()`可以将数字类型转换成`std::string`类型，从而可以直接使用`+`完成字符串的拼接
  + 需要注意的是，`std::string`是C++11才有的方法，在g++编译的时候需要指定`-std=c++11`

+ `c_str()`
  + 如果想要转换为`const char*`的类型，可以使用`c_str()`的方法
    + `std::string str = "hello 1"; str.c_str();`

+ `const_cast`
  + 如果想要去除const属性，需要使用到`const_cast`
    ```
      std::string str = "hello 1"; str.c_str();
      const char* const_char_str = str.c_str();
      std::cout << const_char_str << std::endl;

      char* char_str = const_cast<char*>(const_char_str);
      std::cout << char_str << std::endl;
    ```

## C++类的对象调用成员函数

+ 点
  + **变量名**所指向其成员时使用

+ 箭头
  + **地址**所指向其成员时使用

+ `A *p; p->play()` : 左边是**结构指针**
+ `A p; p.play()` : 左边是**结构变量**
+ 总结：
  + 箭头`->` : 左边必须为指针
  + 点号`.` : 左边必须为实体

## C++中用`new`和不用`new`创建类对象

+ `new`创建类对象，使用完需要使用`delete`删除，和申请内存类似。
+ `new`创建类对象和不使用`new`的区别
  + `new`创建类对象需要指针接收，一处初始化，多处使用
  + `new`创建类对象使用完需要使用`delete`销毁
  + `new`创建对象直接使用堆空间，而局部不用`new`定义类对象则使用栈空间
  + `new`对象指针用途广泛，比如作为函数返回值，函数参数等
  + 频繁调度场合并不适合new，就像new申请和释放内存一样

+ 普通创建方式，使用完后不需要手动释放，该类析构函数会自动执行；而`new`申请的对象，则只有调用到`delete`时才会执行析构函数，如果程序退出而没有执行`delete`，则会造成内存泄漏。

+ 只定义类指针：
  + 这跟不用new声明对象有很大区别：类指针可以先行定义，但是类指针只是一个通用指针，在`new`之前并未对该类对象分配任何内存空间。
  + 使用普通方式创建的类对象，在创建之初就已经分配了内存空间，而类指针，如果没有经过对象初始化，则不需要`delete`释放

## vsscanf()

+ `int vsscanf(const char* s, const char* format, va_list arg);`
+ 功能：**将格式化数据从字符串读取到变量参数列表中**。从s读取数据并根据参数格式将它们存储到由arg标识的变量参数列表中的元素所指向的位置。
  + 在内部，该函数从由arg标识的列表中检索参数，就好像在其上使用了`va_arg`一样，因此`arg`的状态可能会被调用更改。
  + 无论如何，`arg`应该在调用之前的某个时间点由`va_start`初始化，并且预计在调用之后的某个时间点由`va_end`释放。
+ 参数
  + `s` -- 函数将其处理为检索数据的源的C字符串
  + `format` -- 包含**格式字符串**的C字符串，该格式字符串遵循与`scanf`中的格式相同的规范
  + `arg` -- 一个值，用于标识使用`va_start`初始化的变量参数列表。`va_list`是在`<cstdarg>`中定义的特殊类型。
+ 返回值：
  + 成功时，该函数返回参数列表中成功填充的项目数
  + 在匹配失败的情况下，此计数可以匹配预期的项目数或更少，甚至为零。
  + 如果在成功解释任何数据之前输入失败，则返回EOF

## tuple,元组

+ 简介：
  + `tuple`是一个固定大小的不同类型值的集合，是泛化的`std::pair`。可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更加简洁，直观。`std::tuple`理论上可以有无数个任意类型的成员变量，而`std::pair`只能是2个成员，因此在需要保存3个及以上的数据时就需要使用`tuple`元组

+ `template <class... Types> class tuple;`
+ 元组是能够保存元素集合的对象。每个元素可以是不同的类型
+ 模板参数：
  + `Types...` -- 用于元素的类型列表，其顺序与它们在元组中的排序顺序相同

## auto

+ C++11引入了auto和decltype关键字实现类型推导，通过这两个关键字不仅能方便地获取复杂的类型，而且还能简化书写，提高编程效率。

## 类和动态内存分配

+ C++如何增加内存负载？
  + 假设要创建一个类，其一个成员表示某人的姓。最简单的方法是使用字符数组来保存，但这种方法有一种缺陷。开始也许会使用一个14个字符的数组，然后发现数组太小，更保险的方法是，使用一个40个字符的数组。然而，如果创建包含2000个这种对象的数组，就会由于字符数组只有部分被使用而浪费大量的内存（**在这种情况下，增加了计算机的内存负载**）。
+ **通常，最好是在程序运行时（而不是编译时）确定诸如使用多少内存等问题**。对于在对象中保存姓名来说，通常的C++方法是：在类构造函数中使用new运算符在程序运行时分配所需的内存。

+ 在构造函数中使用new来为字符串分配空间，这避免了在类声明中预先定义字符串的长度
+ 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员。这对于所有类对象都具有相同值的类私有数据是非常方便的。

+ 在构造函数中使用`new`来分配内存时，必须在相应的析构函数中使用`delete`来释放内存。如果使用`new[]`（包括中括号）来分配内存，则应使用`delete[]`（包括中括号）来释放内存。


## std::get()

```
  (1)template <size_t I, class... Types> typename tuple_element<I, tuple<Types...>>::type& get(tuple<Types...>& tpl) noexcept;
  (2)template <size_t I, class... Types> typename tuple_element<I, tuple<Types...>>::type&& get(tuple<Types...>&& tpl) noexcept;
  (3)template <size_t I, class... Types> typename tuple_element<I, tuple<Types...>>::type const& get(tuple<Types...>& tpl) noexcept;
```

+ 功能：返回对元组`tpl`的第`I`个元素的引用。
  + 版本2将元组的右值作为引用参数，向前应用到返回的元素
  + 版本3将const元组作为参数，返回对元素的const引用
+ 参数
  + `I` -- 元组中元素的位置，0为第一个元素的位置，`size_t`是无符号整数类型
  + `Types` -- 元组中元素的类型（通常从tpl隐式获得）
+ 返回值
  + 对元组中指定位置的元素的引用

## 内存模型和名称空间

+ C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据（作用域和链接）等。可以使用new来动态地分配内存，而定位new运算符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。
+ 通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据。这样的程序涉及到程序文件的单独编译。

### 单独编译

+ 和C语言一样，C++也允许甚至鼓励程序员将**组件函数**放在独立的文件中。

+ 与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构声明时，只需要在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。
+ 原来的程序分成三部分：
  + 头文件，包含结构声明和使用这些结构的函数的原型
  + 源代码文件，包含与结构有关的函数的代码
  + 源代码文件，包含调用与结构相关的函数的代码

+ 头文件中常包含的内容：
  + 函数原型
  + 使用`#define`或`const`定义的符号常量
  + 结构声明
  + 类声明
  + 模板声明
  + 内联函数

### 存储持续性，作用域和链接性

+ C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间
  + **自动存储持续性** -- 在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。
  + **静态存储持续性** -- 在**函数定义外**定义的变量和使用关键字`static`定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有三种存储持续性为静态的变量。
  + **线程存储持续性（C++11）** -- 当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字`thread_local`声明的，则其声明周期与所属的线程一样长。（并行编程）
  + **动态存储持续性** -- 用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束位置。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)

+ 作用域(scope)描述了名称在文件（翻译单元）的多大范围内可见。
+ 链接性(linkage)描述了名称如何在不同单元间共享。
  + 链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享
  + 自动变量的名称没有链接性，因为它们不能共享