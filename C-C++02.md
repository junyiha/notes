## C/C++判断变量的类型

+ C++判断变量类型：利用`typeid()`来判断变量类型
  + `#include <typeinfo>  typeid(var).name()`

+ C语言中，**没有判断变量类型的函数**
+ 可以简单利用`sizeof()`或者`ASCII`码辅助判断
  + 表达式`sizeof()`可以得到对象或类型的存储字节大小，但是不同操作系统可能存在差异

## __sync_fetch_and_add系列

+ 作用：提供多线程下变量的加减和逻辑运算的原子操作  
+ 存在原因：
  + `count++`这种操作不是原子的。一个自加操作，本质上是分成三步的：
    + 从缓存取到寄存器
    + 在寄存器加1
    + 存入缓存
  + 由于时序的因素，多个线程操作同一个全局变量，会出现问题。这也是并发编程的难点。在目前多核条件下，这种困境会越来越彰显出来
  + 最简单的处理办法就是加锁保护。
  + 使用`__sync_fetch_and_add`，对于多线程对全局变量进行自加，就不用线程锁了
  + `__sync_fetch_and_add`系列的处理速度是线程锁的6-7倍
+ `__sync_fetch_and_add`系列一共有是十二个函数，有加/减/与/或/异或/等函数的**原子性操作函数**
+ `__sync_fetch_and_add`，顾名思义，先fetch，然后自加，返回的是自加之前的数值。
  + 以`count = 4`为例，调用`__sync_fetch_and_add(&count, 1)`之后，返回值是4，然后，count变成了5
+ 全部函数：
  ```
    type __sync_fetch_and_add (type *ptr, type value);
    type __sync_fetch_and_sub (type *ptr, type value);
    type __sync_fetch_and_or (type *ptr, type value);
    type __sync_fetch_and_and (type *ptr, type value);
    type __sync_fetch_and_xor (type *ptr, type value);
    type __sync_fetch_and_nand (type *ptr, type value);
    type __sync_add_and_fetch (type *ptr, type value);
    type __sync_sub_and_fetch (type *ptr, type value);
    type __sync_or_and_fetch (type *ptr, type value);
    type __sync_and_and_fetch (type *ptr, type value);
    type __sync_xor_and_fetch (type *ptr, type value);
    type __sync_nand_and_fetch (type *ptr, type value);
  ```
+ 这些都是在**C++11**以后支持的

+ 由一个概念叫做：**无锁化编程**，知道Linux支持的哪些操作是具有原子特性的是理解和设计无锁化编程算法的基础
+ 如果是想使用全局变量来做统计操作，而又不得不考虑多线程间的互斥访问的话，最好使用编译器支持的原子操作函数。在满足互斥访问的前提下，编程最简单，效率最高
+ `lock-free`，无锁编程方式确实能够比传统加锁方式效率高。所以在**高并发程序中采用无锁编程的方式可以进一步提高程序效率。但是得对无锁方式有足够熟悉的了解，不然效率反而会更低而且容器出错。**

+ 无锁编程与分布式编程
  + 无锁编程主要是使用原子操作替代锁来实现对共享资源的访问保护
  + 在多核系统中，因为多个CPU核在物理上是并行的，可能发生同时写的现象；所以必须保证一个CPU核在对共享内存进行写操作时，其他CPU核不能写这块内存。因此在多核系统中和单核有区别，即时只有一条执行，也需要加锁保护
  + 在无锁编程环境中(Lock-free)，主要使用的原子操作为`CAS(Compare and Swap)`操作。使用这种原子操作替代锁的最大的一个好处是**它是非阻塞的**。
  + 分布式编程设计的主要特征是**分布和通信**。
    + 采用分布式程序设计方法设计程序时，一个程序由若干个可独立执行的程序模块组成。这些程序模块分布于一个分布式计算机系统的几台计算机上同时执行。
    + 分布在各台计算机上的程序模块是相互关联的，它们在执行中需要交换数据，即**通信**。只有通过通信，各程序模块才能协调地完成一个共同的计算任务。
    + 采用分布式程序设计方法解决计算问题，必须提供用以进行分布式程序设计的语言和设计相应的分布式算法。
    + 分布式程序设计语言与常用的各种程序设计语言的主要区别：在于它具有程序分布和通信的功能。**因此，分布式程序设计语言，往往可以由一种程序设计语言增加分布和通信的功能而构成**。
    + 分布式算法和适用于多处理器系统的并行算法，都具有并行执行的特点，但它们是有区别的。
      + 设计分布算法时，必须保证实现算法的各程序模块间不会有公共变量，它们只能通过通信来交换数据。此外，设计分布式算法时，往往需要考虑坚定性，即**当系统中几台计算机失效时，算法仍然是v有效的。

## C++字符串和数字的拼接

+ `std::to_string()`
  + 通过`std::to_string()`可以将数字类型转换成`std::string`类型，从而可以直接使用`+`完成字符串的拼接
  + 需要注意的是，`std::string`是C++11才有的方法，在g++编译的时候需要指定`-std=c++11`

+ `c_str()`
  + 如果想要转换为`const char*`的类型，可以使用`c_str()`的方法
    + `std::string str = "hello 1"; str.c_str();`

+ `const_cast`
  + 如果想要去除const属性，需要使用到`const_cast`
    ```
      std::string str = "hello 1"; str.c_str();
      const char* const_char_str = str.c_str();
      std::cout << const_char_str << std::endl;

      char* char_str = const_cast<char*>(const_char_str);
      std::cout << char_str << std::endl;
    ```