## tcflush

+ 简介：
  + tcflush()函数用于刷新串口输入输出缓冲区。它是与串口相关的函数，可用于清空或刷新串口的数据缓冲区

+ 原型：
```c
int tcflush(int fd, int queue_selector);
```

+ 参数：
  + fd：文件描述符，表示要刷新的串口
  + queue_selector：刷新队列的选择器，可以是以下值之一
    + TCIFLUSH：刷新输入队列，丢弃输入缓冲区中的数据
    + TCOFLUSH：刷新输出队列，丢弃输出缓冲区中的数据
    + TCIOFLUSH：刷新输入和输出队列，丢弃输入和输出缓冲区中的数据

+ 返回值：
  + 如果刷新成功，返回值为0
  + 如果刷新失败，返回值为-1，并设置errno变量以指示错误类型

+ 详解：
  + 使用tcflush()函数可以清空串口的输入和输出缓冲区，以便开始或终止数据传输之前进行必要的清理

+ 示例：
```c
#include <termios.h>
#include <stdio.h>

int main() {
    int serial_fd; // 串口文件描述符

    // 打开串口并设置相关参数...

    // 清空输入缓冲区
    if (tcflush(serial_fd, TCIFLUSH) == -1) {
        perror("Failed to flush input queue");
        return 1;
    }

    // 清空输出缓冲区
    if (tcflush(serial_fd, TCOFLUSH) == -1) {
        perror("Failed to flush output queue");
        return 1;
    }

    printf("Serial port input and output queues flushed\n");

    // 关闭串口...

    return 0;
}
```

+ 注：
  + 在上述示例中，我们首先打开串口并设置相关参数（未在示例中展示）。然后，我们使用tcflush()函数两次调用来分别清空输入和输出缓冲区。最后，我们关闭串口（未在示例中展示）
  + 请注意，上述示例仅演示了刷新串口缓冲区的情况。在实际应用中，你可能还需要进行其他串口操作，如读取或写入数据等。同时，还要注意进行错误处理，以检查函数调用是否成功

## cfsetospeed

+ 简介：
  + cfsetospeed() 函数用于设置串口设备的输出波特率。它是与串口相关的函数，用于配置串口的通信参数

+ 原型：
```c
int cfsetospeed(struct termios *termios_p, speed_t speed);
```

+ 参数：
  + termios_p：指向 termios 结构的指针，该结构包含了串口的配置参数
  + speed：要设置的输出波特率

+ 返回值：
  + 如果设置成功，返回值为 0
  + 如果设置失败，返回值为 -1，并设置 errno 变量以指示错误类型

+ 详解：
  + 使用 cfsetospeed() 函数时，通常需要先获取当前的串口配置参数，然后修改其中的输出波特率，最后将修改后的参数重新设置给串口

+ 示例：
```c
#include <termios.h>
#include <stdio.h>

int main() {
    struct termios term;
    
    // 获取当前的串口配置参数
    tcgetattr(STDOUT_FILENO, &term);
    
    // 设置输出波特率为 9600
    if (cfsetospeed(&term, B9600) == -1) {
        perror("Failed to set output baud rate");
        return 1;
    }
    
    // 将修改后的配置参数重新设置给串口
    if (tcsetattr(STDOUT_FILENO, TCSANOW, &term) == -1) {
        perror("Failed to apply serial port settings");
        return 1;
    }
    
    printf("Output baud rate set to 9600\n");
    
    return 0;
}
```

+ 注：
  + 在上述示例中，我们首先通过调用 tcgetattr() 函数获取当前的串口配置参数，并将其存储在 term 结构中。然后，我们使用 cfsetospeed() 函数将输出波特率设置为 9600。最后，我们调用 tcsetattr() 函数将修改后的配置参数重新应用到串口
  + 请注意，上述示例仅演示了设置输出波特率的情况。如果你还需要设置输入波特率，可以使用类似的方法调用 cfsetispeed() 函数进行设置。同时，还要注意进行错误处理，以检查函数调用是否成功

## cfsetispeed

+ 简介：
  + cfsetispeed() 函数用于设置串口设备的输入波特率。它是与串口相关的函数，用于配置串口的通信参数

+ 原型：
```c
int cfsetispeed(struct termios *termios_p, speed_t speed);
```

+ 参数：
  + termios_p：指向 termios 结构的指针，该结构包含了串口的配置参数
  + speed：要设置的输入波特率

+ 返回值：
  + 如果设置成功，返回值为 0
  + 如果设置失败，返回值为 -1，并设置 errno 变量以指示错误类型

+ 详解：
  + 使用 cfsetispeed() 函数时，通常需要先获取当前的串口配置参数，然后修改其中的输入波特率，最后将修改后的参数重新设置给串口

+ 示例：
```c
#include <termios.h>
#include <stdio.h>

int main() {
    struct termios term;
    
    // 获取当前的串口配置参数
    tcgetattr(STDIN_FILENO, &term);
    
    // 设置输入波特率为 9600
    if (cfsetispeed(&term, B9600) == -1) {
        perror("Failed to set input baud rate");
        return 1;
    }
    
    // 将修改后的配置参数重新设置给串口
    if (tcsetattr(STDIN_FILENO, TCSANOW, &term) == -1) {
        perror("Failed to apply serial port settings");
        return 1;
    }
    
    printf("Input baud rate set to 9600\n");
    
    return 0;
}
```

+ 注：
  + 在上述示例中，我们首先通过调用 tcgetattr() 函数获取当前的串口配置参数，并将其存储在 term 结构中。然后，我们使用 cfsetispeed() 函数将输入波特率设置为 9600。最后，我们调用 tcsetattr() 函数将修改后的配置参数重新应用到串口
  + 请注意，上述示例仅演示了设置输入波特率的情况。如果你还需要设置输出波特率，可以使用类似的方法调用 cfsetospeed() 函数进行设置。同时，还要注意进行错误处理，以检查函数调用是否成功

## tcgetattr

+ 简介：
  + tcgetattr() 是一个 C 函数，用于获取终端设备的属性。它用于读取终端设备的当前设置，并将这些设置存储在一个 termios 结构体中

+ 原型：
```c
int tcgetattr(int fd, struct termios *termios_p);
```

+ 参数：
  + fd：要获取属性的终端设备文件描述符。
  + termios_p：指向 termios 结构体的指针，用于存储终端设备的属性

+ 返回值：
  + tcgetattr() 函数会返回一个整数值，表示函数执行的结果。如果函数执行成功，则返回 0；否则，返回 -1，并设置相应的错误码

+ 详解
  + 使用 tcgetattr() 函数可以获取终端设备的属性，如输入输出模式、字符大小、超时设置等。可以通过修改 termios 结构体的成员来更改终端设备的属性，然后使用 tcsetattr() 函数将修改后的属性应用到终端设备上

+ 示例：
```c
#include <stdio.h>
#include <termios.h>
#include <unistd.h>

int main() {
    int fd = STDIN_FILENO; // 标准输入设备文件描述符

    struct termios term;
    if (tcgetattr(fd, &term) == -1) {
        perror("tcgetattr");
        return 1;
    }

    // 打印终端设备的属性
    printf("Input flags: %x\n", term.c_iflag);
    printf("Output flags: %x\n", term.c_oflag);
    printf("Control flags: %x\n", term.c_cflag);
    printf("Local flags: %x\n", term.c_lflag);

    return 0;
}
```

+ 注：
  + 这个示例程序获取标准输入设备的属性，并打印各个属性的值。

## ioctl 

+ 简介：
  + ioctl() 是一个系统调用函数，用于控制设备的操作，它在不同的设备和操作系统上有不同的功能和用法。在 C 语言中，可以使用 ioctl() 函数来发送命令给设备驱动程序，并执行特定的操作

+ 原型：
```c
#include <sys/ioctl.h>

int ioctl(int fd, unsigned long request, ...);
```

+ 参数：
  + fd：文件描述符，用于指定要进行控制的设备
  + request：控制命令，是一个无符号长整型数值，用于指定具体的操作
  + ...：可选参数，根据不同的控制命令可能需要提供额外的参数

+ 返回值：
  + ioctl() 函数的返回值通常为 0 表示操作成功，-1 表示操作失败，并通过 errno 变量来获取具体的错误信息

+ 详解：
  + 要使用 ioctl() 函数，需要事先了解设备的控制命令和参数的定义。不同的设备和操作系统可能有不同的命令和参数定义，因此需要参考相关的文档或设备驱动程序的头文件来获取正确的命令和参数定义

+ 示例
```c
#include <stdio.h>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>

int main() {
    int fd = open("/dev/ttyS0", O_RDWR);
    if (fd == -1) {
        perror("Failed to open serial port");
        return 1;
    }

    struct termios options;
    if (tcgetattr(fd, &options) == -1) {
        perror("Failed to get serial port options");
        close(fd);
        return 1;
    }

    cfsetispeed(&options, B9600);
    cfsetospeed(&options, B9600);

    if (tcsetattr(fd, TCSANOW, &options) == -1) {
        perror("Failed to set serial port options");
        close(fd);
        return 1;
    }

    close(fd);
    return 0;
}
```

+ 注：
  + 在上述示例中，首先使用 open() 函数打开串口设备文件 /dev/ttyS0，然后使用 tcgetattr() 函数获取当前的串口设置
  + 接下来使用 cfsetispeed() 和 cfsetospeed() 函数将输入和输出波特率设置为 9600。这里使用了波特率常量 B9600，具体的常量定义可以在 <termios.h> 头文件中找到
  + 最后使用 tcsetattr() 函数将修改后的串口设置应用到设备上，并关闭文件描述符
  + 这只是一个简单的示例，实际的 ioctl() 使用可能涉及更复杂的控制命令和参数，具体的用法和命令定义需要参考相关文档或设备驱动程序的说明

## ftruncate

+ 简介：
  + ftruncate() 函数是 C/C++ 中的一个文件操作函数，用于调整文件的大小

+ 原型：
```c
#include <unistd.h>

int ftruncate(int fd, off_t length);
```

+ 参数：
  + fd：文件描述符，指定要操作的文件。
  + length：要设置的新文件大小

+ 详解：
  + 函数功能：
    + 如果文件当前的大小大于指定的 length，则文件将被截断到指定的大小。
    + 如果文件当前的大小小于指定的 length，则文件将被扩展到指定的大小，并使用空字节填充扩展的部分。
    + 如果文件当前的大小等于指定的 length，则文件大小保持不变
  + 返回值
    + 如果调用成功，返回值为 0。
    + 如果调用失败，返回值为 -1，并设置相应的错误码，可以通过 errno 全局变量获取具体的错误信息。
  + 使用 ftruncate() 函数需要先打开文件，获取文件描述符 fd，然后调用该函数即可。请确保在使用该函数时具有足够的权限来修改文件大小

+ 示例
```cpp
#include <fcntl.h>
#include <unistd.h>
#include <iostream>

int main() {
    const char* filename = "example.txt";
    int fd = open(filename, O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return 1;
    }

    off_t new_size = 1024;  // New file size in bytes

    if (ftruncate(fd, new_size) == -1) {
        std::cerr << "Failed to truncate file" << std::endl;
        close(fd);
        return 1;
    }

    close(fd);

    std::cout << "File size adjusted successfully" << std::endl;

    return 0;
}
```

+ 注：
  + 上述代码打开名为 "example.txt" 的文件，将其大小调整为 1024 字节。如果调用成功，将输出 "File size adjusted successfully"。否则，将输出相应的错误信息
  + 请注意，使用 ftruncate() 函数时应格外谨慎，确保操作的文件和大小设置是正确的，以免意外丢失数据

## shm_unlink

+ 简介：
  + shm_unlink() 函数用于解除与共享内存对象的链接，并将其标记为待删除状态。具体来说，shm_unlink() 函数的作用是删除共享内存对象的名字，但并不立即释放共享内存资源，只有当所有打开该共享内存对象的文件描述符都关闭时，才会释放共享内存资源

+ 原型
```c
int shm_unlink(const char* name);
```

+ 参数：
  + 参数 name 是共享内存对象的名字，通过该名字可以标识和访问共享内存对象。

+ 详解：
  + 调用 shm_unlink() 函数后，如果成功解除链接并标记为删除，函数返回 0；如果发生错误，返回 -1，并设置对应的错误码

+ 示例：
```cpp
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>

int main() {
    const char* shm_name = "/my_shared_memory";

    // 打开共享内存对象
    int shm_fd = shm_open(shm_name, O_RDWR, 0666);
    if (shm_fd == -1) {
        // 错误处理
        return 1;
    }

    // 解除链接并标记为删除
    int result = shm_unlink(shm_name);
    if (result == -1) {
        // 错误处理
        return 1;
    }

    // 关闭共享内存对象
    close(shm_fd);

    return 0;
}
```

+ 注：
  + 在上述示例中，我们通过 shm_open() 打开了一个共享内存对象，然后调用 shm_unlink() 解除与该对象的链接并标记为删除。最后，通过 close() 关闭了共享内存对象的文件描述符
  + 需要注意的是，只有当所有打开共享内存对象的进程都解除链接后，该共享内存对象才会被真正删除。因此，在使用 shm_unlink() 函数时需要确保所有进程都已解除链接，以避免资源泄漏

## shm_open

+ 简介：
  + 在 C++ 中，shm_open() 函数用于创建或打开共享内存对象。它是 POSIX 共享内存机制的一部分，用于在不同进程之间共享内存数据。

+ 原型：
```c
int shm_open(const char* name, int oflag, mode_t mode);
```

+ 参数：
  + name：共享内存对象的名称，以字符串形式表示。在创建共享内存对象时，可以给它一个唯一的名称，以便其他进程可以使用相同的名称来访问该对象
  + oflag：打开标志，用于指定打开共享内存的方式。常用的选项包括 O_CREAT（如果共享内存对象不存在，则创建它）和 O_RDWR（可读写方式打开共享内存）等
  + mode：权限模式，用于设置共享内存对象的权限。只有在创建新的共享内存对象时才会使用该参数，它类似于 open() 函数中的文件权限参数

+ 详解：
  + shm_open() 函数返回一个整数值，代表共享内存对象的文件描述符。如果打开或创建共享内存对象成功，则返回非负整数值；否则返回 -1，并设置相应的错误码。

+ 示例：
```cpp
#include <iostream>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    // 共享内存对象的名称
    const char* name = "/my_shared_memory";
    
    // 创建或打开共享内存对象
    int fd = shm_open(name, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        std::cout << "Failed to create/open shared memory" << std::endl;
        return 1;
    }
    
    // 关闭共享内存对象的文件描述符
    close(fd);
    
    std::cout << "Shared memory created/opened successfully" << std::endl;
    
    return 0;
}
```

+ 注：
  + 在上述示例中，我们使用 shm_open() 函数创建或打开了一个名为 "/my_shared_memory" 的共享内存对象。通过指定 O_CREAT 和 O_RDWR 标志，我们创建了一个新的共享内存对象，并以可读写方式打开它。然后，我们关闭了共享内存对象的文件描述符，并输出一条成功的消息
  + 请注意，shm_open() 函数只是打开或创建共享内存对象，它并没有定义共享内存的大小或分配实际的内存空间。要分配内存空间并映射到共享内存对象，可以使用 mmap() 函数。同时，创建或打开共享内存对象后，应该适当处理错误情况并进行错误检查，以确保操作的成功
  + 在编译链接时，需要包含头文件`<sys/mman.h>`和链接库`librt.so`

## shmat

+ 简介：
  + shmat()函数用于将共享内存段连接到当前进程的地址空间。

+ 原型：
```c
#include <sys/types.h>
#include <sys/shm.h>

void *shmat(int shmid, const void *shmaddr, int shmflg);
```

+ 参数：
  + shmid：共享内存标识符，即共享内存段的标识符。
  + shmaddr：指定共享内存段连接到当前进程地址空间的地址。通常设置为NULL，让系统自动选择一个可用的地址
  + shmflg：标志位，用于指定共享内存段的连接方式和权限。可以使用SHM_RDONLY表示只读方式连接共享内存段，也可以使用0表示可读写方式连接

+ 详解：
  + shmat()函数的返回值是一个void*指针，指向共享内存段在当前进程地址空间的起始地址。连接成功时，返回指向共享内存段的指针；连接失败时，返回-1。

+ 示例：
```c
#include <stdio.h>
#include <sys/shm.h>

int main() {
    int shmid = 1234; // 共享内存标识符
    
    // 连接共享内存段
    void *shm_ptr = shmat(shmid, NULL, 0);
    if (shm_ptr == (void*)-1) {
        perror("shmat");
        return 1;
    }
    
    printf("Shared memory segment attached at address: %p\n", shm_ptr);
    
    // 在连接的共享内存段中读写数据
    int *data = (int*)shm_ptr;
    *data = 42;
    printf("Data in shared memory: %d\n", *data);
    
    // 断开共享内存段的连接
    int result = shmdt(shm_ptr);
    if (result == -1) {
        perror("shmdt");
        return 1;
    }
    
    printf("Shared memory segment detached\n");
    
    return 0;
}
``` 

+ 注：
  + 在这个示例中，我们首先使用shmat()函数将共享内存段连接到当前进程的地址空间。通过将shmaddr参数设置为NULL，让系统自动选择可用的地址进行连接。如果连接成功，返回的shm_ptr指向共享内存段在当前进程地址空间的起始地址
  + 接下来，我们可以在连接的共享内存段中进行读写操作。在示例中，我们将共享内存段当作一个整数变量来使用，将值42写入共享内存段，并从共享内存段中读取该值
  + 最后，我们使用shmdt()函数断开共享内存段的连接，将共享内存段从当前进程的地址空间中分离。注意，断开连接并不会删除共享内存段，只是将共享内存段从当前进程中移除。如果其他进程仍然连接到该共享内存段，它们仍然可以访问和修改共享内存数据
  + 需要注意的是，使用shmat()和shmdt()函数时需要确保当前用户对共享内存段具有足够的权限。另外，要小心处理共享内存的并发访问，使用同步机制来避免竞争条件和数据不一致的问题

## shmctl

+ 简介：
  + shmctl()函数用于控制和操作共享内存段的属性。

+ 原型：
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

+ 参数：
  + shmid：共享内存标识符，即共享内存段的标识符。
  + cmd：控制命令，用于指定对共享内存段的操作，可以是下列值之一：
    + IPC_STAT：获取共享内存段的状态信息，将共享内存段的信息存储在buf指向的shmid_ds结构体中。
    + IPC_SET：设置共享内存段的状态信息，将buf指向的shmid_ds结构体中的信息应用于共享内存段。
    + IPC_RMID：删除共享内存段，释放共享内存资源。
  + buf：用于存储共享内存段状态信息的结构体指针。

+ 详解：
  + 使用IPC_STAT命令可以获取共享内存段的状态信息，包括共享内存段的大小、创建者的用户ID、最后一次操作的时间等。这些信息被存储在shmid_ds结构体中，通过传递一个指向该结构体的指针作为buf参数来获取这些信息
  + 使用IPC_SET命令可以修改共享内存段的属性，比如更改共享内存段的权限、所有者等。需要将一个填充了新属性值的shmid_ds结构体指针传递给buf参数
  + 使用IPC_RMID命令可以删除共享内存段，释放相关的资源。注意，删除共享内存段并不会立即清除共享内存中的数据，只是使得该共享内存段不再可用。实际的共享内存段会在所有连接到它的进程都断开连接后被系统清理

+ 示例
```c
#include <stdio.h>
#include <sys/shm.h>

int main() {
    int shmid = 1234; // 共享内存标识符
    
    struct shmid_ds shm_info;
    
    // 获取共享内存段的状态信息
    int result = shmctl(shmid, IPC_STAT, &shm_info);
    if (result == -1) {
        perror("shmctl");
        return 1;
    }
    
    printf("Size of shared memory segment: %lu\n", shm_info.shm_segsz);
    printf("Owner's user ID: %d\n", shm_info.shm_perm.uid);
    printf("Last attach time: %ld\n", shm_info.shm_atime);
    
    // 修改共享内存段的权限
    shm_info.shm_perm.mode = 0666; // 设置权限为rw-rw-rw-
    result = shmctl(shmid, IPC_SET, &shm_info);
    if (result == -1) {
        perror("shmctl");
        return 1;
    }
    
    printf("Shared memory segment permissions updated successfully\n");
    
    return 0;
}
```

+ 注：
  + 在这个示例中，我们首先使用shmctl()函数和IPC_STAT命令获取共享内存段的状态信息，并将信息存储在shmid_ds结构体（shm_info）中。然后，我们打印出共享内存段的大小、所有者的用户ID以及最后一次附加到共享内存段的时间
  + 接下来，我们修改共享内存段的权限，将权限设置为0666，即读写权限对所有用户都可用。我们将新的权限信息存储在shm_info结构体中，并使用shmctl()函数和IPC_SET命令应用这些新的属性
  + 请注意，使用shmctl()函数进行修改操作时，需要确保当前用户对共享内存段具有足够的权限。另外，要小心使用IPC_RMID命令删除共享内存段，因为这将导致所有连接到该共享内存段的进程失去对它的访问权限

## shmdt

+ 简介：
  + shmdt()函数用于将共享内存段从当前进程的地址空间中分离，即将共享内存段与进程的连接断开

+ 原型：
```c
#include <sys/types.h>
#include <sys/shm.h>

int shmdt(const void *shmaddr);
```

+ 参数
  + shmaddr：共享内存段的起始地址，即附加到进程地址空间的地址。

+ 详解：
  + shmdt()函数将共享内存段从当前进程的地址空间中分离，并释放与共享内存段相关的资源。一旦共享内存段被分离，进程将无法再访问共享内存段中的数据。
  + 使用shmdt()函数时需要注意以下几点：
    + shmaddr参数应该是之前使用shmat()函数将共享内存段附加到进程地址空间时返回的地址
    + 成功执行shmdt()函数后，共享内存段与进程的连接被断开，但共享内存段本身并没有被销毁。其他进程仍然可以访问该共享内存段。
    + 如果多个进程共享同一个共享内存段，在一个进程中调用shmdt()函数分离共享内存段后，其他进程仍然可以继续访问该共享内存段。
    + 分离共享内存段后，可以使用shmctl()函数删除共享内存段。

+ 示例：
```c
#include <stdio.h>
#include <sys/shm.h>

int main() {
    int shmid = 1234; // 共享内存标识符
    
    void *shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void *)-1) {
        perror("shmat");
        return 1;
    }
    
    printf("Shared memory segment attached at address: %p\n", shmaddr);
    
    int result = shmdt(shmaddr);
    if (result == -1) {
        perror("shmdt");
        return 1;
    }
    
    printf("Shared memory segment detached successfully\n");
    
    return 0;
}
```

+ 注：
  + 在这个示例中，我们首先使用shmat()函数将共享内存段附加到进程地址空间，并获取共享内存段的起始地址（shmaddr）。然后，我们使用shmdt()函数分离共享内存段，断开进程与共享内存段的连接。如果分离共享内存段时出现错误，我们使用perror()函数打印相应的错误消息
  + 请注意，分离共享内存段后，进程将无法再访问共享内存段中的数据

## shmget

+ 简介：
  + shmget()函数是一个系统调用，用于创建或打开一个共享内存段。

+ 原型：
```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);
```

+ 参数
  + key：共享内存段的键值，通常由ftok()函数生成。
  + size：共享内存段的大小，以字节为单位
  + shmflg：共享内存段的访问权限和标志，可以是一个或多个标志的位或运算结果，如IPC_CREAT、IPC_EXCL等。

+ 详解
  + shmget()函数根据给定的键值和大小创建或打开一个共享内存段，并返回一个与共享内存段相关的标识符（shmid）。这个标识符可以用于后续的共享内存操作，如附加、分离、读写等。
  + 使用shmget()函数时需要注意以下几点：
    + key参数应该是一个与其他进程共享的键值，通常由ftok()函数生成。不同的key值将对应不同的共享内存段。
    + size参数指定了共享内存段的大小，即申请的内存空间大小。
    + shmflg参数用于设置共享内存段的权限和标志。常见的标志有IPC_CREAT表示创建新的共享内存段，IPC_EXCL表示只在共享内存段不存在时创建，0666表示权限设置为可读可写。
    + 如果成功创建或打开共享内存段，shmget()函数返回一个非负整数的共享内存标识符（shmid），用于后续的共享内存操作。
    + 如果共享内存段已经存在且没有指定IPC_EXCL标志，则返回已存在的共享内存标识符

+ 示例
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("/path/to/file", 1);
    if (key == -1) {
        perror("ftok");
        return 1;
    }
    
    int size = 1024; // 共享内存段的大小，以字节为单位
    
    int shmid = shmget(key, size, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget");
        return 1;
    }
    
    printf("Shared memory segment created with shmid: %d\n", shmid);
    
    return 0;
}
```

+ 注：
  + 这个示例中，我们首先使用ftok()函数生成一个键值，然后使用shmget()函数创建一个共享内存段，并获取与该共享内存段相关的标识符（shmid）。如果创建共享内存段时出现错误，我们使用perror()函数打印相应的错误消息。
  + 请注意，创建共享内存段后，还需要使用其他函数（如shmat()）将共享内存段附加到进程的地址空间中，才能进行读写操作。此处仅演示了创建共享内存段的基本过程

## ftok

+ 简介：
  + `ftok()`函数是C语言中的一个函数，用于生成一个唯一的键值（key）来创建一个共享内存、消息队列或信号量等系统对象。

+ 原型：
```c
key_t ftok(const char *pathname, int proj_id);
```

+ 参数
  + pathname：一个存在的文件的路径名，用于生成键值。
  + proj_id：项目标识符，通常为一个非负整数，用于区分不同的键值。

+ 详解
  + ftok()函数根据pathname和proj_id生成一个唯一的键值，并返回一个key_t类型的值作为结果。这个键值可以用于创建和访问共享内存、消息队列或信号量等系统对象
  + 使用ftok()函数时需要注意以下几点：
    + pathname参数必须是一个有效的文件路径，且文件必须存在。如果文件不存在或路径无效，ftok()函数将返回一个错误的键值。
    + proj_id参数通常是一个非负整数，用于区分不同的键值。不同的proj_id值将生成不同的键值。

+ 示例
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>

int main() {
    key_t key = ftok("/path/to/file", 1);
    
    if (key == -1) {
        perror("ftok");
        return 1;
    }
    
    printf("Generated key: %d\n", key);
    
    return 0;
}
```

+ 注：
  + 请注意，生成的键值应该在进程之间共享，以便其他进程可以使用相同的键值访问同一个系统对象。通常，可以将生成的键值传递给共享内存、消息队列或信号量等相关函数来创建或访问这些对象
  + 相同的文件，相同的标识符，生成相同的键值

## newlocale

+ `newlocale`是一个C语言函数，用于创建一个新的区域设置对象。区域设置对象是一个数据结构，包含了与特定地区相关的本地化信息，如日期格式、货币符号、语言偏好等。

+ `newlocale`函数的原型如下：
  ```c
    #include <locale.h>

    locale_t newlocale(int category_mask, const char *locale, locale_t base);
  ```

+ 参数解释如下：
  - `category_mask`：一个位掩码，用于指定要设置的区域设置的不同方面。可以使用`LC_ALL`表示所有方面，或使用以下值之一：`LC_COLLATE`、`LC_CTYPE`、`LC_MONETARY`、`LC_NUMERIC`、`LC_TIME`。
  - `locale`：一个字符串，表示要创建的区域设置的名称。可以是特定地区的名称（例如："en_US"表示美国英语），也可以是一些特殊值（例如："C"表示默认的"POSIX"区域设置）。
  - `base`：一个基本区域设置对象，用作新区域设置的基础。可以将其设置为`NULL`，表示没有基础区域设置。
  
+ 函数返回一个`locale_t`类型的值，表示新创建的区域设置对象。如果创建失败，函数返回`NULL`。

+ 使用`newlocale`函数可以创建新的区域设置对象，以便在程序中进行本地化设置，从而使程序能够适应不同的地区和语言环境。创建后的区域设置对象可以传递给其他一些与本地化相关的函数，如`strftime`、`strcoll`等，以便根据特定区域的规则进行相应的操作。

## memcpy

+ 简介：
  + C 库函数 void *memcpy(void *str1, const void *str2, size_t n) 从存储区 str2 复制 n 个字节到存储区 str1。

+ 声明
  + `void *memcpy(void *str1, const void *str2, size_t n);`

+ 参数：
  + str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
  + str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。
  + n -- 要被复制的字节数。

+ 返回值：
  + 该函数返回一个指向目标存储区 str1 的指针。

## getopt

+ 简介：getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 `<unistd.h>` 头文件中。

+ 定义：
  ```c
    int getopt(int argc, char * const argv[], const char *optstring);
     
    extern char *optarg;
    extern int optind, opterr, optopt;
  ``` 

+ getopt参数：
  + argc：通常由 main 函数直接传入，表示参数的数量
  + argv：通常也由 main 函数直接传入，表示参数的字符串变量数组
  + optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号
    + 可选参数：一个冒号表示选项后必须有参数，没有参数就会报错。如果有两个冒号的话，那么这个参数就是可选参数了，即可有可没有。
    + 注意这里 可选参数 选项 -c 后面跟参数的时候，一定不能有空格。
    + 但是如果是 必选参数，即选项后面只有一个冒号，则是有没有空格都可以。

+ 外部变量说明
  + optarg：如果某个选项有参数，这包含当前选项的参数字符串
  + optind：argv 的当前索引值
  + opterr：正常运行状态下为 0。非零时表示存在无效选项或者缺少选项参数，并输出其错误信息
  + optopt：当发现无效选项字符时，即 getopt() 方法返回 ? 字符，optopt 中包含的就是发现的无效选项字符

+ 输入字符串转 int
  + 由于 optarg 都是字符串类型的，所以当我们想要整型的输入参数时，会经常用到 atio() 这个方法，这里也简单介绍一下。
  + atoi (表示 ascii to integer) 是把字符串转换成整型数的一个函数，包含在 `<stdlib.h>` 头文件中，使用方式如下：
    + `int num = atoi(optarg);`

## getopt_long

+ 简介：getopt_long支持处理长短选项的命令行解析，函数在`<getopt.h>`头文件中

+ 定义：`int getopt_long(int argc, char *const *argv, const char *shortopts, const option *longopts, int *longind);`

+ 参数
  + argc、argv 和 main 函数的两个参数一致；
  + optstring：短选项字符串；
    + 形式如 a:b::cd，分别表示程序支持的命令行短选项有 -a、-b、-c、-d，冒号含义如下：
      + 只有一个字符，不带冒号-----只表示选项，如: -c
      + 一个字符，后面接一个冒号-----表示选项后面带一个参数，如: -a 100
      + 一个字符，后面接两个冒号-----表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数之间不能有空格，如: -b200
  + longopts：表示长选项结构体：
    ```c
      struct option
      {
        const char *name;
        /* has_arg can't be an enum because some compilers complain about
           type mismatches in all the code that assumes it is an int.  */
        int has_arg;
        int *flag;
        int val;
      };

      static struct option long_options[] = {
          {"help", no_argument,       0,   'h'},
          {"cfg",  required_argument, 0,   'f'},
          {"http-proxy", required_argument, &lopt, 1 },
          {"http-user", required_argument, &lopt, 2 },
          {"http-passwd", required_argument, &lopt, 3 },
          {"http-proxy-user", required_argument, &lopt, 4 },
          {"http-proxy-passwd", required_argument, &lopt, 5 },
          {"http-auth-scheme", required_argument, &lopt, 6 },
          {nullptr, 0, nullptr, 0}
      };
    ``` 
    + name：表示选项的名称，如 help、cfg 等；
    + has_arg：表示选项后面是否携带参数，该参数有三个不同值，如：
      + no_argument(0): 参数后面不跟参数值，如：–help；
      + required_argument(1): 参数输入格式为：–参数 值 or –参数=值，如：./dist_measurment_node --cfg ./cal_result；
      + optional_argument(2): 参数输入格式只能为：–参数=值。
    + flag：该参数有两种，空或者非空：
      + 如果参数为空(NULL)：当选中某个长选项的时候，getopt_long 将返回 val 值，如： ./可执行程序 --help，getopt_long 的返回值为 h。
      + 如果参数不为空：当选中某个长选项的时候，getopt_long 将返回 0，并且将 flag 指针指向 val 值，如：./可执行程序 --http-proxy=127.0.0.1:80，getopt_long 的返回值为 0，并且 lopt 值为 1。
    + val：表示指定函数找到该选项时的返回值，或者当 flag 非空时指定 flag 指向的数据的值。
    + longindex：longindex 非空，它指向的变量将记录当前找到参数符合 longopts 里的第几个元素的描述，即 longopts 的下标值。

+ 全局变量
  + optarg：会被系统自动赋为当前选项的参数；
  + optind：表示下一个将被处理到的参数在 argv 中的下标值；
  + opterr：如果 opterr = 0，在getopt、getopt_long、getopt_long_only 遇到错误将不会输出错误信息到标准输出流。opterr 在非 0 时，向屏幕输出错误。
  + optopt：会被自动赋值当前未标识的选项；

+ 返回值：
  + 如果短选项找到，那么将返回短选项对应的字符。
  + 如果长选项找到，如果flag为NULL，返回val。如果flag不为空，返回0
  + 如果遇到一个选项没有在短字符、长字符里面，或者在长字符里面存在二义性的，返回“？”
  + 如果解析完所有字符没有找到（一般是输入命令参数格式错误，eg： 连斜杠都没有加的选项），返回“-1”
  + 如果选项需要参数，忘了添加参数。返回值取决于optstring，如果其第一个字符是“：”，则返回“：”，否则返回“？”

+ 注意：
  + longopts的最后一个元素必须是全0填充，否则会报段错误
  + 短选项中每个选项都是唯一的。而长选项如果简写，也需要保持唯一性。

## perror()

+ 功能：把一个描述性错误消息输出到标准错误 stderr
+ 原型：`void perror(const char *str);`
+ 参数：
  + `str`  --  这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。

## daemon()

+ 功能：将程序置于后台，并与控制终端分离
+ 原型：`int daemon(int nochdir, int noclose);`
+ 参数：
  + `nochdir`  --  如果为0，执行`chdir ("/")`
  + `noclose`  --  如果为0，将`stdin, stdout, stderr`重定向到`/dev/null`

## strchr()

+ 功能：在参数 `str` 所指向的字符串中搜索最后一次出现字符 `c`（一个无符号字符）的位置
+ 原型：`char* strrchr(const char *str, int c);`
+ 参数：
  + `str`  --  C字符串
  + `c`    --  要搜索的字符。以 `int` 形式传递，但是最终会转换回 `char` 形式
+ 返回值：
  + 成功  --  返回`str`中最后一次出现字符`c`的位置
  + 失败  --  没有找到该值，返回一个空指针
+ 需求：
  + 头文件：`#include <string.h>`

## pipe()

+ 功能：创建单项通信通道(管道)
+ 原型：`int pipe(int *__pipedes);`
  + 如果成功，两个文件描述符存储在`pipedes`中
  + `pipedes[1]`上写入的字节可以从`pipedes[0]`中读取
+ 参数：
  + `__pipedes`  --  数组
+ 返回值：
  + 成功  --  0
  + 失败  --  -1
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + 管道没有外部或永久的名字，因此程序只能通过它的两个描述符来访问它
  + 因此，管道只能由创建它的进程或在`fork`时继承了它的描述符的后代进程使用。

## mkfifo()

+ 功能：创建新的FIFO特殊文件
+ 原型：`int mkfifo(const char *path, mode_t mode);`
+ 参数：
  + `path`  --  创建的文件路径
  + `mode`  --  文件权限
+ 返回值：
  + 成功  --  0
  + 失败  --  -1，并设置errno

## fork()

+ 功能：克隆调用进程，创建一个精确的副本。
+ 原型：`pid_t fork();`
+ 参数：无
+ 返回值：
  + 成功  --  新进程返回 0，或者新进程对旧进程的进程ID
  + 失败  --  -1

## getpid()

+ 功能：返回进程ID
+ 原型：`pid_t getpid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getpid`函数不能返回错误

## getppid()

+ 功能：返回父进程ID
+ 原型：`pid_t getppid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  父进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getppid`函数不能返回错误

## geteuid()

+ 功能：返回用户ID
+ 原型：`uid_t geteuid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  用户ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `uid_t`是代表用户ID的整数类型
  + `geteuid()`不返回错误

## getegid()

+ 功能：返回组ID
+ 原型：`gid_t getegid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  组ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `gid_t`是代表组ID的整数类型
  + `getegid()`不返回错误

## fork()

+ 功能：创建新的进程
+ 原型：`pid_t fork(void);`
+ 参数：无
+ 返回值：
  + 成功  --  向子进程返回0，并将子进程ID返回父进程
  + 失败  --  -1，并设置errno，没有创建子进程
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + fork函数的返回值是允许父进程和子进程区别自己并执行不同代码的关键特征

## execl()

+ 功能：使用参数`arg`以及之后的参数 执行`path`
+ 原型：`int execl(const char* path, const char* arg,...);`
+ 参数：
  + `path`  --  要执行的文件
  + `arg`   --  执行的参数
+ 返回值：
  + 成功  --
  + 失败  --

## pthread_sigmask()

+ 功能：修改，控制调用线程的信号掩码
+ 原型：`int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);`
+ 参数：
  + `how`  --  
    + `SIG_BLOCK`  ：结果集是当前集合参数集的并集， 
    + `SIG_UNBLOCK`：结果集是当前集合参数集的差集， 
    + `SIG_SETMASK`：结果集是由参数集指向的集
  + `newmask`
  + `oldmask`
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1，并设置errno
+ 需求：
  + 头文件：`#include <signal.h>`

## pthread_create()

+ 功能：创建一个新的线程，并让它可执行
+ 原型：`int pthread_create(pthread_t *newthread, const pthread_attr_t attr, void *(*start_routine)(void *), void *arg);`
+ 参数：
  + `newthread`  --  存储新线程的句柄，指向线程标识符指针
  + `attr` --  设置线程属性
  + `start_routine` -- 线程运行函数的起始地址
  + `arg`  --  运行函数的参数
+ 返回值：
  + 线程创建成功  --  0
  + 线程创建失败  --  返回出错编号，并且*thread中的内容是未定义的
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：
  + 返回成功时，由`newthread`指向的内存单元被设置为新创建线程的线程ID
  + attr参数用于指定各种不同的线程属性
  + 新创建的线程从`start_routine`函数的地址开始运行，该函数只有一个万能指针参数`arg`
  + 如果需要向`start_routine`函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入
  + linux下用C语言开发多线程程序，Linux系统下的多线程遵循POSIX线程接口，称为pthread

## pthread_join()

+ 功能：子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。
+ 原型：`int pthread_join(pthread_t thread, void **retval);`
+ 参数：
  + `thread`  --  线程标识符，即线程ID，标识唯一的线程
  + `retval`  --  用户定义的指针，用来存储被等待线程的返回值
+ 返回值：
  + 成功  --  0
  + 失败  --  其他值
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：
  + pthread_join()函数，以阻塞的方式等待thread指定的线程结束。
  + 当函数返回时，被等待线程的资源被收回。
  + 如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。

## pthread_detach()

+ 功能：指示线程`th`永远不会与`PTHREAD_JOIN`连接。因此，`th`的资源将在它终止时立即被释放，而不是等待另一个线程对它执行`PTHREAD_JOIN`。
  + 主线程与子线程分离，子线程结束后，资源自动回收。
+ 原型：`int pthread_detach(pthread_t th);`
+ 参数：
  + `th`  --  线程标识符，指向需要自动释放的线程
+ 返回值：
  + 成功  --  0
  + 失败  --  其他情况
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：

## pthread 两种状态 

+ `pthread`有两种状态`joinable`状态和`unjoinable`状态

+ 如果线程是`joinable`状态，当线程函数自己返回退出时或`pthread_exit`时都不会释放线程所占用堆栈和线程描述符（总计8K多）
+ 只有当你调用了`pthread_join`之后这些资源才会被释放

+ 若是`unjoinable`状态的线程，这些资源在线程函数退出时或`pthread_exit`时自动会被释放
+ `unjoinable`属性可以在`pthread_create`时指定，或在线程创建后在线程中`pthread_detach`自己

+ `pthread_detach(pthread_self());`
  + 将状态改为`unjoinable`状态，确保资源的释放。或者将线程置为 `joinable`,然后适时调用`pthread_join`.
  + 简单的说就是在线程函数头加上 `pthread_detach(pthread_self())`的话，线程状态改变，**在函数尾部直接 `pthread_exit` 线程就会自动退出**。省去了给线程擦屁股的麻烦

## _exit()

+ 功能：使用`__status`的`low-order 8 bits`终止程序执行
+ 原型：`void _exit(int __status);`
+ 参数：
  + `__status`  --  
+ 返回值：

## waitpid()

+ 功能：等待进程为`pid`的子进程死亡， 
+ 原型：`pid_t waitpid(pid_t  pid, int* stat_loc, int options);`
+ 参数：
  + `pid`  --  等待的进程,指向返回状态所在单元的指针和一个用来指定可选项的标志符
    + pid有四种情况：
      + pid <  -1 等待组ID等于pid绝对值的任意子进程
      + pid == -1 等待任意子进程
      + pid == 0  等待组ID等于调用进程组ID的任意子进程
      + pid >  0  等待进程ID与pid相等的子进程
  + `stat_loc`  --  指向终止进程的终止状态，如果不关心终止状态可指定为空指针
  + `options`   --  控制waitpid的操作
    + WCONTINUED
    + WUNTRACED
    + WNOHANG  waitpid不阻塞
+ 返回值：
  + 成功  --  返回pid，并将子进程的状态存储到`stat_loc`中
  + 失败  --  -1

## mkstemp()

+ 功能：根据`__tmplate`生成唯一的临时文件名
+ 原型：`int mkstemp(char *__template);`
+ 参数：
  + `__tmplate`  --  需要操作的文件
+ 返回值：
  + 成功  --  返回在文件上打开的用于读取和写入的文件描述符
  + 失败  --  -1 （如果它不能创建一个唯一的文件名）

## openlog()

+ 功能：此函数用来打开一个到系统日志记录程序的连接，打开之后就可以用`syslog`或`vsyslog`函数向系统日志里添加信息了。而`closelog`函数就是用来关闭此连接的
+ 原型：`void openlog(const char *ident, int option, int facility);`
+ 参数：
  + `ident`  --  一个标记，`ident`所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记
  + `option` --  参数option是下列值取与运算的结果：
    + `LOG_CONS，LOG_NDELAY， LOG_NOWAIT， LOG_ODELAY， LOG_PERROR，LOG_PID`
    + 各值意义请参考`man openlog`手册
  + `facility`  --  指明记录日志的程序的类型
+ 返回值：空

## setlogmask()

+ 功能：设置日志掩码级别
+ 原型：`int setlogmask(int mask);`
+ 参数：
  + `mask`  --  
+ 返回值：
  + 成功  --  
  + 失败  -- 

## C 标准库 `<stdarg.h>`

+ `stdarg.h` 头文件定义了一个变量类型 `va_list` 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。
+ 可变参数的函数通在参数列表的末尾是使用省略号`(,...)`定义的

### 库变量 -- va_list

+ 功能：这是一个适用于 `va_start()`、`va_arg()` 和 `va_end()` 这三个宏存储信息的类型
+ 声明：`typedef _G_va_list va_list;`

### va_start()

+ 功能：
  + C 库宏 `void va_start(va_list ap, last_arg)` 初始化 `ap` 变量，它与 `va_arg` 和 `va_end` 宏是一起使用的
  + `last_arg` 是最后一个传递给函数的已知的固定参数，即**省略号之前的参数**
  + 这个宏必须在使用 `va_arg` 和 `va_end` 之前被调用
+ 原型：`void va_start(va_list ap, last_arg);`
+ 参数：
  + `ap` -- 这是一个 `va_list` 类型的对象，它用来存储通过 `va_arg` 获取额外参数时所必需的信息
  + `last_arg` -- 最后一个传递给函数的已知的固定参数
+ 返回值：空

### va_arg()

+ 功能：
  + C 库宏 `type va_arg(va_list ap, type)` 检索函数参数列表中类型为 `type` 的下一个参数。
  + 它无法判断检索到的参数是否是传给函数的最后一个参数
+ 原型：`type va_arg(va_list ap, type);`
+ 参数：
  + `ap`   -- 这是一个 `va_list` 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 `va_arg` 之前通过调用 `va_start` 进行初始化
  + `type` -- 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。
+ 返回值：
  + 该宏返回下一个额外的参数，是一个类型为 `type` 的表达式

### va_end()

+ 功能：
  + C 库宏 `void va_end(va_list ap)` 允许使用了 `va_start` 宏的带有可变参数的函数返回。
  + 如果在从函数返回之前没有调用 `va_end`，则结果为未定义
+ 原型：`void va_end(va_list ap);`
+ 参数：
  + `ap` -- 这是之前由同一函数中的 `va_start` 初始化的 `va_list` 对象
+ 返回值：空

## vsnprintf()

+ 功能：将可变参数列表的格式化数据写入到大小为`n`的缓冲区
+ 原型：`int vsnprintf(char *s, size_t n, const char *format, va_list arg);`
+ 参数：
  + `s`  --  指向存储C字符串的缓冲区指针
  + `n`  --  缓冲区最大可用的字节数
  + `format`  --  包含格式化字符串的C字符串，和printf()相同
  + `arg`--  识别使用`va_start`初始化的可变参数列表的值
+ 返回值：
  + 成功  --  被写入的字符数`n`
  + 失败  --  -1

## sort()

+ 功能：对在范围`[first, last]`内的元素进行排序，不能保证保留同等元素的顺序  
+ 原型：
  + `template <class RandomIt>, class <Compare>`
  + `void sort(RandomIt first, RandomIt last, Compare comp);`
+ 参数：
  + `first`  --  排序元素范围的开始
  + `last`   --  排序元素范围的结束
  + `comp`   --  比较函数对象（即满足比较要求的对象）
+ 返回值：空
+ 需求：
  + 头文件：`#include <algorithm>`

## sqrt()

+ 功能：返回x的平方根
+ 原型：`double sqrt(double x);`
+ 参数：
  + `x`  --  需要处理的浮点数
+ 返回值：
  + 成功  --  x的平方根
+ 需求：
  + 头文件：`#include <math.h>`

## opendir()

+ 功能：打开一个目录文件
+ 原型：`DIR *opendir(const char *dirname);`
+ 参数：
  + `dirname`  --  目录
+ 返回值：
  + 成功  --  返回一个指向目录对象的指针
  + 失败  --  返回一个空指针，并设置errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + 定义在dirent.h中的DIR类型，表示的是一个**目录流**(directory stream)
  + 目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的

## readdir()

+ 功能：读取一个目录文件中的数据
+ 原型：`struct dirent *readdir(DIR *dirp);`
+ 参数：
  + `dirp`  --  目录对象的指针
+ 返回值：
  + 成功  --  返回一个指向`struct dirent`结构的指针，结构中包含了与下一个目录项有关的信息
  + 失败  --  返回一个NULL指针，并设置errno
    + `readdir()`的实现必须检测的错误只有一种，就是要返回的结构中的值无法正确表达，其错误码是`EOVERFLOW`
    + `readdir()`函数也返回NULL来指示目录的末尾，但在这种情况下它并不改变errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + `readdir`在每次调用之后都将流转移到下一个位置上去

## stat()

+ 功能：通过名字来访问文件
+ 原型：`int stat(const char *restrict path, struct stat *restrict buf);`
+ 参数：
  + `path`  --  指定了需要返回状态的文件或符号链接的名字
  + `buf`   --  指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中
+ 返回值：
  + 成功  --  0
  + 失败  --  -1，并设置errno

## link()

+ 功能：为`path1`指定的已存在文件创建一个新的目录项，这个文件位于`path2`指定的目录中
+ 原型：`int link(const char *path1, const char *path2)`
+ 参数：
  + `path1`  --  已存在文件
  + `path2`  --  指定的目录
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`

## unlink()

+ 功能：删除了path指定的目录项
+ 原型：`int unlink(const char *path);`
+ 参数：
  + `path`  --  需要删除的目录项
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`
  
## symlink()

+ 功能：创建一个符号链接
+ 原型：`int symlink(const char *path1, const char *path2);`
+ 参数：
  + `path1`  --  包含了将成为链接的内容的字符串
  + `path2`  --  链接的路径名
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + 换句话来说，path2就是新创建的链接，而新链接指向path1

## sigset_t 信号集

+ 信号集被定义为一种数据类型：
  + `typedef struct {unsigned long sig[_NSIG_WORDS];} sigset_t;`
+ 信号集用来描述信号的集合，每个信号占用一位（64位）。
+ Linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用

### 信号集操作定义的相关函数：

+ `int sigemptyset(sigset_t *set);`  初始化由`set`指定的信号集，信号集里面的所有信号被清空，相当于`64`为置`0`；

+ `int sigfillset(sigset_t *set);`   调用该函数后，`set`指向的信号集中将包含`linux`支持的`64`种信号，相当于`64`为都置`1`；

+ `int sigaddset(sigset_t *set, int signum);`在`set`指向的信号集中加入`signum`信号，相当于将给定信号所对应的位置`1`；
  
+ `int sigdelset(sigset_t *set, int signum);`在`set`指向的信号集中删除`signum`信号，相当于将给定信号所对应的位置`0`；

+ `int sigismember(const sigset_t *set, int signum);`判定信号`signum`是否在`set`指向的信号集中，相当于检查给定信号所对应的位是`0`还是`1`。

### 信号处理

+ 信号是内核提供的向用户态进程发送信息的机制, 
+ 常见的有使用`SIGUSR1`唤醒用户进程执行子程序或发生段错误时使用`SIGSEGV`保存用户错误现场.

## sigwait()

+ 功能：从`set`中选择任何挂起的信号或等待任何一个信号到达
+ 原型：`int sigwait(const sigset_t *set, int sig);`
+ 参数：
  + `set`  --  信号集
  + `sig`  --  
+ 返回值：
  + 成功  --  
  + 失败  --  
+ 需求：
  + 头文件：`#include <signal.h>`
+ 注意：
  + sigwait是同步的等待信号的到来，而不是像进程中那样是异步的等待信号的到来
  + sigwait函数使用一个信号集作为他的参数，并且在集合中的任一个信号发生时返回该信号值，解除阻塞，然后可以针对该信号进行一些相应的处理。