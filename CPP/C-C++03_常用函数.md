## getopt

+ 简介：getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 `<unistd.h>` 头文件中。

+ 定义：
  ```
    int getopt(int argc, char * const argv[], const char *optstring);
     
    extern char *optarg;
    extern int optind, opterr, optopt;
  ``` 

+ getopt参数：
  + argc：通常由 main 函数直接传入，表示参数的数量
  + argv：通常也由 main 函数直接传入，表示参数的字符串变量数组
  + optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号
    + 可选参数：一个冒号表示选项后必须有参数，没有参数就会报错。如果有两个冒号的话，那么这个参数就是可选参数了，即可有可没有。
    + 注意这里 可选参数 选项 -c 后面跟参数的时候，一定不能有空格。
    + 但是如果是 必选参数，即选项后面只有一个冒号，则是有没有空格都可以。

+ 外部变量说明
  + optarg：如果某个选项有参数，这包含当前选项的参数字符串
  + optind：argv 的当前索引值
  + opterr：正常运行状态下为 0。非零时表示存在无效选项或者缺少选项参数，并输出其错误信息
  + optopt：当发现无效选项字符时，即 getopt() 方法返回 ? 字符，optopt 中包含的就是发现的无效选项字符

+ 输入字符串转 int
  + 由于 optarg 都是字符串类型的，所以当我们想要整型的输入参数时，会经常用到 atio() 这个方法，这里也简单介绍一下。
  + atoi (表示 ascii to integer) 是把字符串转换成整型数的一个函数，包含在 `<stdlib.h>` 头文件中，使用方式如下：
    + `int num = atoi(optarg);`

## getopt_long

+ 简介：getopt_long支持处理长短选项的命令行解析，函数在`<getopt.h>`头文件中

+ 定义：`int getopt_long(int argc, char *const *argv, const char *shortopts, const option *longopts, int *longind);`

+ 参数
  + argc、argv 和 main 函数的两个参数一致；
  + optstring：短选项字符串；
    + 形式如 a:b::cd，分别表示程序支持的命令行短选项有 -a、-b、-c、-d，冒号含义如下：
      + 只有一个字符，不带冒号-----只表示选项，如: -c
      + 一个字符，后面接一个冒号-----表示选项后面带一个参数，如: -a 100
      + 一个字符，后面接两个冒号-----表示选项后面带一个可选参数，即参数可有可无，如果带参数，则选项与参数之间不能有空格，如: -b200
  + longopts：表示长选项结构体：
    ```
      struct option
      {
        const char *name;
        /* has_arg can't be an enum because some compilers complain about
           type mismatches in all the code that assumes it is an int.  */
        int has_arg;
        int *flag;
        int val;
      };

      static struct option long_options[] = {
          {"help", no_argument,       0,   'h'},
          {"cfg",  required_argument, 0,   'f'},
          {"http-proxy", required_argument, &lopt, 1 },
          {"http-user", required_argument, &lopt, 2 },
          {"http-passwd", required_argument, &lopt, 3 },
          {"http-proxy-user", required_argument, &lopt, 4 },
          {"http-proxy-passwd", required_argument, &lopt, 5 },
          {"http-auth-scheme", required_argument, &lopt, 6 },
          {nullptr, 0, nullptr, 0}
      };
    ``` 
    + name：表示选项的名称，如 help、cfg 等；
    + has_arg：表示选项后面是否携带参数，该参数有三个不同值，如：
      + no_argument(0): 参数后面不跟参数值，如：–help；
      + required_argument(1): 参数输入格式为：–参数 值 or –参数=值，如：./dist_measurment_node --cfg ./cal_result；
      + optional_argument(2): 参数输入格式只能为：–参数=值。
    + flag：该参数有两种，空或者非空：
      + 如果参数为空(NULL)：当选中某个长选项的时候，getopt_long 将返回 val 值，如： ./可执行程序 --help，getopt_long 的返回值为 h。
      + 如果参数不为空：当选中某个长选项的时候，getopt_long 将返回 0，并且将 flag 指针指向 val 值，如：./可执行程序 --http-proxy=127.0.0.1:80，getopt_long 的返回值为 0，并且 lopt 值为 1。
    + val：表示指定函数找到该选项时的返回值，或者当 flag 非空时指定 flag 指向的数据的值。
    + longindex：longindex 非空，它指向的变量将记录当前找到参数符合 longopts 里的第几个元素的描述，即 longopts 的下标值。

+ 全局变量
  + optarg：会被系统自动赋为当前选项的参数；
  + optind：表示下一个将被处理到的参数在 argv 中的下标值；
  + opterr：如果 opterr = 0，在getopt、getopt_long、getopt_long_only 遇到错误将不会输出错误信息到标准输出流。opterr 在非 0 时，向屏幕输出错误。
  + optopt：会被自动赋值当前未标识的选项；

+ 返回值：
  + 如果短选项找到，那么将返回短选项对应的字符。
  + 如果长选项找到，如果flag为NULL，返回val。如果flag不为空，返回0
  + 如果遇到一个选项没有在短字符、长字符里面，或者在长字符里面存在二义性的，返回“？”
  + 如果解析完所有字符没有找到（一般是输入命令参数格式错误，eg： 连斜杠都没有加的选项），返回“-1”
  + 如果选项需要参数，忘了添加参数。返回值取决于optstring，如果其第一个字符是“：”，则返回“：”，否则返回“？”

+ 注意：
  + longopts的最后一个元素必须是全0填充，否则会报段错误
  + 短选项中每个选项都是唯一的。而长选项如果简写，也需要保持唯一性。

## perror()

+ 功能：把一个描述性错误消息输出到标准错误 stderr
+ 原型：`void perror(const char *str);`
+ 参数：
  + `str`  --  这是 C 字符串，包含了一个自定义消息，将显示在原本的错误消息之前。

## daemon()

+ 功能：将程序置于后台，并与控制终端分离
+ 原型：`int daemon(int nochdir, int noclose);`
+ 参数：
  + `nochdir`  --  如果为0，执行`chdir ("/")`
  + `noclose`  --  如果为0，将`stdin, stdout, stderr`重定向到`/dev/null`

## strchr()

+ 功能：在参数 `str` 所指向的字符串中搜索最后一次出现字符 `c`（一个无符号字符）的位置
+ 原型：`char* strrchr(const char *str, int c);`
+ 参数：
  + `str`  --  C字符串
  + `c`    --  要搜索的字符。以 `int` 形式传递，但是最终会转换回 `char` 形式
+ 返回值：
  + 成功  --  返回`str`中最后一次出现字符`c`的位置
  + 失败  --  没有找到该值，返回一个空指针
+ 需求：
  + 头文件：`#include <string.h>`

## pipe()

+ 功能：创建单项通信通道(管道)
+ 原型：`int pipe(int *__pipedes);`
  + 如果成功，两个文件描述符存储在`pipedes`中
  + `pipedes[1]`上写入的字节可以从`pipedes[0]`中读取
+ 参数：
  + `__pipedes`  --  数组
+ 返回值：
  + 成功  --  0
  + 失败  --  -1
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + 管道没有外部或永久的名字，因此程序只能通过它的两个描述符来访问它
  + 因此，管道只能由创建它的进程或在`fork`时继承了它的描述符的后代进程使用。

## mkfifo()

+ 功能：创建新的FIFO特殊文件
+ 原型：`int mkfifo(const char *path, mode_t mode);`
+ 参数：
  + `path`  --  创建的文件路径
  + `mode`  --  文件权限
+ 返回值：
  + 成功  --  0
  + 失败  --  -1，并设置errno

## fork()

+ 功能：克隆调用进程，创建一个精确的副本。
+ 原型：`pid_t fork();`
+ 参数：无
+ 返回值：
  + 成功  --  新进程返回 0，或者新进程对旧进程的进程ID
  + 失败  --  -1

## getpid()

+ 功能：返回进程ID
+ 原型：`pid_t getpid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getpid`函数不能返回错误

## getppid()

+ 功能：返回父进程ID
+ 原型：`pid_t getppid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  父进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getppid`函数不能返回错误

## geteuid()

+ 功能：返回用户ID
+ 原型：`uid_t geteuid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  用户ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `uid_t`是代表用户ID的整数类型
  + `geteuid()`不返回错误

## getegid()

+ 功能：返回组ID
+ 原型：`gid_t getegid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  组ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `gid_t`是代表组ID的整数类型
  + `getegid()`不返回错误

## fork()

+ 功能：创建新的进程
+ 原型：`pid_t fork(void);`
+ 参数：无
+ 返回值：
  + 成功  --  向子进程返回0，并将子进程ID返回父进程
  + 失败  --  -1，并设置errno，没有创建子进程
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + fork函数的返回值是允许父进程和子进程区别自己并执行不同代码的关键特征

## execl()

+ 功能：使用参数`arg`以及之后的参数 执行`path`
+ 原型：`int execl(const char* path, const char* arg,...);`
+ 参数：
  + `path`  --  要执行的文件
  + `arg`   --  执行的参数
+ 返回值：
  + 成功  --
  + 失败  --

## pthread_sigmask()

+ 功能：修改，控制调用线程的信号掩码
+ 原型：`int pthread_sigmask(int how, const sigset_t *newmask, sigset_t *oldmask);`
+ 参数：
  + `how`  --  
    + `SIG_BLOCK`  ：结果集是当前集合参数集的并集， 
    + `SIG_UNBLOCK`：结果集是当前集合参数集的差集， 
    + `SIG_SETMASK`：结果集是由参数集指向的集
  + `newmask`
  + `oldmask`
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1，并设置errno
+ 需求：
  + 头文件：`#include <signal.h>`

## pthread_create()

+ 功能：创建一个新的线程，并让它可执行
+ 原型：`int pthread_create(pthread_t *newthread, const pthread_attr_t attr, void *(*start_routine)(void *), void *arg);`
+ 参数：
  + `newthread`  --  存储新线程的句柄，指向线程标识符指针
  + `attr` --  设置线程属性
  + `start_routine` -- 线程运行函数的起始地址
  + `arg`  --  运行函数的参数
+ 返回值：
  + 线程创建成功  --  0
  + 线程创建失败  --  返回出错编号，并且*thread中的内容是未定义的
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：
  + 返回成功时，由`newthread`指向的内存单元被设置为新创建线程的线程ID
  + attr参数用于指定各种不同的线程属性
  + 新创建的线程从`start_routine`函数的地址开始运行，该函数只有一个万能指针参数`arg`
  + 如果需要向`start_routine`函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入
  + linux下用C语言开发多线程程序，Linux系统下的多线程遵循POSIX线程接口，称为pthread

## pthread_join()

+ 功能：子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。
+ 原型：`int pthread_join(pthread_t thread, void **retval);`
+ 参数：
  + `thread`  --  线程标识符，即线程ID，标识唯一的线程
  + `retval`  --  用户定义的指针，用来存储被等待线程的返回值
+ 返回值：
  + 成功  --  0
  + 失败  --  其他值
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：
  + pthread_join()函数，以阻塞的方式等待thread指定的线程结束。
  + 当函数返回时，被等待线程的资源被收回。
  + 如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。

## pthread_detach()

+ 功能：指示线程`th`永远不会与`PTHREAD_JOIN`连接。因此，`th`的资源将在它终止时立即被释放，而不是等待另一个线程对它执行`PTHREAD_JOIN`。
  + 主线程与子线程分离，子线程结束后，资源自动回收。
+ 原型：`int pthread_detach(pthread_t th);`
+ 参数：
  + `th`  --  线程标识符，指向需要自动释放的线程
+ 返回值：
  + 成功  --  0
  + 失败  --  其他情况
+ 需求：
  + 头文件：`#include <pthread>`
+ 注意：

## pthread 两种状态 

+ `pthread`有两种状态`joinable`状态和`unjoinable`状态

+ 如果线程是`joinable`状态，当线程函数自己返回退出时或`pthread_exit`时都不会释放线程所占用堆栈和线程描述符（总计8K多）
+ 只有当你调用了`pthread_join`之后这些资源才会被释放

+ 若是`unjoinable`状态的线程，这些资源在线程函数退出时或`pthread_exit`时自动会被释放
+ `unjoinable`属性可以在`pthread_create`时指定，或在线程创建后在线程中`pthread_detach`自己

+ `pthread_detach(pthread_self());`
  + 将状态改为`unjoinable`状态，确保资源的释放。或者将线程置为 `joinable`,然后适时调用`pthread_join`.
  + 简单的说就是在线程函数头加上 `pthread_detach(pthread_self())`的话，线程状态改变，**在函数尾部直接 `pthread_exit` 线程就会自动退出**。省去了给线程擦屁股的麻烦

## _exit()

+ 功能：使用`__status`的`low-order 8 bits`终止程序执行
+ 原型：`void _exit(int __status);`
+ 参数：
  + `__status`  --  
+ 返回值：

## waitpid()

+ 功能：等待进程为`pid`的子进程死亡， 
+ 原型：`pid_t waitpid(pid_t  pid, int* stat_loc, int options);`
+ 参数：
  + `pid`  --  等待的进程,指向返回状态所在单元的指针和一个用来指定可选项的标志符
    + pid有四种情况：
      + pid <  -1 等待组ID等于pid绝对值的任意子进程
      + pid == -1 等待任意子进程
      + pid == 0  等待组ID等于调用进程组ID的任意子进程
      + pid >  0  等待进程ID与pid相等的子进程
  + `stat_loc`  --  指向终止进程的终止状态，如果不关心终止状态可指定为空指针
  + `options`   --  控制waitpid的操作
    + WCONTINUED
    + WUNTRACED
    + WNOHANG  waitpid不阻塞
+ 返回值：
  + 成功  --  返回pid，并将子进程的状态存储到`stat_loc`中
  + 失败  --  -1

## mkstemp()

+ 功能：根据`__tmplate`生成唯一的临时文件名
+ 原型：`int mkstemp(char *__template);`
+ 参数：
  + `__tmplate`  --  需要操作的文件
+ 返回值：
  + 成功  --  返回在文件上打开的用于读取和写入的文件描述符
  + 失败  --  -1 （如果它不能创建一个唯一的文件名）

## openlog()

+ 功能：此函数用来打开一个到系统日志记录程序的连接，打开之后就可以用`syslog`或`vsyslog`函数向系统日志里添加信息了。而`closelog`函数就是用来关闭此连接的
+ 原型：`void openlog(const char *ident, int option, int facility);`
+ 参数：
  + `ident`  --  一个标记，`ident`所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记
  + `option` --  参数option是下列值取与运算的结果：
    + `LOG_CONS，LOG_NDELAY， LOG_NOWAIT， LOG_ODELAY， LOG_PERROR，LOG_PID`
    + 各值意义请参考`man openlog`手册
  + `facility`  --  指明记录日志的程序的类型
+ 返回值：空

## setlogmask()

+ 功能：设置日志掩码级别
+ 原型：`int setlogmask(int mask);`
+ 参数：
  + `mask`  --  
+ 返回值：
  + 成功  --  
  + 失败  -- 

## C 标准库 `<stdarg.h>`

+ `stdarg.h` 头文件定义了一个变量类型 `va_list` 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。
+ 可变参数的函数通在参数列表的末尾是使用省略号`(,...)`定义的

### 库变量 -- va_list

+ 功能：这是一个适用于 `va_start()`、`va_arg()` 和 `va_end()` 这三个宏存储信息的类型
+ 声明：`typedef _G_va_list va_list;`

### va_start()

+ 功能：
  + C 库宏 `void va_start(va_list ap, last_arg)` 初始化 `ap` 变量，它与 `va_arg` 和 `va_end` 宏是一起使用的
  + `last_arg` 是最后一个传递给函数的已知的固定参数，即**省略号之前的参数**
  + 这个宏必须在使用 `va_arg` 和 `va_end` 之前被调用
+ 原型：`void va_start(va_list ap, last_arg);`
+ 参数：
  + `ap` -- 这是一个 `va_list` 类型的对象，它用来存储通过 `va_arg` 获取额外参数时所必需的信息
  + `last_arg` -- 最后一个传递给函数的已知的固定参数
+ 返回值：空

### va_arg()

+ 功能：
  + C 库宏 `type va_arg(va_list ap, type)` 检索函数参数列表中类型为 `type` 的下一个参数。
  + 它无法判断检索到的参数是否是传给函数的最后一个参数
+ 原型：`type va_arg(va_list ap, type);`
+ 参数：
  + `ap`   -- 这是一个 `va_list` 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 `va_arg` 之前通过调用 `va_start` 进行初始化
  + `type` -- 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。
+ 返回值：
  + 该宏返回下一个额外的参数，是一个类型为 `type` 的表达式

### va_end()

+ 功能：
  + C 库宏 `void va_end(va_list ap)` 允许使用了 `va_start` 宏的带有可变参数的函数返回。
  + 如果在从函数返回之前没有调用 `va_end`，则结果为未定义
+ 原型：`void va_end(va_list ap);`
+ 参数：
  + `ap` -- 这是之前由同一函数中的 `va_start` 初始化的 `va_list` 对象
+ 返回值：空

## vsnprintf()

+ 功能：将可变参数列表的格式化数据写入到大小为`n`的缓冲区
+ 原型：`int vsnprintf(char *s, size_t n, const char *format, va_list arg);`
+ 参数：
  + `s`  --  指向存储C字符串的缓冲区指针
  + `n`  --  缓冲区最大可用的字节数
  + `format`  --  包含格式化字符串的C字符串，和printf()相同
  + `arg`--  识别使用`va_start`初始化的可变参数列表的值
+ 返回值：
  + 成功  --  被写入的字符数`n`
  + 失败  --  -1

## sort()

+ 功能：对在范围`[first, last]`内的元素进行排序，不能保证保留同等元素的顺序  
+ 原型：
  + `template <class RandomIt>, class <Compare>`
  + `void sort(RandomIt first, RandomIt last, Compare comp);`
+ 参数：
  + `first`  --  排序元素范围的开始
  + `last`   --  排序元素范围的结束
  + `comp`   --  比较函数对象（即满足比较要求的对象）
+ 返回值：空
+ 需求：
  + 头文件：`#include <algorithm>`

## sqrt()

+ 功能：返回x的平方根
+ 原型：`double sqrt(double x);`
+ 参数：
  + `x`  --  需要处理的浮点数
+ 返回值：
  + 成功  --  x的平方根
+ 需求：
  + 头文件：`#include <math.h>`

## opendir()

+ 功能：打开一个目录文件
+ 原型：`DIR *opendir(const char *dirname);`
+ 参数：
  + `dirname`  --  目录
+ 返回值：
  + 成功  --  返回一个指向目录对象的指针
  + 失败  --  返回一个空指针，并设置errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + 定义在dirent.h中的DIR类型，表示的是一个**目录流**(directory stream)
  + 目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的

## readdir()

+ 功能：读取一个目录文件中的数据
+ 原型：`struct dirent *readdir(DIR *dirp);`
+ 参数：
  + `dirp`  --  目录对象的指针
+ 返回值：
  + 成功  --  返回一个指向`struct dirent`结构的指针，结构中包含了与下一个目录项有关的信息
  + 失败  --  返回一个NULL指针，并设置errno
    + `readdir()`的实现必须检测的错误只有一种，就是要返回的结构中的值无法正确表达，其错误码是`EOVERFLOW`
    + `readdir()`函数也返回NULL来指示目录的末尾，但在这种情况下它并不改变errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + `readdir`在每次调用之后都将流转移到下一个位置上去

## stat()

+ 功能：通过名字来访问文件
+ 原型：`int stat(const char *restrict path, struct stat *restrict buf);`
+ 参数：
  + `path`  --  指定了需要返回状态的文件或符号链接的名字
  + `buf`   --  指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中
+ 返回值：
  + 成功  --  0
  + 失败  --  -1，并设置errno

## link()

+ 功能：为`path1`指定的已存在文件创建一个新的目录项，这个文件位于`path2`指定的目录中
+ 原型：`int link(const char *path1, const char *path2)`
+ 参数：
  + `path1`  --  已存在文件
  + `path2`  --  指定的目录
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`

## unlink()

+ 功能：删除了path指定的目录项
+ 原型：`int unlink(const char *path);`
+ 参数：
  + `path`  --  需要删除的目录项
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`
  
## symlink()

+ 功能：创建一个符号链接
+ 原型：`int symlink(const char *path1, const char *path2);`
+ 参数：
  + `path1`  --  包含了将成为链接的内容的字符串
  + `path2`  --  链接的路径名
+ 返回值：
  + 成功  -- 0
  + 失败  -- -1
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + 换句话来说，path2就是新创建的链接，而新链接指向path1

## sigset_t 信号集

+ 信号集被定义为一种数据类型：
  + `typedef struct {unsigned long sig[_NSIG_WORDS];} sigset_t;`
+ 信号集用来描述信号的集合，每个信号占用一位（64位）。
+ Linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用

### 信号集操作定义的相关函数：

+ `int sigemptyset(sigset_t *set);`  初始化由`set`指定的信号集，信号集里面的所有信号被清空，相当于`64`为置`0`；

+ `int sigfillset(sigset_t *set);`   调用该函数后，`set`指向的信号集中将包含`linux`支持的`64`种信号，相当于`64`为都置`1`；

+ `int sigaddset(sigset_t *set, int signum);`在`set`指向的信号集中加入`signum`信号，相当于将给定信号所对应的位置`1`；
  
+ `int sigdelset(sigset_t *set, int signum);`在`set`指向的信号集中删除`signum`信号，相当于将给定信号所对应的位置`0`；

+ `int sigismember(const sigset_t *set, int signum);`判定信号`signum`是否在`set`指向的信号集中，相当于检查给定信号所对应的位是`0`还是`1`。

### 信号处理

+ 信号是内核提供的向用户态进程发送信息的机制, 
+ 常见的有使用`SIGUSR1`唤醒用户进程执行子程序或发生段错误时使用`SIGSEGV`保存用户错误现场.

## sigwait()

+ 功能：从`set`中选择任何挂起的信号或等待任何一个信号到达
+ 原型：`int sigwait(const sigset_t *set, int sig);`
+ 参数：
  + `set`  --  信号集
  + `sig`  --  
+ 返回值：
  + 成功  --  
  + 失败  --  
+ 需求：
  + 头文件：`#include <signal.h>`
+ 注意：
  + sigwait是同步的等待信号的到来，而不是像进程中那样是异步的等待信号的到来
  + sigwait函数使用一个信号集作为他的参数，并且在集合中的任一个信号发生时返回该信号值，解除阻塞，然后可以针对该信号进行一些相应的处理。