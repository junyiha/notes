## 简介

+ C/C++常用函数，大部分为C函数

## fnmatch

`fnmatch()` 函数是C标准库中用于进行模式匹配的函数之一，它可以用来比较一个字符串是否匹配指定的模式。这个函数通常用于文件名匹配等场景。以下是关于 `fnmatch()` 函数的详细解释：

**函数原型：**
```c
#include <fnmatch.h>

int fnmatch(const char *pattern, const char *string, int flags);
```

**参数：**
- `pattern`：要匹配的模式字符串。
- `string`：要进行匹配的输入字符串。
- `flags`：控制匹配行为的标志位，可以是以下之一或它们的组合：
  - `FNM_NOESCAPE`：不解释反斜杠 `\` 作为转义字符。
  - `FNM_PATHNAME`：模式中的斜杠只与斜杠匹配。
  - `FNM_PERIOD`：模式中的起始点 `.` 只与起始点匹配。
  - `FNM_FILE_NAME`：等效于 `FNM_PATHNAME | FNM_PERIOD`。

**返回值：**
- 如果匹配成功，返回0。
- 如果不匹配，返回 `FNM_NOMATCH`。
- 如果发生错误，返回其他非零值。

**示例：**
```c
#include <fnmatch.h>
#include <stdio.h>

int main() {
    const char *pattern = "*.txt";
    const char *strings[] = {"file.txt", "example.txt", "document.doc"};

    for (size_t i = 0; i < sizeof(strings) / sizeof(strings[0]); ++i) {
        if (fnmatch(pattern, strings[i], 0) == 0) {
            printf("%s matches the pattern.\n", strings[i]);
        } else {
            printf("%s does not match the pattern.\n", strings[i]);
        }
    }

    return 0;
}
```

在上面的示例中，`fnmatch()` 函数被用来检查字符串数组中的每个元素是否匹配指定的模式。`pattern` 参数是要匹配的模式，`string` 参数是要进行匹配的字符串。函数返回0表示匹配成功，`FNM_NOMATCH` 表示不匹配。

需要注意的是，`fnmatch()` 函数可能会依赖于实现和操作系统的特定行为。在使用时，务必查阅操作系统和标准库的文档来了解更多细节和支持情况。

## inet_ntoa

在 C 语言中，`inet_ntoa()` 函数用于将网络字节序（大端字节序）的IPv4地址转换为点分十进制形式的字符串表示。它的详细说明如下：

**函数原型：**
```c
#include <arpa/inet.h>

char *inet_ntoa(struct in_addr in);
```

**参数：**
- `in`: 一个`struct in_addr`结构体，包含要转换的IPv4地址。

**返回值：**
- 如果转换成功，函数返回一个指向包含点分十进制IPv4地址的静态缓冲区的指针。
- 如果转换失败，函数返回NULL，并设置`errno`。

**注意事项：**
- `inet_ntoa()`函数是不可重入的（not thread-safe）。它使用了一个静态缓冲区来存储转换后的字符串。因此，如果在同一线程中多次调用`inet_ntoa()`，它会覆盖前一次的结果。

**示例：**
```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    struct in_addr addr;
    inet_pton(AF_INET, "192.168.1.100", &addr);

    char *ip_str = inet_ntoa(addr);
    if (ip_str == NULL) {
        perror("inet_ntoa");
        return 1;
    }

    printf("IPv4 Address: %s\n", ip_str);
    return 0;
}
```

在上面的示例中，我们首先使用`inet_pton()`函数将字符串形式的IPv4地址转换为`struct in_addr`结构体（网络字节序）。然后，我们使用`inet_ntoa()`函数将该结构体转换为点分十进制形式的字符串，并打印出来。

需要注意的是，由于`inet_ntoa()`使用静态缓冲区，如果需要在同一线程中多次使用它或保留转换后的字符串内容，最好将其复制到自己管理的内存中，以避免数据覆盖问题。