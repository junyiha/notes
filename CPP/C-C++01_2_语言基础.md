## 简介

+ C/C++ 编程语言理论基础

## C++ 预处理指令详解

C++预处理器是一个在实际编译之前执行的阶段，它处理以 `#` 开头的预处理指令。这些指令用于在源代码中进行文本替换、条件编译、头文件包含等操作，以及定义宏和条件编译代码块。以下是一些常见的C++预处理指令以及它们的作用：

1. **#include：**
   用于包含其他文件中的内容。主要用于包含头文件，以便在源文件中使用头文件中的声明和定义。

   示例：
   ```cpp
   #include <iostream>   // 包含C++标准库的iostream头文件
   #include "myheader.h" // 包含自定义头文件
   ```

2. **#define：**
   用于定义宏。预处理器会将宏名称替换为相应的文本。可以用于创建常量、函数宏等。

   示例：
   ```cpp
   #define PI 3.14159
   #define MAX(x, y) ((x) > (y) ? (x) : (y))
   ```

3. **#ifdef / #ifndef / #else / #endif：**
   用于条件编译。根据指定的条件，决定是否编译某段代码。`#ifdef` 表示 "如果定义了宏"，`#ifndef` 表示 "如果未定义宏"，`#else` 表示 "否则"，`#endif` 表示结束条件块。

   示例：
   ```cpp
   #ifdef DEBUG
       // 调试时执行的代码
   #else
       // 发布版本时执行的代码
   #endif
   ```

4. **#if / #elif / #else / #endif：**
   类似于条件编译，但允许在代码中进行更复杂的条件判断，如使用预定义宏来确定编译路径。

   示例：
   ```cpp
   #if defined(_WIN32)
       // Windows平台下的代码
   #elif defined(__linux__)
       // Linux平台下的代码
   #else
       // 其他平台下的代码
   #endif
   ```

5. **#undef：**
   用于取消宏定义。如果需要取消一个已定义的宏，可以使用 `#undef`。

   示例：
   ```cpp
   #define MY_MACRO 42
   #undef MY_MACRO
   ```

6. **#pragma：**
   用于在编译器中插入特定的指令。`#pragma` 指令的效果和语法会因编译器而异。

   示例：
   ```cpp
   #pragma warning(disable : 1234)
   ```

7. **#error：**
   用于生成编译错误消息。可以用于在特定条件下阻止编译，或者为开发者提供有用的错误信息。

   示例：
   ```cpp
   #ifdef OLD_COMPILER
       #error "This version is not supported by the old compiler"
   #endif
   ```

8. **#line：**
   用于改变编译器报告的行号和文件名，通常用于错误消息或调试信息的生成。

   示例：
   ```cpp
   #line 100 "mycode.cpp"
   ```

C++预处理器的这些指令允许您在编译前进行一些文本操作和条件判断，以便根据不同的情况定制化代码的编译过程。它们在代码的可维护性和可配置性方面非常有用。

## 友元 friend

在 C++ 中，**友元**（friend）是一种访问控制机制，它允许一个函数或类访问另一个类的私有成员。友元关系通过在类的定义中使用 `friend` 关键字来建立。

友元的主要用途是在一些特殊情况下提供灵活的访问权限，但也应该谨慎使用，因为它可能会破坏类的封装性和隔离性。

以下是关于 C++ 中友元的详细解释：

1. **友元函数**：在类定义中使用 `friend` 关键字声明一个函数为友元函数。这意味着友元函数可以访问该类的私有和受保护成员。友元函数不是类的成员函数，但它具有特殊的权限，可以直接访问私有成员。

2. **友元类**：同样，可以使用 `friend` 关键字将一个类声明为另一个类的友元类。这意味着友元类的所有成员函数可以访问该类的私有和受保护成员。友元类可以访问另一个类的私有成员，但不会继承它的成员。

友元关系是双向的：如果类 A 是类 B 的友元，那么类 B 也可以访问类 A 的私有成员。

下面是一个示例，演示了如何在 C++ 中使用友元函数和友元类：

```cpp
#include <iostream>

class FriendExample {
private:
    int privateValue;

public:
    FriendExample(int value) : privateValue(value) {}

    friend void FriendFunction(FriendExample& obj);  // 友元函数声明
    friend class FriendClass;  // 友元类声明
};

// 友元函数定义
void FriendFunction(FriendExample& obj) {
    std::cout << "Friend Function accessing privateValue: " << obj.privateValue << std::endl;
}

// 友元类定义
class FriendClass {
public:
    void AccessPrivateValue(FriendExample& obj) {
        std::cout << "Friend Class accessing privateValue: " << obj.privateValue << std::endl;
    }
};

int main() {
    FriendExample obj(42);
    FriendFunction(obj);

    FriendClass friendObj;
    friendObj.AccessPrivateValue(obj);

    return 0;
}
```

在这个示例中，`FriendExample` 类的 `privateValue` 是私有成员。`FriendFunction` 被声明为 `FriendExample` 类的友元函数，而 `FriendClass` 被声明为 `FriendExample` 类的友元类。因此，这两者都可以访问 `FriendExample` 类的私有成员。

友元机制在某些情况下很有用，例如在需要特定函数或类能够访问另一个类的私有成员时。然而，过度使用友元可能会破坏封装性，应该谨慎使用。

---

## 比特位 读写

在C++中，可以使用位操作运算符来进行比特位的读写操作。位操作运算符允许你直接对变量的二进制位进行操作，从而有效地读取和写入单个比特位。

以下是一些常用的位操作运算符和示例：

1. 与运算符（&）：
   用于检查特定比特位的状态。将要检查的比特位置1，其他位置0，然后通过与运算得到结果。

   示例：检查第3个比特位是否为1
   ```cpp
   bool isBitSet = (number & (1 << 2)) != 0;
   ```

2. 或运算符（|）：
   用于设置特定比特位的状态。将要设置的比特位置1，其他位置保持不变，然后通过或运算得到结果。

   示例：设置第5个比特位为1
   ```cpp
   number |= (1 << 4);
   ```

3. 异或运算符（^）：
   用于切换特定比特位的状态。将要切换的比特位置1，其他位置保持不变，然后通过异或运算得到结果。

   示例：切换第2个比特位的状态
   ```cpp
   number ^= (1 << 1);
   ```

4. 取反运算符（~）：
   用于取反变量的所有比特位。

   示例：将所有比特位取反
   ```cpp
   number = ~number;
   ```

5. 左移运算符（<<）：
   将一个数的所有比特位向左移动指定的位数。

   示例：将number的比特位向左移动3位
   ```cpp
   number = number << 3;
   ```

6. 右移运算符（>>）：
   将一个数的所有比特位向右移动指定的位数。对于无符号类型，左侧补0；对于有符号类型，左侧补符号位。

   示例：将number的比特位向右移动2位
   ```cpp
   number = number >> 2;
   ```

注意事项：
- 在进行位操作时，务必确保要操作的比特位在合法的范围内，避免访问未定义的行为。
- 使用无符号整数类型（例如`unsigned int`）可以避免在右移操作时出现符号位扩展的问题。

请根据你的具体需求选择适合的位操作运算符来进行比特位的读写操作。

## C++ 常用容器 详解

C++ 标准模板库（Standard Template Library，STL）提供了许多常用的容器，这些容器是用于存储和管理数据的数据结构。STL 容器提供了各种不同类型的数据结构，以满足不同的需求。以下是 C++ 中常用的 STL 容器的详细解释：

1. `std::vector`：
   `std::vector` 是一个动态数组，可以在运行时调整大小。它支持高效的随机访问和在末尾插入/删除元素，但插入/删除操作在中间位置较慢。在使用时，通常使用 `push_back` 在末尾插入元素。

2. `std::list`：
   `std::list` 是一个双向链表，支持在任意位置快速插入/删除元素，但随机访问元素较慢。在使用时，通常使用 `push_back` 和 `push_front` 在末尾和头部插入元素。

3. `std::deque`：
   `std::deque` 是一个双端队列，支持在头部和尾部快速插入/删除元素，并支持高效的随机访问。在使用时，通常使用 `push_back` 和 `push_front` 在末尾和头部插入元素。

4. `std::set`：
   `std::set` 是一个集合，它按照元素的键值自动排序，并且不允许重复的元素。它支持高效的插入/删除操作，并可以在 O(log n) 时间内查找元素。

5. `std::map`：
   `std::map` 是一个关联容器，它存储键值对，并按照键值自动排序。每个键只能对应一个值，因此不允许重复的键。

6. `std::unordered_set`：
   `std::unordered_set` 是一个无序集合，它存储不重复的元素，并支持高效的插入/删除操作和查找元素。由于它是无序的，不会进行排序。

7. `std::unordered_map`：
   `std::unordered_map` 是一个无序关联容器，它存储键值对，并支持高效的插入/删除操作和查找元素。由于它是无序的，不会进行排序。

8. `std::stack`：
   `std::stack` 是一个后进先出（LIFO）的堆栈容器，它只允许在堆栈顶部插入和删除元素。

9. `std::queue`：
   `std::queue` 是一个先进先出（FIFO）的队列容器，它只允许在队列的尾部插入元素，在队列的头部删除元素。

10. `std::priority_queue`：
    `std::priority_queue` 是一个优先队列容器，它按照元素的优先级进行排序，并支持高效的插入/删除操作。

这些是 C++ 中常用的 STL 容器。选择适当的容器取决于您的具体需求，比如数据访问方式、插入/删除操作的频率、是否需要排序等。STL 提供了这些容器以及丰富的算法和迭代器，使得在 C++ 中进行数据管理和处理变得非常方便和高效。