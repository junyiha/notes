## __sync_fetch_and_add()

+ 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`相加并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_add (type *ptr, type value, ...)`

## __sync_fetch_and_sub()

+ 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`相减并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_sub (type *ptr, type value, ...)`

## __sync_fetch_and_or()

+ 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`做按位或运算，并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_or (type *ptr, type value, ...)`

## __sync_and_and_fetch()

+ 简述：先将`*ptr`与`val`做按位与运算，返回操作之后的值
+ 声明：`type __sync_add_and_fetch (type *ptr, type value, ...)`

## __sync_bool_compare_and_swap(), __sync_val_compare_and_swap()

+ 简述：这两个函数提供原子的比较和交换，如果`*ptr`与`oldval`相等，就将`newval`写入到`*ptr`
+ 声明：
  + `bool __sync_bool_compare_and_swap(type *ptr, type oldval, type newval,...);`
    + 在相等并且写入成功的情况下，返回true；否则返回false；
  + `type __sync_val_compare_and_swap(type *ptr, type oldval, type newval,...);`
    + 返回写入之前的值

## sleep()

+ 简述：睡眠函数
+ 声明：`unsigned int sleep(unsigned int __seconds);`
+ 参数：
  + `__seconds`  --  睡眠的时间，单位为秒
+ 注意：
  + 需要包含头文件：`<unistd.h>`

## calloc()

+ 简述：分配所需的内存空间,并返回一个指向它的指针
+ 声明：`void *calloc(size_t nitems, size_t size)`
+ 参数：
  + nitems -- 要被分配的元素的个数
  + size   -- 元素的大小
+ 注意：
  + `malloc`和`calloc`之间的不同点是:`malloc`不会设置内存为零,而`calloc`会**设置分配的内存为零**

## strlen()

+ 简述：计算字符串 `str` 的长度，直到空结束字符，但不包括空结束字符
+ 声明：`size_t strlen(const char *str);`
+ 参数：
  + `str` -- 要计算长度的字符串
+ 返回值：
  + 返回字符串的长度
+ 需求：
  + 头文件：`#include <string.h>`

## dup2()

+ 简述：将 `fd` 复制到 `fd2`，关闭 `fd2` 并使其在同一文件上打开
+ 声明：`int dup2 (int fd, int fd2);`
+ 参数：
  + `fd`  --  已经打开的文件描述符
  + `fd2` --  需要重复打开的文件描述符
+ 返回值：
  + 成功
  + 失败

## write()

+ 简述：将 n 字节的 buf 写入 __fd
+ 声明：`ssize_t write(int __fd, const void *__buf, size_t __n);`
+ 参数：
  + `__fd`  --  要保存写入数据的文件
  + `__buf` --  保存要写入的内存块指针
  + `n`     --  数据大小
+ 返回值：
  + 成功  --  返回写入的数字
  + 失败  --  -1

## read()

+ 简述：将大小为`nbytes`的数据从文件`__fd`中读取到内存`__buf`中
+ 声明：`ssize_t read(int __fd, void *__buf, size_t __nbytes);`
+ 参数：
  + `__fd`  --  被读取数据的文件
  + `__buf` --  存放数据的内存块指针
  + `__nbytes`  --  要读取的数据大小
+ 返回值：
  + 成功  --  读取的数字
  + 失败  --  -1 or 0 
+ 注意：
  + 必须实际提供一个足够大的缓冲区来装载`nbyte`字节的数据
  + 常见的错误是提供了一个未初始化的指针buf，而没有提供实际的缓冲区
  + read的实现必须检测的错误及相应的错误码

## mmap()

+ 简述：
  + 映射地址从`addr`附近开始并扩展到`len`字节。从`offset`根据`prot`和`flags`写入文件`fd`中描述。
  + 如果`MAP_FIXED`位是在`flags`中设置，映射将准确地位于`addr`；否则系统会选择一个方便的附近地址
+ 声明：`void* mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);`
+ 参数：
  + `addr`  --  要映射的地址
  + `len`   --  要映射的数据大小
  + `prot`  -- 
  + `flags` --  标识
  + `fd`    --  存放需要映射数据的文件
  + `offset`--  偏移
+ 返回值：
  + 成功  --  实际映射地址
  + 失败  --  `MAP_FAILED`

## dirname()

+ 简述：返回`path`的目录部分，如果没有可用的，就返回`.`
+ 声明：`char* dirname(char *path);`
+ 参数：
  + `path`  --  需要查找目录的文件
+ 返回值：
  + 成功  --  文件所在的目录
  + 失败  --  

## basename()

+ 简述：去掉文件`pathfile`的前缀，只保存文件名(input string:/data/test.cpp , output string:test.cpp)
+ 声明：`char* basename(char *pathfile);`
+ 参数：
  + `pathfile`  --  需要操作的文件
+ 返回值：
  + 成功  --  文件名
  + 失败  --  

## readlink()

+ 简述：
  + readlink()会将参数path的 符号链接内容存储到参数buf所指的内存空间，返回的内容不是以\000作字符串结尾，但会将字符串的字符数返回，这使得添加\000变得简单。
  + 若参数bufsiz小于符号连接的内容长度，过长的内容会被截断，如果 readlink 第一个参数指向一个文件而不是 符号链接时，readlink 设 置errno 为 EINVAL 并返回 -1。 
  + readlink()函数组合了open()、read()和close()的所有操作
+ 声明：`ssize_t readlink(const char *path, char *buf, size_t bufsize);`
+ 参数：
  + `path`  --  符号连接
  + `buf`   --  存储从`path`读取到的内容
  + `bufsize` --  读取到的字符数
+ 返回值：
  + 成功  --  返回读取到的字符数
  + 失败  --  -1
+ 注意：
  + Linux系统中有一个符号链接 `/proc/self/exe` -- 它代表当前程序
  + **所以可以使用`readlink()`读取它的源路径就可以获取当前程序的绝对路径**

## strdup()

+ 简述：转储字符串，返回一个字符指针，其存储的内容和参数`s`相同，获得的内存是使用`malloc()`完成的，因此可以使用`free()`完成
+ 声明：`char* strdup(const char *s);`
+ 参数：
  + `s`  --  需要转储的字符串
+ 返回值：
  + 返回新存储的字符指针

## mkdir()

+ 简述：创建一个目录`path`，并将文件权限设置为`mode`
+ 声明：`int mkdir(const char *path, __model_t mode);`
+ 参数：
  + `path`  --  目录文件路径
  + `model` --  创建的目录文件的权限
+ 返回值：
  + 成功  --  
  + 失败  -- 

## chmod()

+ 简述：将文件`file`的权限设置为`mode`
+ 声明：`int chmod(const char* file, mode_t mode);`
+ 参数：
  + `file`  --  需要修改的文件
  + `mode`  --  权限
+ 返回值：
  + 成功  --  
  + 失败  -- 

## open()

+ 简述：以指定模式打开指定文件
+ 声明：`int open(const char *path, int __oflag, ...);`
+ 参数：
  + `path`  --  要操作的文件，绝对路径
  + `oflag` --  通常由一下常量通过或运算`I`组成
    + `O_RDONlY` 只读打开
    + `O_WRONlY` 只写打开
    + `O_RDWR` 读写打开
    + `O_EXEC` 只执行打开
    + `O_SEARCH` 只搜索（对于目录有此选项）
    + 在以上五个常量中必须指定且只能指定一个，而以下常量为可选的 
      + `O_APPEND` 每次写入追加到文件末尾
      + `O_CLOEXEC` 把FD_CLOEXEC设定为文件描述符
      + `O_CREATE` 若文件不存在则创建， 需要指定文件权限位 ， 即mode_t 参数。
      + `O_DIRECTORY` 若path指向的不为目录，则出错。
      + `O_EXCL` 若同时指定O_CREATE且文件不存在，则出错。可以将测试文件存在和创建文件封装为原子操作
      + `O_NOCTTY` 若path引用的是终端设备，则不将该设备分配作为该进程的控制终端
      + `O_NONBLOCK` 若path引用的是一个FIFO，一个块特殊文件或者字符特殊文件，则此选项将本次文件的打开操作和后续的IO操作设置为非阻塞模式
      + `O_SYNC` 每次操作需要等待物理IO完成，包括更新文件属性而需要的物理IO
      + `O_TURNC` 若文件存且为只写或读写打开，那么将其长度截断为零。
      + `O_DSYNC` 每次写入需要等待物理IO完成，但是如果不影响读取，则不需要更新文件属性
      + `O_FSYNC` 使每一个 以文件描述符为参数的进行的read操作等待，直到所有对文件同一部分的挂起写操作都完成
+ 返回值：
  + 成功  --  非负整数来表示打开的文件描述符
  + 失败  --  返回-1，并设置errno
+ 需求：
  + 头文件：`#include <fcntl.h>`  
+ 注意：
  + open的实现必须检测的错误及相应的错误码


## atoi()

+ 简述：把参数 str 所指向的字符串转换为一个整数（类型为 int 型）
+ 声明：`int atoi(const char *str);`
+ 参数：
  + `str`  -- 要转换为整数的字符串
+ 返回值：
  + 成功  --  返回转换后的整数
  + 失败  --  返回零

## atol()

+ 简述：把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）
+ 声明：`long int atol(const char *str);`
+ 参数：
  + `str` -- 要转换为长整数的字符串
+ 返回值
  + 成功  --  返回转换后的长整数
  + 失败  --  返回零

## atof()

+ 简述：把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）
+ 声明：`double atof(const char *str);`
+ 参数：
  + `str`  --  要转换为浮点数的字符串
+ 返回值：
  + 成功  --  返回转换后的双精度浮点数
  + 失败  --  返回零(0.0)

## clock_gettime()

+ 简述：获取当前时钟的时间，并保存到参数`tp`
+ 声明：`int clock_gettime(clockid_t clock_id, struct timespec *tp);`
+ 参数：
  + `clock_id`  --  时钟ID
  + `tp`        --  `timespec` 结构体指针
+ 返回值：
  + 成功  --  
  + 失败  -- 
+ 需求：
  + 头文件：`#include <time.h>`

## getline()

+ 简述：从打开的文件流中按行读取，将保存行字符的缓冲区地址保存到`*line_ptr`
+ 声明：`size_t getline(char **lineptr, size_t *n, FILE *stream);`
+ 参数：
  + `lineptr`  --  保存读取的字符的缓冲区
  + `n`        
  + `stream`   --  使用`fopen`打开的文件句柄
+ 返回值：
  + 成功  --  存储在缓冲区中的字符数，也就是读取的字符数
  + 失败  --  -1
+ 需求
  + 头文件：`#include <stdio.h>`
+ 注意：
  + `lineptr`，如果在调用函数之前被置为 `NULl`，则在函数执行过程中会自动申请内存资源，所以需要在调用失败时，手动释放`lineptr`指向的内存资源

## getdelim()

+ 简述：
  + 函数应从流读取，直到遇到与定界符字符匹配的字符为止。
  + 定界符参数是一个int，应用程序应确保其为终止读取过程的无符号字符表示的字符。
  + 如果定界符参数具有任何其他值，则行为是不确定的，换言之，从给定文件中读取流，遇到定界符参数就终止
+ 声明：`_IO_ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);`
+ 参数：
  + `lineptr`  --  指向初始缓冲区或空指针的指针
  + `n`        --  指向初始缓冲区大小的指针
  + `delimiter`--  定界线字符
  + `stream`   --  有效输入流，由`fopen()`打开
+ 返回值：
  + 成功  --  存储在缓冲区中的字符数，包括定界符，但是不包括空字符
  + 失败  --  -1

## iscntrl()

+ 简述：检查所传的字符是否是控制字符
  + 根据标准 ASCII 字符集，控制字符的 ASCII 编码介于 0x00 (NUL) 和 0x1f (US) 之间，以及 0x7f (DEL)，某些平台的特定编译器实现还可以在扩展字符集（0x7f 以上）中定义额外的控制字符
+ 声明：`int iscntrl(int c);`
+ 参数：
  + `c`  --  要检查的字符
+ 返回值：
  + 如果c 是一个控制字符，则返回非零值
  + 否则，返回0
+ 需求：
  + 头文件：`#include <ctype.h>`

## strcpy()

+ 简述：把 `src` 所指向的字符串复制到 `dest`
+ 声明：`char *strcpy(char *dest, const char *src);`
+ 参数：
  + dest  --  指向用于存储复制内容的目标数组
  + src   --  要复制的字符串
+ 返回值：
  + 成功  --  该函数返回一个指向最终的目标字符串 dest 的指针
  + 失败  --  NULL
+ 注意：
  + 如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况

## strncpy()

+ 简述：把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。
+ 声明：`char *strncpy(char *dest, const char *src, size_t n);`
+ 参数：
  + `dest`  --  指向用于存储复制内容的目标数组。
  + `src`   --  要复制的字符串。
  + `n`     --  要从源中复制的字符数。
+ 返回值：
  + 返回最终复制的字符串
+ 注意：
  + strncpy 没有自动加上终止符的，需要手动加上不然会出问题的。

## `stdio.h` 库宏

+ `NULL`    -- 这个宏是一个空指针常量的值。
+ `_IOFBF`、`_IOLBF` 和 `_IONBF` -- 这些宏扩展了带有特定值的整型常量表达式，并适用于 `setvbuf` 函数的第三个参数
+ `BUFSIZ`  -- 这个宏是一个整数，该整数代表了 `setbuf` 函数使用的缓冲区大小  
+ `EOF`     --  这个宏是一个表示已经到达文件结束的负整数
+ `FOPEN_MAX`     --  这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。
+ `FILENAME_MAX`  --  这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值
+ `L_tmpnam`  --  这个宏是一个整数，该整数代表了字符数组可以存储的由 `tmpnam` 函数创建的临时文件名的最大长度
+ `SEEK_CUR`、`SEEK_END` 和 `SEEK_SET` -- 这些宏是在 `fseek` 函数中使用，用于在一个文件中定位不同的位置
+ `TMP_MAX`   --  这个宏是 `tmpnam` 函数可生成的独特文件名的最大数量
+ `stderr`、`stdin` 和 `stdout`  --  这些宏是指向 `FILE` 类型的指针，分别对应于标准错误、标准输入和标准输出流

## `stdio.h`库函数

+ `int fclose(FILE *stream);`     --  关闭流 `stream` 。刷新所有的缓冲区。

+ `void clearerr(FILE *stream);`  --  清除给定流 `stream` 的文件结束和错误标识符。

+ `int feof(FILE *stream);`       --  测试给定流 `stream` 的文件结束标识符

+ `int ferror(FILE *stream);`     --  测试给定流 `stream` 的错误标识符

+ `int fflush(FILE *stream);`     --  刷新流 `stream` 的输出缓冲区

+ `int fgetpos(FILE *stream, fpos_t *pos);`  -- 获取流 `stream` 的当前文件位置，并把它写入到 `pos`

+ `FILE *fopen(const char *filename, const char *mode);`   -- 使用给定的模式 `mode` 打开 `filename` 所指向的文件

+ `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`     --  从给定流 `stream` 读取数据到 `ptr` 所指向的数组中

+ `FILE *freopen(const char *filename, const char *mode, FILE *stream);`  --  把一个新的文件名 `filename` 与给定的打开的流 `stream` 关联，同时关闭流中的旧文件
  
+ `	int fseek(FILE *stream, long int offset, int whence);` -- 设置流 `stream` 的文件位置为给定的偏移 `offset` ，参数 `offset` 意味着从给定的 `whence` 位置查找的字节数
  
+ `int fsetpos(FILE *stream, const fpos_t *pos);`  --  设置给定流 `stream` 的文件位置为给定的位置。参数 `pos` 是由函数 `fgetpos` 给定的位置

+ `long int ftell(FILE *stream);`     -- 返回给定流 `stream` 的当前文件位置

+ `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);`  --  把 `ptr` 所指向的数组中的数据写入到给定流 `stream` 中。

+ `int remove(const char *filename);` --  删除给定的文件名 `filename` ，以便它不再被访问

+ `int rename(const char *old_filename, const char *new_filename);`  --  把 `old_filename` 所指向的文件名改为 `new_filename`

+ `void rewind(FILE *stream);`  --  设置文件位置为给定流 `stream` 的文件的开头

+ `void setbuf(FILE *stream, char *buffer);`  --  定义流 `stream` 应如何缓冲。

+ `int setvbuf(FILE *stream, char *buffer, int mode, size_t size);`  --  另一个定义流 `stream` 应如何缓冲的函数

+ `FILE *tmpfile(void);`  --  以二进制更新模式(`wb+`)创建临时文件

+ `char *tmpnam(char *str);`  --  生成并返回一个有效的临时文件名，该文件名之前是不存在的

+ `int fprintf(FILE *stream, const char *format, ...);`  --  发送格式化输出到流 `stream` 中

+ `int printf(const char *format, ...);`  --  发送格式化输出到标准输出 `stdout`

+ `int sprintf(char *str, const char *format, ...);`  --  发送格式化输出到字符串

+ `int vfprintf(FILE *stream, const char *format, va_list arg);`  --  用参数列表发送格式化输出到流 `stream` 中

+ `int vprintf(const char *format, va_list arg);`  --  使用参数列表发送格式化输出到标准输出 `stdout`

+ `int vsprintf(char *str, const char *format, va_list arg);`  --  使用参数列表发送格式化输出到字符串

+ `int fscanf(FILE *stream, const char *format, ...);`  --  从流 `stream` 读取格式化输入

+ `int scanf(const char *format, ...);`  --  从标准输入 `stdin` 读取格式化输入

+ `int sscanf(const char *str, const char *format, ...);`  --  从字符串读取格式化输入

+ `int fgetc(FILE *stream);`  --  从指定的流 `stream` 获取下一个字符（一个无符号字符），并把位置标识符往前移动

+ `char *fgets(char *str, int n, FILE *stream);`  --  从指定的流 `stream` 读取一行，并把它存储在 `str` 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定
  
+ `int fputc(int char, FILE *stream);`  --  把参数 `char` 指定的字符（一个无符号字符）写入到指定的流 `stream` 中，并把位置标识符往前移动

+ `int fputs(const char *str, FILE *stream);`  --  把字符串写入到指定的流 `stream` 中，但不包括空字符

+ `int getc(FILE *stream);`  --  从指定的流 `stream` 获取下一个字符（一个无符号字符），并把位置标识符往前移动

+ `int getchar(void);`  --  从标准输入 `stdin` 获取一个字符（一个无符号字符）

+ `char *gets(char *str);`  --  从标准输入 `stdin` 读取一行，并把它存储在 `str` 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定
  
+ `int putc(int char, FILE *stream);`  --  把参数 `char` 指定的字符（一个无符号字符）写入到指定的流 `stream` 中，并把位置标识符往前移动

+ `int putchar(int char);`  --  把参数 `char` 指定的字符（一个无符号字符）写入到标准输出 `stdout` 中

+ `int puts(const char *str);`  --  把一个字符串写入到标准输出 `stdout` ，直到空字符，但不包括空字符。换行符会被追加到输出中

+ `int ungetc(int char, FILE *stream);`  --  把字符 `char`（一个无符号字符）推入到指定的流 `stream` 中，以便它是下一个被读取到的字符

+ `void perror(const char *str);`  --  把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 `str` ，后跟一个冒号，然后是一个空格

+ `int snprintf(char *str, size_t size, const char *format, ...);`  --  格式字符串到 `str` 中

## fopen()

+ 简述：使用给定的模式(mode)打开(filename)所指向的文件
+ 声明： `FILE *fopen(const char *filename, const char *mode);`
+ 参数：
  + `filename` -- 字符串，表示要打开的文件名称
  + `mode`     -- 字符串，表示文件的访问模式
    + `r`  -- 打开一个用于读取的文件。该文件必须存在
    + `w`  -- 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件
    + `a`  -- 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件
    + `b`  -- 以二进制模式打开文件
    + `r+` -- 打开一个用于更新的文件，可读取也可写入。该文件必须存在
    + `w+` -- 创建一个用于读写的空文件
    + `a+` -- 打开一个用于读取和追加的文件
+ 返回值：
  + 成功  -- 返回一个`FILE`指针
  + 失败  -- 返回`NULL`，且设置全局变量`errno`来标识错误

## fwrite()

+ 简述：把 `ptr` 所指向的数组中的数据写入到给定流 `stream` 中
+ 声明：`size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);`
+ 参数：
  + `ptr`    -- 这是指向要被写入的元素数组的指针
  + `size`   -- 这是要被写入的每个元素的大小，以字节为单位
  + `nmemb`  -- 这是元素的个数，每个元素的大小为 size 字节
  + `stream` -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流
+ 返回值：
  + 成功  -- 返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型
  + 失败  -- 返回一个错误

## fprintf()

+ 简述：发送格式化输出到流 stream 中
+ 声明：`int fprintf(FILE *stream, const char *format, ...);`
+ 参数：
  + stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。
  + format -- 这是 C 字符串，包含了要被写入到流 stream 中的文本。
    + 它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。
    + format 标签属性是 `%[flags][width][.precision][length]specifier`
+ 返回值：
  + 成功  --  返回写入的字符总数
  + 失败  --  返回一个负数

## fflush()

+ 简述：刷新流 `stream` 的输出缓冲区
+ 声明：`int fflush(FILE *stream);`
+ 参数：
  + `stream` -- 这是指向 `FILE` 对象的指针，该 `FILE` 对象指定了一个缓冲流
+ 返回值：
  + 成功 -- 返回零值
  + 失败 -- 返回 EOF，且设置错误标识符（即 feof）
+ 头文件：
  + `stdio.h`

## fseek()

+ 简述：设置流 `stream` 的文件位置为给定的偏移 `offset`，参数 `offset` 意味着从给定的 `whence` 位置查找的字节数。
+ 声明：`int fseek(FILE *stream, long int offset, int whence);`
+ 参数：
  + stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流
  + offset -- 这是相对 whence 的偏移量，以字节为单位
  + whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：
    + SEEK_SET  --  文件的开头
    + SEEK_CUR  --  文件指针的当前位置
    + SEEK_END  --  文件的末尾
+ 返回值：
  + 成功 -- 返回零值
  + 失败 -- 返回非零值

## ftell()

+ 简述：返回给定流 stream 的当前文件位置
+ 声明：`long int ftell(FILE *stream);`
+ 参数：
  + stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流
+ 返回值：
  + 成功  --  该函数返回位置标识符的当前值
  + 失败  --  返回 -1L，全局变量 errno 被设置为一个正值。

## fgets()

+ 简述：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内
+ 声明：`char *fgets(char *str, int n, FILE *stream);`
+ 参数：
  + str -- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。
  + n -- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度
  + stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。
+ 返回值：
  + 成功  --  返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。
  + 失败  --  返回一个空指针。
+ 注意：
  + 当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定


## rewind()

+ 简述：设置文件位置为给定流 `stream` 的文件的开头
+ 声明：`void rewind(FILE *stream);`
+ 参数：
  + `stream` -- 这是指向 `FILE` 对象的指针，该 `FILE` 对象标识了流。
+ 返回值：
  + 无
+ 头文件：
  + `stdio.h`

## access()

+ 简述：确定文件或文件夹的访问权限。即，检查某个文件的存取方式，例如说是只读方式，只写方式等。
+ 声明：`int access (const char *__name, int __type);`
+ 参数
  + `name` -- 文件路径
  + `type` -- 判断参数
    + `R_OK 4` -- 读权限
    + `W_OK 2` -- 写权限
    + `X_OK 1` -- 执行权限
    + `F_OK 0` -- 是否存在
+ 返回值：
  + 指定的存取方式有效，则函数返回0，
  + 指定的存取方式无效，则返回-1
+ 需求：
  + 头文件：`#include <unistd.h>`

## remove()

+ 简述：通过文件名称删除文件
+ 声明：`int remove(const char* __filename);`
+ 参数：
  + `filename`  --  指向文件名的字符指针
+ 需求：
  + 头文件：`#include <stdio.h>`

## rename()

+ 简述：重命名一个文件
+ 声明：`int rename(const char* old, const char* new);`
+ 参数：
  + `old`  --  旧的文件名
  + `new`  --  新的文件名
+ 返回值：
  + 成功  -- 
  + 失败  -- 
+ 需求：
  + `#include <stdio.h>`

## assert()

+ 简述：C库宏 允许诊断信息被写入到标准错误文件中。换句话说，它可用于在C程序中添加诊断
+ 声明：`void assert(int expression)`
+ 参数：
  + `expression` : 这可以是一个变量或任何C表达式。
    + 如果`expression`为真，`assert()`不执行任何动作。
    + 如果`expression`为假，`assert()`会在标准错误`stderr`上显示错误消息，并中止程序执行。

## getenv()

+ 简述：搜索 name 所指向的环境字符串，并返回相关的值给字符串，
+ 声明：`#include <stdlib.h>  char* getenv (const char* name);`
+ 参数：
  + name  --  包含被请求变量名称的C字符串
+ 返回值：
  + 成功  --  返回一个以NULL结尾的字符串，该字符串为被请求环境变量的值
  + 失败  --  返回NULL
+ 注意：
  + 如果没有将第一次返回的字符串拷贝到缓冲区中去，多次调用`getenv`就要特别小心
  + `getenv`的某些实现为返回字符串使用了静态缓冲区，**每次调用时都会重写缓冲区**

## to_string()

+ 简述:一个字符串对象，包含val作为字符序列的表示形式
+ 声明：`string to_string(int val);`
+ 参数：
  + `val`  --  数值

## strcat()

+ 简述：将源字符串的副本附加到目标字符串。目标中的终止空字符被源的第一个字符覆盖，并且在目标中两者连接形成的新字符串的末尾包含一个空字符。
+ 声明：`char* strcat(char* destination, const char* source);`
+ 参数：
  + `destination` ： 指向目标数组的指针，它应该包含一个C字符串，并且足够大以包含连接的结果字符串。
  + `source` : 要附加的C字符串，这部应该与目标字符串相同。

## puts()

+ 简述：
  + 将字符串写入标准输出。将str指向的C字符串写入标准输出(stdout)并且附加一个换行符(`'\n'`)。
  + 该函数从指定的地址（str）开始复制，直到到达终止空字符（'\0')。此终止空字符不会复制到流中
  + 注意，puts不仅与fputs不同，它使用标准输出作为目标，而且它还在末尾自动附加一个环行符（fputs则没有）
+ 声明：`int puts(const char* str);`
+ 参数：
  + `str` : 需要打印的C字符串
+ 返回值
  + 成功  --  返回一个非负值
  + 失败  --  该函数返回EOF并且设置错误指示符(ferror)

## sprintf()

+ 简述：发送格式化输出到str所指向的字符串
+ 声明：` int sprintf(char *str, const char* format, ... )`
+ 参数：
  + `str`：这是指向一个字符数组的指针，该数组存储了C字符串
  + `format`:这是字符串，包含了要被写入到字符串`str`的文本。它可以包含嵌入的`format`标签，`format`标签可被随后的附加参数中指定的值替换，并按需求进行格式化。`format`标签属性是`%[flags][width][.precision][length]specifier`
  + 具体详情：
  + `specifier, 类型说明符`：
    + `c` : 字符
    + `d, i` : 有符号的十进制整数
    + `e` : 使用`e`字符的科学计数法（尾数和指数）
    + `E` : 使用`E`字符的科学计数法（尾数和指数）
    + `f` : 十进制浮点数
    + `g` : 自动选择`%e`或`%f`中合适的表示法
    + `G` : 自动选择`%E`或`%f`中合适的表示法
    + `o` : 有符号八进制
    + `s` : 字符的字符串
    + `u` : 无符号十进制整数
    + `x` : 无符号十六进制整数
    + `X` : 无符号十六进制整数（大写字母）
    + `p` : 指针地址
    + `n` : 无输出
    + `%` : 字符
+ 返回值：
  + 成功  --  返回写入的字符总数，不包括字符串追加在字符串末尾的空字符
  + 失败  --  返回一个负数
+ 需求：
  + 头文件：`#include <stdio.h>`
  
## snprintf()

+ 简述：将格式化的输出写入大小适中的缓冲区
+ 声明：`int snprintf(char* s, size_t n, const char* format, ...);`
+ 参数：
  + `s` -- 指向存储C字符串的缓冲区的指针。这个缓冲区的大小至少要能存储`n`个字符
  + `n` -- 在缓冲区存储的最大字节数。通常，生成的字符串最大长度为`n-1`，留下一个空间存储空字符
  + `format` -- 和printf格式一样，C字符串要存储的格式
+ 返回值
  + 如果写入正常，返回被写入的字符数
  + 如果错误，返回一个负数
  + 只有当返回的不是一个负数，且小于`n`时，字符串才被完全写入

## sscanf()

+ 简述：
  + 从s读取数据并根据参数格式将它们存储到附加参数给出的位置，就像使用了scanf一样，但从s而不是标准输入（stdin）读取数据。
  + 附加参数应该指向已分配的对象，其类型由格式字符串中的相应格式说明符指定。
+ 声明：`int sscanf(const char* s, const char* format, ...);`
+ 参数：
  + `s`  --  存储数据的指针
  + `format`  --  格式化字符串
+ 返回值：
  + 成功  --  返回参数列表中成功填充的项目数。
  + 失败  --  匹配预期的项目数或更少（甚至为零）
+ 需求：
  + 头文件：`#include <stdio.h>`

## c_str()

+ 返回指向包含以null结尾的字符序列（即C字符串）的数组的指针，该字符序列表示字符串对象的当前值。
+ 这个数组包含构成字符串对象值的相同字符序列，以及末尾的附加终止空字符`\0` 
+ 返回值：指向字符串对象值的C字符串表示形式的指针。

## strtok()

+ 简述： 分解字符串 str 为一组字符串，delim 为分隔符
+ 声明：`char *strtok(char *str, const char *delim);`
+ 参数：
  + str -- 要被分解成一组小字符串的字符串。
  + delim -- 包含分隔符的 C 字符串。
+ 返回值：
  + 函数返回被分解的第一个子字符串
  + 如果没有可检索的字符串，则返回一个空指针。
+ 注意：
  + 首次调用时，`str`指向要分解的字符串，之后再次调用要把`str`设置称为NULL
  + 当strtok()在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为\0 字符。
  + 在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针
  + 需要注意的是，**使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了**。
  + 第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。

## strtok_r()

+ 简述：linux下分割字符串的安全函数
+ 声明：`char *strtok_r(char *str, const char *delim, char **saveptr);`
+ 参数：
  + str -- 要被分解成一组小字符串的字符串。
  + delim -- 包含分隔符的 C 字符串。
  + saveptr -- 保存剩余的字符
+ 返回值：
  + 函数返回被分解的第一个子字符串
  + 如果没有可检索的字符串，则返回一个空指针。
+ 注意：
  + 该函数也会破坏带分解字符串的完整性，但是其将剩余的字符串保存在saveptr变量中，保证了安全性

## strchr和sscanf组合，按指定分隔符分割字符串

## strtol()

+ 简述：
  + 解析C字符串str，将其内容解释为指定基数的整数，该基数作为long int返回。如果endptr不是空指针，该函数还将endptr的值设置为指向数字后的第一个字符。
  + 该函数首先根据需要丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，按照依赖于基本参数的语法获取尽可能多的有效字符，并将它们解释为数值。
  + 最后，指向str中整数表示之后的第一个字符的指针存储在endptr指向的对象中。
+ 声明：` long int strtol (const char* str, char** endptr, int base);`
+ 参数：
  + `str`:以整数表示的C字符串开头(C-string beginning with the representation of an integral number)
  + `endptr`:引用`char*`类型的对象，其值由函数设置为`str`中数值之后的下一个字符。
  + `base`:确定有效字符及其解释的数字基数
+ 返回值：
  + 成功时，该函数将转换后的整数作为long int值返回
  + 如果无法执行有效转换，则返回零值
+ 需求：
  + 头文件：`#include <stdlib.h>`

## reserve()

+ 简述：请求更改容量
+ 声明：`void reserve (size_type n);`
+ 参数：
  + `n` ： 向量的最小容量。

## C标准库 -- `stdarg.h`

+ 简介：
  + `stdarg.h`头文件定义了一个变量类型`va_list`和三个宏，
  + 这三个宏可用于在参数个数未知（即**参数个数可变**）时获取函数中的参数。
  + 可变参数的函数通过在参数列表的末尾是使用省略号（`...`）定义的。

+ **库变量：**
  + `va_list` ： 这是一个适用于`va_start()`, `va_arg()` 和 `va_end()`这三个宏存储信息的类型。

+ **库宏：**
  + `void va_start(va_list ap, last_arg)`：
    + 这个宏初始化`ap`变量，它与`va_arg`和`va_end`宏是一起使用的。`last_arg`是最后一个传递给函数的已知的固定参数，即省略号之前的参数。这个宏必须在使用`va_arg`和`va_end`之前被调用
    + 参数：
      + `ap` -- 这是一个`va_list`类型的对象，它用来存储通过`va_arg`获取额外参数时所必需的信息。
      + `last_arg` -- 最后一个传递给函数的已知的固定参数
  + `void va_end(va_list ap)`:
    + C库宏`void va_end(va_list ap)`允许使用了`va_start`宏的带有可变参数的函数返回。如果在从函数返回之前没有调用`va_end`，则结果为未定义
    + 参数：
      + `ap` -- 这是之前由同一函数中的`va_start`初始化的`va_list`对象。

## std::get()

+ 简述：
  + 返回对元组`tpl`的第`I`个元素的引用。
  + 版本2将元组的右值作为引用参数，向前应用到返回的元素
  + 版本3将const元组作为参数，返回对元素的const引用
+ 声明：
    ```c++
      (1)template <size_t I, class... Types> typename tuple_element<I, tuple<Types...>>::type& get(tuple<Types...>& tpl) noexcept;
      (2)template <size_t I, class... Types> typename tuple_element<I, tuple<Types...>>::type&& get(tuple<Types...>&& tpl) noexcept;
      (3)template <size_t I, class... Types> typ
      ename tuple_element<I, tuple<Types...>>::type const& get(tuple<Types...>& tpl) noexcept;
    ```
+ 参数
  + `I` -- 元组中元素的位置，0为第一个元素的位置，`size_t`是无符号整数类型
  + `Types` -- 元组中元素的类型（通常从tpl隐式获得）
+ 返回值
  + 对元组中指定位置的元素的引用

## fstat()

+ 简述：获取报告与打开的文件描述符`fildes`有关的文件的状态信息
+ 声明：`int fstat(int __fd, struct stat *__buf);`
+ 参数：
  + `__fd`  --  文件描述符
  + `__buf` --  内存区域指针，用户提供的缓冲区，`fstat`将信息写入这个缓冲区
+ 返回值：
  + 成功  --  0
  + 失败  --  1
+ 需求：
  + 头文件：`#include <sys/stat.h>`

## fmemopen()

+ 简述：创建一个新的引用内存缓冲区的流
+ 声明：`FILE* fmemopen(void *s, size_t len, const char *modes);`
+ 参数：
  + `s`     --  
  + `len`   -- 
  + `modes` -- 
+ 返回值：
  + 成功  --  返回创建的流指针
  + 失败  --  
+ 注意：
  + 虽然仍使用FILE指针进行访问，但其实并没有底层文件（并没有磁盘上的实际文件，因为打开的内存流fp是在内存中的）
  + 所有的I/O都是通过在缓冲区与主存（就是内存）之间来回传送字节来完成的

## mmap()

+ mmap(memory map，即地址的映射)，是一种内存映射文件的方法，将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。
+ `mmap()`系统调用，使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以访问普通内存一样对文件进行访问，不必再调用`read(), write()`等操作。
+ mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而POSIX或系统V的共享内存IPC则只是用于共享目的。

+ Linux通过内存映像机制来提供用户程序对内存直接访问的能力。内存映像的意思是把内核中特定部分的内存空间映射到用户级程序的内存空间去。也就是说，用户空间和内核空间共享一块相同的内存。
+ 相对于传统的write/read IO系统调用，必需先把数据从磁盘拷贝至内核缓冲区（页缓冲），然后再把数据拷贝至用户进程中。两者相比，mmap会少一次拷贝数据，这样带来的性能提升是巨大的

+ 声明：`void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);`
+ 参数
  + `addr` -- 指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成
  + `length` -- 指的是映射到调用进程地址空间的字节数，它从被映射文件开头offset各字节开始算起
  + `prot` -- 指定共享内存的访问权限
  + `flags` -- 常值 ： MAP_SHARED, MAP_PRIVATE, MAP_PIXED`
  + `offset` -- 一般设置为0，表示从文件头开始映射
  + `fd` -- 为即将映射到进程空间的文件描述字，一般由`open()`返回。
+ 返回值
  + 函数的返回值为最后文件映射到进程空间的地址，进程可直接操作其是地址为该值的有效地值。
+ 需求：
  + 头文件：`#include <sys/mman.h>`

+ 具体原理：`https://blog.csdn.net/Holy_666/article/details/86532671`

## munmap()

+ 简述：解除任何内存映射
+ 声明：`int munmap(void* __addr, size_t __len);`
+ 参数：
  + `addr`  --  内存地址
  + `__len` --  内存地址大小
+ 返回值
  + 成功  --  0
  + 失败  --  -1
+ 需求：
  + 头文件：`#include <sys/mman.h>`

## 锁定物理内存 -- mlock家族

+ 锁住内存是为了防止这段内存被操作系统交换掉(swap)，并且由于此操作风险高，仅超级用户可以执行。

+ 家族成员
  ```c
    #include <sys/mman.h>
    int mlock(const void* addr, size_t len);
    int munlock(const void* addr, size_t len);
    int mlockall(int flags);
    int munlockall(void);
  ```

+ `getpagesize()` 函数返回系统的分页大小，在X86 Linux系统上，这个值是4KB

+ 如果希望程序的全部地址空间被锁定在物理内存中，使用 `mlockall` ，该函数将调用进程的全部虚拟地址空间加锁，防止出现内存交换，将该进程的地址空间交换到外存上
+ `mlockall()` 将所有映射到进程地址空间的内存上锁，这些页包括 -- 代码段，数据段，栈段，共享库，共享内存, user space kernel data, memory-mapped file。当函数成功返回的时候，所有的被映射的页都在内存中
+ 参数
  + `MCL_CURRENT` -- 仅当前已分配的内存会被锁定，之后分配的内存则不会
  + `MCL_FUTURE` -- 锁定之后分配的所有内存
  + `MCL_CURRENT|MCL_FUTURE` -- 将已经以及将来分配的所有内存锁定在物理内存中
+ 返回值
  + 成功返回`0`
  + 出错返回`-1`
+ 此函数有两个重要的应用：
  + `real-time algorithms（实时算法）` -- 对事件要求非常高
  + `high-scurity data processing（机密数据的处理）` -- 如果数据被交换到外存上，可能会泄密
+ 如果进程执行了一个`execve`类函数，所有的锁都会被删除
+ 内存锁不会被子进程继承
+ 内存锁不会叠加，即使多次调用`mlockall()`函数，只调用一次`munlockall()`就会解锁

## clock_gettime()

+ 简述：用于计算时间，有秒和纳秒两种精度
+ 函数声明：`int clock_gettime(clockid_t clk_id, struct timespec *tp);`
+ 参数：
  + `clockid_t clk_id`有四种
    + `CLOCK_REALTIME` -- 系统实时时间，随系统实时时间改变而改变
    + `CLOCK_MONOTONIC` -- 从系统启动这一刻开始计时，不受系统时间被用户改变的影响
    + `CLOCK_PROCESS_CPUTIME_ID` -- 本进程到当前代码系统CPU花费的时间
    + `CLOCK_THREAD_CPUTIME_ID` -- 本线程到当前代码系统CPU花费的时间

## vsscanf()

+ 简述：**将格式化数据从字符串读取到变量参数列表中**。从s读取数据并根据参数格式将它们存储到由arg标识的变量参数列表中的元素所指向的位置。
+ 声明：`int vsscanf(const char* s, const char* format, va_list arg);`
  + 在内部，该函数从由arg标识的列表中检索参数，就好像在其上使用了`va_arg`一样，因此`arg`的状态可能会被调用更改。
  + 无论如何，`arg`应该在调用之前的某个时间点由`va_start`初始化，并且预计在调用之后的某个时间点由`va_end`释放。
+ 参数
  + `s` -- 函数将其处理为检索数据的源的C字符串
  + `format` -- 包含**格式字符串**的C字符串，该格式字符串遵循与`scanf`中的格式相同的规范
  + `arg` -- 一个值，用于标识使用`va_start`初始化的变量参数列表。`va_list`是在`<cstdarg>`中定义的特殊类型。
+ 返回值：
  + 成功时，该函数返回参数列表中成功填充的项目数
  + 在匹配失败的情况下，此计数可以匹配预期的项目数或更少，甚至为零。
  + 如果在成功解释任何数据之前输入失败，则返回EOF

## memset()

+ 简述：将`ptr`指向的内存块的前`num`字节设置为指定值（解释为无符号字符）
+ 声明：`void* memset(void* ptr, int value, size_t num);`
+ 参数
  + `ptr` -- 指向要填充的内存块的指针
  + `value` -- 要设置的值。该值作为int传递，但是该函数使用该值的转换的无符号字符填充内存块
  + `num` -- 要设置为值的字节数。`size_t`是无符号整数类型
+ 返回值
  + 返回`ptr`

## max()

+ 简述：返回a和b中的最大值。如果两者相等，则返回a
+ 声明：`template <class T> const T& max (const T& a, const T& b);`
+ 返回值
  + 作为参数传递的最大值