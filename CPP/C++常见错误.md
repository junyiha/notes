## 段错误:`Segmentation fault`

+ 段错误是什么？
  + 段错误是指访问的内存超出了系统给这个程序所设定的内存空间。

+ 段错误产生的原因
  1. 访问不存在的内存地址
  2. 访问系统保护的内存地址
  3. 访问制度的内存地址
  4. 栈溢出
  5. delete使用错误

## `corrupted size vs. prev_size` 问题 内存越界

+ 在C++中我们时常会遇见`corrupted size vs. prev_size`的报错，它的原因在于**内存越界**
+ 其实解决这个问题的办法在于使用`vector`来代替自己申请内存，并且使用以下两种方法来访问元素：
  + 使用迭代器
  + 使用`at`

+ 尽量要避免使用`[]`来访问`vector`，越界的时候很难找到错误的地方，使用`at`带有越界的检查，更为安全。

## `memory corruption`  内存泄漏

## 内存问题

+ 内存问题始终是C++程序员需要去面对的问题，这也是C++语言门槛高的原因之一

+ 常见的内存问题：
  1. 内存重复释放，出现`double free`时，通常是由于这种情况导致的
  2. 内存泄漏，分配的内存忘记释放
  3. 内存越界使用，使用了不该使用的内存
  4. 使用了无效指针
  5. 空指针，对一个空指针进行操作 

+ 内存越界，引起的问题有极大的不确定性，有时大，有时小，有时可能不会对程序的运行产生影响，正是这种不易复现的错误，才是最致命的。
+ 内存越界，通常可能会造成如下几种情况：
  1. 破坏了堆中的内存分配信息数据，特别是动态分配的内存块的内存信息数据。因为操作系统在分配和释放内存块时需要访问该数据，一旦该数据被破坏，可能会出现一下几种情况：
        ```
        *** glibcdetected *** free(): invalid pointer:
        *** glibcdetected *** malloc(): memory corruption:
        *** glibcdetected *** double free or corruption (out): 0x00000000005c18a0 ***
        *** glibcdetected *** corrupted double-linked list: 0x00000000005ab150***
        ```    
  2. 破坏了程序自己的其他对象的内存空间，这种破坏会影响程序执行的不正确性，当然也会诱发`coredump`，如破坏了指针数据
  3. 破坏了空闲内存块
  4. 通常，代码错误被激发是偶然的，也就是说之前的程序一切正常，可能由于为类增加了两个成员变量，或者改变了某一部分代码，`coredump`就频繁发生，而增加的代码绝不会有任何问题，这时应该考虑**是否是某些内存被破坏了**。

+ 注意事项：
  1. **出现段错误时**，首先应该想到段错误的定义，从它出发考虑引发错误的原因
  2. **在使用指针时**，定义了指针后记得初始化指针，在使用的时候记得判断是否为NULL
  3. **在使用数组时**，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等
  4. **在访问变量时**，注意变量所占地址空间是否已经被程序释放
  5. **在处理变量时**，注意变量的格式控制是否合理等

## 核心转储:`core dumped`

+ 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的**内存状态**记录下来，保存在一个文件中，这种行为就叫做`Core Dump`（中文有的翻译成 核心转储）
+ 可以认为`core dump`是内存快照，但实际上，除了内存信息之外，还有一些关键的程序运行状态也会同时`dump`下来，例如寄存器信息（包括程序指针，栈指针），内存管理信息，其他处理器和操作系统状态和信息。
+ `Segmentation fault (core dumped)`通常是内存未正常操作造成。空指针，野指针的读写操作，数组越界访问，破坏常量等。

+ 打开`core dump`功能
  1. 在终端输入命令`ulimit -c`，输出结果为0，表示关闭`core dump`，即当程序异常终止时，也不会生成`core dump`文件
  2. 可以使用命令`ulimit -c unlimited`来开启`core dump`功能，并且不限制`core dump`文件的大小；如果需要限制文件的大小，将`unlimited`换成想生成文件的存储上限，单位为blocks(KB)
  3. 用上面命令只会对当前终端环境有效，如果想要永久生效，需要设置文件`/etc/security/limits.conf`文件
  4. 默认生成的`core`文件保存在可执行文件所在的目录下，文件名就为`core`
  5. 修改文件`/proc/sys/kernel/core_uses_pid`文件可以让生成`core`文件名自动加上pid号
  6. 修改文件`/proc/sys/kernel/core_pattern`控制生成`core`文件保存的位置以及文件名格式

## Linux下C/C++程序内存泄露检查工具

+ valgrind:强大开源的程序检测工具
+ mtrace:GNU扩展,用来跟踪malloc
+ dmalloc:用于检查C/C++内存泄露的工具,即是检查是否在程序运行结束还没有释放的内存,以一个运行库发布
+ memwatch:和dmalloc一样,能够检测未释放的内存,同一段内存被释放多次,位地址取错误及不当使用未分配的内存区域
+ mpatrol:一个跨平台的C++内存泄露检测器
+ dbgmem:是一个动态库发布的形式,有点类似于dmalloc

### Valgrind详解

+ `Valgrind`包含以下一些工具:
  1. `Memcheck`:这是`valgrind`应用最广泛的工具,一个重量级的内存检查器,能够发现 开发中绝大不多述的内存错误使用的情况,比如:使用未初始化
  2. `callgrind`:主要用来检查程序中函数调用过程中出现的问题
  3. `cachegrind`:主要用来检查程序中缓存使用出现的问题
  4. `Helgrind`:主要用来检查多线程中出现的竞争问题
  5. `Massif`:主要用来检查程序中堆栈使用中出现的问题
  6. `Extension`:可以使用core提供的功能,自己编写特定的内存调试工具

+ 内存检查原理:
  1. `Valid-value`表:对于进程的整个地址空间中的每一个字节(byte),都有与之对应的8个bits,对于CPU的每个寄存器,也有一个与之对应的bit向量,这些bits负责记录该字节或者寄存器值是否具有有效的,已经初始化的值
  2. `Valid-Address`表:对于进程整个地址空间中的一个字节(byte),还有与之对应的1bit,负责记录改地址是否能够被读写
  3. 检测原理:
     + 当要读写内存中的某个字节时,首先检查这个字节对应的A bit, 如果该A bit显示该位置是无效位置,memcheck则报告读写错误
     + 内核(core)类似于一个虚拟的CPU环境,这样当内存中的某个字节被加载到真实的CPU中时,该字节对应的V bit也被加载到虚拟的CPU环境中,一旦寄存器中的值,被用来产生内存地址,或者该值能够影响程序的输出,则memcheck会检查对应的vbits,如果该值尚未初始化,则会报告使用未初始化内存错误

+ `Valgrind`的安装
  1. 解压安装包:`tar -jxvf valgrind-3.11.0.tar.bz2 -C /usr/local/src`
  2. 进入目录安装:`cd /usr/local/src/valgrind-3.11.0`
  3. 运行 `./autogen.sh` 设置环境(需要标准的`autoconf`工具):`./autogen.sh`
  4. 配置`Valgrind`,生成Makefile文件:`./configure --prefix=/usr/local`
  5. 编译和安装`valgrind`:`make && make install`

+ `Valgrind`的使用 
  + 为了`valgrind`发现的错误更精确,如能够定位到源代码的行,建议在编译时加上-g参数,编译优化选项选择O0(不要优化)
  + 利用`valgrind`调试内存问题,不需要重新编译源程序,它的输入就是二进制的可执行程序
  + 调用`valgrind`的通用格式:valgrind [valgrind-options] your-program [your-program-options]
  + `Valgrind`的参数分为两类
      + 一类是core的参数,它对所有的工具都适用
      + 另一类就是具体某个工具,如memcheck的参数.
  + `Valgrind`默认的工具就是memcheck,也可以通过 `-tool=toolname` 指定其他的工具

+ `Memcheck`将内存泄露分为两种:
  1. `Possibly lost`:可能的内存泄露
        + `Possibly lost`是指仍然存在某个指针能够访问某块内存,但是该指针指向的已经不是该内存的首地址
  2. `Definitely lost`:确定的内存泄漏
        + 确定的内存泄露是指已经不能够访问这块内存
        + `Definitely lost`又分为两种:
            1. `direct`:直接,直接是没有任何指针指向该内存
            2. `indirect`:间接,指向该内存的指针都位于内存泄露处

+ `Valgrind`常用命令
  + `-log-file=valReport` :指定生成分析日志文件到当前执行目录,文件名为 `valReport`
  + `-leak-check=full` :显示每个泄露的详细信息
  + `-show-reachable=yes` :是否检测控制范围之外的泄露,比如全局指针,`static`指针等,显示所有的内存泄露类型
  + `-leak-resolution=low` :内存泄露报告合并等级

+ `Valgrind`输出内容:
  + `==98725==` :进程号,如果程序使用了多进程的方式来执行,就会显示多个进程的内容
  + 第一段是`valgrind`的基本信息
  + 第二段是对堆内存分配的总结信息,
  + 第三段的内容描述了内存泄露的具体信息
  + 最后一段是总结,4字节为一块的内存泄露