## 查找算法

在C++中，可以使用标准库提供的范围查找算法来在容器中查找特定元素或满足特定条件的元素。以下是一些常用的范围查找算法：

1. `std::find()`：在指定范围内查找指定值的第一个匹配项。

```cpp
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    auto it = std::find(numbers.begin(), numbers.end(), 3);
    if (it != numbers.end()) {
        // 找到了元素
    } else {
        // 没有找到元素
    }

    return 0;
}
```

2. `std::find_if()`：在指定范围内查找满足特定条件的第一个元素。

```cpp
#include <algorithm>
#include <vector>

bool isEven(int num) {
    return num % 2 == 0;
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    auto it = std::find_if(numbers.begin(), numbers.end(), isEven);
    if (it != numbers.end()) {
        // 找到满足条件的元素
    } else {
        // 没有找到满足条件的元素
    }

    return 0;
}
```

3. `std::binary_search()`：在已排序的范围内执行二分查找，判断指定值是否存在。

```cpp
#include <algorithm>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    bool exists = std::binary_search(numbers.begin(), numbers.end(), 3);
    if (exists) {
        // 值存在
    } else {
        // 值不存在
    }

    return 0;
}
```

这些是一些常见的范围查找算法示例，您可以根据具体的需求选择适合的算法来执行查找操作。请注意，在使用这些算法之前，确保容器已经按照所需的顺序进行了排序（如果需要）。

## 射线法，判断点在多边形内

+ 思路
  + 该算法的思路很简单，就是从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。
  + 如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。

+ 步骤
  + 已知点point(x,y)和多边形Polygon的点有序集合（x1,y1;x2,y2;….xn,yn;）
  + 以point为起点，以无穷远为终点作平行于X轴的射线line(x,y; -∞,y)；循环取得多边形的每一条边side(xi,yi;xi+1,yi+1)：
    + 判断point(x,y)是否在side上，如果是，则返回true。
    + 判断line与side是否有交点，如果有则count++。
  + 判断交点的总数count，如果为奇数则返回true，偶数则返回false。

## 判断矩形框是否在多边形区域内

要判断一个矩形框是否在多边形区域内，可以使用点与多边形边界的位置关系进行判断。下面是一个简单的示例，展示了如何判断一个矩形框是否在多边形区域内部：

```cpp
#include <iostream>
#include <vector>

struct Point {
    double x;
    double y;

    Point(double x, double y) : x(x), y(y) {}
};

// 判断点是否在多边形内部
bool isInsidePolygon(const Point& point, const std::vector<Point>& polygon) {
    int n = polygon.size();
    bool inside = false;

    for (int i = 0, j = n - 1; i < n; j = i++) {
        if (((polygon[i].y > point.y) != (polygon[j].y > point.y)) &&
            (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
            inside = !inside;
        }
    }

    return inside;
}

// 判断矩形框是否在多边形区域内部
bool isRectangleInsidePolygon(const std::vector<Point>& rectangle, const std::vector<Point>& polygon) {
    for (const Point& point : rectangle) {
        if (!isInsidePolygon(point, polygon)) {
            return false;
        }
    }

    return true;
}

int main() {
    std::vector<Point> polygon = {
        {0.0, 0.0},
        {5.0, 0.0},
        {5.0, 5.0},
        {0.0, 5.0}
    };

    std::vector<Point> rectangle = {
        {1.0, 1.0},
        {4.0, 1.0},
        {4.0, 4.0},
        {1.0, 4.0}
    };

    if (isRectangleInsidePolygon(rectangle, polygon)) {
        std::cout << "矩形框在多边形区域内" << std::endl;
    } else {
        std::cout << "矩形框不在多边形区域内" << std::endl;
    }

    return 0;
}
```

在上述示例中，我们使用了射线法的思想来判断点是否在多边形内部，然后将该方法应用到矩形框的每个顶点。函数 `isInsidePolygon` 判断点是否在多边形内部，函数 `isRectangleInsidePolygon` 判断矩形框的每个顶点是否都在多边形区域内。