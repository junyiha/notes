## C/C++ 常用编程技巧

+ 常用的编程技巧，使用示例与方法

## gprof 性能分析 程序剖析

在Linux环境下，使用gprof进行C++程序的性能分析与使用方法类似于前面提到的通用gprof用法。下面是关于在Linux中使用gprof进行C++程序性能分析的详细解释：

1. 编译时启用性能计数器：与使用gprof分析C程序一样，在编译C++程序时也需要使用特殊的编译选项启用性能计数器。使用g++编译器时，可以添加"-pg"选项。例如：

   ```
   $ g++ -pg -o myprogram myprogram.cpp
   ```

2. 运行程序：编译完成后，运行生成的可执行文件。程序执行过程中会记录性能数据。

   ```
   $ ./myprogram
   ```

3. 生成gmon.out文件：当程序运行完毕后，会生成一个名为"gmon.out"的文件，其中包含了程序的性能数据。

4. 生成性能报告：使用gprof工具来分析性能数据并生成性能报告。使用以下命令生成报告：

   ```
   $ gprof myprogram gmon.out > report.txt
   ```

   这将生成一个名为"report.txt"的文件，其中包含了函数级别的性能报告。

5. 分析性能报告：打开生成的性能报告文件，你将看到与前述相似的内容，包括每个函数的调用次数和占总运行时间的百分比，每个函数内部花费的时间，以及函数调用关系图。

与分析C程序相比，对于C++程序，性能分析结果可能会更加复杂，因为C++中涉及到了对象的构造和析构，以及虚函数的动态调用等特性。因此，在分析C++程序时，除了关注函数级别的性能数据外，还需要注意类和对象的性能开销。

需要注意的是，gprof的性能分析结果是基于采样数据得出的，可能存在一定的误差。为了获得更准确的性能分析结果，建议在优化前后进行多次运行，并对多次运行结果取平均值。

希望以上解释能够帮助你理解如何在Linux中使用gprof进行C++程序的性能分析。如果你还有其他问题，请随时提问。

---

## C++11 自然时间

在C++中，你可以使用标准库提供的时间相关函数和类来处理自然时间。下面是一些常用的C++函数和类，用于处理自然时间：

1. time() 函数：
   `time()` 函数返回当前时间的秒数，自1970年1月1日以来的时间戳。可以使用 `<ctime>` 头文件来访问该函数。

   示例：
   ```cpp
   #include <iostream>
   #include <ctime>

   int main() {
       std::time_t currentTime = std::time(nullptr);
       std::cout << "Current timestamp: " << currentTime << std::endl;
       return 0;
   }
   ```

2. std::tm 结构体：
   `std::tm` 是一个表示时间的结构体，包含了年、月、日、时、分、秒等字段。可以使用 `<ctime>` 头文件来访问该结构体。

   示例：
   ```cpp
   #include <iostream>
   #include <ctime>

   int main() {
       std::time_t currentTime = std::time(nullptr);
       std::tm* localTime = std::localtime(&currentTime);
       std::cout << "Current local time: "
                 << localTime->tm_year + 1900 << "-" << localTime->tm_mon + 1 << "-" << localTime->tm_mday << " "
                 << localTime->tm_hour << ":" << localTime->tm_min << ":" << localTime->tm_sec << std::endl;
       return 0;
   }
   ```

3. std::chrono 命名空间：
   `<chrono>` 头文件提供了一组类和函数，用于处理时间间隔和时钟。它提供了高精度的计时功能和各种时间单位的表示。

   示例：
   ```cpp
   #include <iostream>
   #include <chrono>

   int main() {
       auto currentTime = std::chrono::system_clock::now();
       std::time_t currentTimeStamp = std::chrono::system_clock::to_time_t(currentTime);
       std::cout << "Current timestamp: " << currentTimeStamp << std::endl;

       std::chrono::system_clock::time_point oneHourLater = currentTime + std::chrono::hours(1);
       std::time_t oneHourLaterStamp = std::chrono::system_clock::to_time_t(oneHourLater);
       std::cout << "One hour later: " << std::ctime(&oneHourLaterStamp) << std::endl;

       return 0;
   }
   ```

上述示例演示了使用 `<chrono>` 头文件中的类和函数获取当前时间戳，以及进行时间间隔的计算。

这些是C++中处理自然时间的一些常用工具和类。使用这些函数和类，你可以获取当前时间、进行时间戳的转换，以及计算时间间隔和操作。

---

## C++11 解析main函数从命令行接收的参数

在 C++ 中，你可以通过 `main` 函数的参数来解析命令行输入。`main` 函数接受两个参数，一个是 `argc`，表示命令行参数的数量，另一个是 `argv`，是一个指向指针数组的指针，其中每个指针指向一个命令行参数的字符串。

下面是一个示例代码，展示如何解析 `main` 输入参数：

```cpp
#include <iostream>

int main(int argc, char* argv[]) {
    // 输出命令行参数数量
    std::cout << "argc: " << argc << std::endl;

    // 输出每个命令行参数
    for (int i = 0; i < argc; ++i) {
        std::cout << "argv[" << i << "]: " << argv[i] << std::endl;
    }

    return 0;
}
```

在上述示例中，我们通过遍历 `argv` 数组来访问每个命令行参数，并使用 `argc` 获取参数数量。你可以根据需要进一步处理命令行参数，例如解析选项、获取参数值等。

下面是一个示例，展示如何解析命令行选项和参数值：

```cpp
#include <iostream>

int main(int argc, char* argv[]) {
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];

        if (arg == "-h" || arg == "--help") {
            std::cout << "Help message" << std::endl;
        } else if (arg == "-v" || arg == "--version") {
            std::cout << "Version 1.0" << std::endl;
        } else if (arg == "-f" || arg == "--file") {
            // 检查下一个参数是否存在
            if (i + 1 < argc) {
                std::string filename = argv[i + 1];
                std::cout << "File: " << filename << std::endl;
                ++i;  // 跳过下一个参数
            } else {
                std::cerr << "Missing filename argument" << std::endl;
            }
        } else {
            std::cerr << "Unknown option: " << arg << std::endl;
        }
    }

    return 0;
}
```

在上述示例中，我们检查每个命令行参数，根据不同的选项执行相应的操作。例如，如果参数是 `-h` 或 `--help`，我们输出帮助信息；如果参数是 `-f` 或 `--file`，我们检查下一个参数是否存在，并输出文件名。

你可以根据实际需求扩展这个示例，并根据需要处理更多的命令行选项和参数值。

---

## C++11 "2023-6-21 10:15:2"日期字符串 取出年月日

要从日期字符串 "2023-6-21 10:15:2" 中提取年、月、日，可以使用C++中的字符串处理函数和算法，以及字符串流。以下是一个示例代码：

```cpp
#include <iostream>
#include <string>
#include <sstream>

int main() {
    std::string str = "2023-6-21 10:15:2";
    std::istringstream iss(str);
    std::string year, month, day;

    // 提取年月日
    std::getline(iss, year, '-');
    std::getline(iss, month, '-');
    std::getline(iss, day, ' ');

    std::cout << "提取的年月日为：" << year << "-" << month << "-" << day << std::endl;

    return 0;
}
```

在上面的代码中，我们使用std::istringstream将日期字符串转化为字符串流，然后使用std::getline函数和'-'和' '作为分隔符，逐行读取字符串流中的内容，分别存储到year、month和day字符串中。最后，我们输出提取到的年月日。

运行代码后，输出结果将是：2023-6-21

请注意，以上代码只是简单示例，假设日期字符串的格式固定且正确。如果实际情况与示例不符，你可能需要根据具体需求进行适当的调整和处理。另外，对于日期和时间的处理，你也可以考虑使用C++标准库中的日期时间库，如`<chrono>`和`<ctime>`，以便进行更为灵活和全面的日期时间操作。

---

## C++11 从路径中提取文件名和路径

在 C++11 中，可以使用一些字符串操作函数和库来从路径中提取文件名和路径。下面是一个示例代码，展示如何在 C++11 中从路径中提取文件名和路径：

```cpp
#include <iostream>
#include <string>

// 从路径中提取文件名
std::string extractFilename(const std::string& path) {
    size_t lastSlash = path.find_last_of('/');
    if (lastSlash != std::string::npos) {
        return path.substr(lastSlash + 1);
    }
    return path;
}

// 从路径中提取路径部分
std::string extractPath(const std::string& path) {
    size_t lastSlash = path.find_last_of('/');
    if (lastSlash != std::string::npos) {
        return path.substr(0, lastSlash);
    }
    return "";
}

int main() {
    std::string filePath = "/home/user/Documents/example.txt";

    // 提取文件名
    std::string filename = extractFilename(filePath);
    std::cout << "文件名: " << filename << std::endl;

    // 提取路径
    std::string path = extractPath(filePath);
    std::cout << "路径: " << path << std::endl;

    return 0;
}
```

在上述代码中，我们定义了两个函数 `extractFilename()` 和 `extractPath()`，分别用于提取文件名和路径。这些函数使用了 `std::string` 类型的操作函数，如 `find_last_of()` 和 `substr()`，来进行字符串处理。

运行上述代码将输出以下结果：

```
文件名: example.txt
路径: /home/user/Documents
```

请注意，这只是一种在 C++11 中从路径中提取文件名和路径的方法之一。这种方法依赖于字符串操作，可能不如 C++17 中的 `<filesystem>` 头文件提供的功能丰富和方便。如果你的项目可以使用 C++17 或更高版本的标准，那么推荐使用 `<filesystem>` 头文件来处理文件路径。

---

## C++17 从路径中提取文件名和路径

在 C++ 中，你可以使用标准库中的`<filesystem>`头文件来提取文件名和路径。`<filesystem>`是在 C++17 中引入的，并提供了一组函数和类来操作文件系统路径。

下面是一个示例代码，展示如何从路径中提取文件名和路径：

```cpp
#include <iostream>
#include <filesystem>

namespace fs = std::filesystem;

int main() {
    fs::path filePath = "/home/user/Documents/example.txt";

    // 提取文件名
    std::string filename = filePath.filename().string();
    std::cout << "文件名: " << filename << std::endl;

    // 提取路径
    std::string path = filePath.parent_path().string();
    std::cout << "路径: " << path << std::endl;

    return 0;
}
```

在上述代码中，我们首先定义了一个路径 `filePath`，然后使用 `filename()` 函数来提取文件名，`parent_path()` 函数来提取路径。最后，我们将文件名和路径打印输出。

运行上述代码将输出以下结果：

```
文件名: example.txt
路径: /home/user/Documents
```

这样，你就可以从路径中提取文件名和路径，以便进一步在 C++ 程序中使用。请确保在编译时启用了对 C++17 标准的支持，以便使用 `<filesystem>` 头文件。

---

## 通过进程号 杀死指定进程

在Linux中，可以使用C++编写程序来杀死指定的进程。以下是一个简单的示例：

```cpp
#include <unistd.h>
#include <signal.h>
#include <iostream>

int main() {
    pid_t pid = 12345;  // 要杀死的进程的PID

    // 发送SIGKILL信号来终止指定的进程
    if (kill(pid, SIGKILL) == 0) {
        std::cout << "进程已成功终止" << std::endl;
    } else {
        std::cerr << "无法终止进程" << std::endl;
    }

    return 0;
}
```

在示例中，`pid` 变量存储了要杀死的进程的PID，可以根据需要修改为实际的PID。然后，使用 `kill()` 函数向指定的进程发送 `SIGKILL` 信号来终止进程。如果 `kill()` 函数返回值为0，表示成功终止进程；如果返回值为-1，表示无法终止进程。

请注意，杀死进程需要足够的权限。如果您的程序没有足够的权限，可能会导致无法终止指定的进程。

---

## 通过进程名 查找进程id

+ 使用popen函数和pgrep命令来执行进程名的查找，并读取输出获取进程ID

```cpp
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <string>
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>

pid_t findProcessIdByName(const char* processName) {
    char command[256];
    sprintf(command, "pgrep -f %s", processName);
    FILE* fp = popen(command, "r");
    if (fp != nullptr) {
        char buffer[16];
        if (fgets(buffer, sizeof(buffer), fp)) {
            pclose(fp);
            return atoi(buffer);
        }
        pclose(fp);
    }
    return -1;
}

int main () 
{
    std::string program_name {"vca.exe"};

    pid_t p; 
    p = findProcessIdByName(program_name.c_str());
    std::cerr << "Program : " << program_name << ", pid: " << p << std::endl;

    return 0;
}
```

---

## 生成随机序列 字母 数字 混合

要生成指定大小的随机数字和字符混合序列，可以结合随机数生成器、字符操作和条件判断来实现。

以下是一个生成指定大小的随机数字和字符混合序列的示例代码：

```cpp
#include <iostream>
#include <vector>
#include <random>

std::string generateRandomMixedString(int size) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<int> dist(0, 2);

    std::string randomString;
    randomString.reserve(size);

    for (int i = 0; i < size; ++i) {
        int choice = dist(gen);
        if (choice == 0) {
            // 生成数字字符
            std::uniform_int_distribution<int> numDist('0', '9');
            randomString.push_back(static_cast<char>(numDist(gen)));
        } else if (choice == 1) {
            // 生成大写字母字符
            std::uniform_int_distribution<int> upperDist('A', 'Z');
            randomString.push_back(static_cast<char>(upperDist(gen)));
        } else {
            // 生成小写字母字符
            std::uniform_int_distribution<int> lowerDist('a', 'z');
            randomString.push_back(static_cast<char>(lowerDist(gen)));
        }
    }

    return randomString;
}

int main() {
    int size = 10;

    std::string randomString = generateRandomMixedString(size);

    // 打印生成的随机数字和字符混合序列
    std::cout << randomString << std::endl;

    return 0;
}
```

在上述代码中，`generateRandomMixedString()`函数使用`std::random_device`来获取真正的随机数种子，然后使用`std::mt19937`作为随机数引擎，并使用`std::uniform_int_distribution`定义一个均匀分布的整数分布，范围为0到2。通过这个分布生成一个随机数，根据不同的随机数选择生成数字字符、大写字母字符或小写字母字符，并将其追加到`std::string`中。最后，返回生成的随机数字和字符混合序列。

在`main()`函数中，指定了字符序列的大小，并调用`generateRandomMixedString()`函数来生成随机数字和字符混合序列。然后，通过打印输出生成的随机数字和字符混合序列。

## std::queue 清空队列

要清空C++中的`std::queue`队列，可以使用以下方法：

1. 使用`std::queue`的`swap()`函数：
   ```cpp
   std::queue<T> emptyQueue;
   std::swap(queue, emptyQueue);
   ```

   这种方法创建一个空的临时队列`emptyQueue`，然后通过调用`std::swap()`函数将原始队列`queue`与空队列交换。由于交换后，临时队列会被销毁，因此原始队列也会变为空。

2. 循环弹出元素直到队列为空：
   ```cpp
   while (!queue.empty()) {
       queue.pop();
   }
   ```

   这种方法使用一个循环来连续地从队列中弹出元素，直到队列为空为止。通过循环弹出操作，可以逐个清空队列中的元素。

这两种方法都可以有效地清空`std::queue`队列中的所有元素。根据具体情况选择合适的方法来清空队列。

需要注意的是，无论使用哪种方法，清空队列后，队列的大小将变为0，但是队列的容量（底层数据结构的大小）可能不会改变。如果需要释放底层数据结构所占用的内存，可以考虑重新创建一个新的队列对象。

## 回调函数 编程技巧 示例

以下是使用C++回调函数的一些示例：

示例 1: 使用函数指针作为回调函数

```cpp
#include <iostream>

// 定义回调函数类型
typedef void (*CallbackFunc)(int);

// 接受回调函数作为参数的函数
void performOperation(int data, CallbackFunc callback) {
    // 执行某些操作
    // ...
    
    // 调用回调函数
    callback(data);
}

// 回调函数
void callbackFunction(int data) {
    std::cout << "Callback executed with data: " << data << std::endl;
}

int main() {
    int data = 42;
    
    // 调用函数并传递回调函数
    performOperation(data, callbackFunction);
    
    return 0;
}
```

示例 2: 使用Lambda表达式作为回调函数

```cpp
#include <iostream>

// 接受回调函数作为参数的函数
void performOperation(int data, const std::function<void(int)>& callback) {
    // 执行某些操作
    // ...
    
    // 调用回调函数
    callback(data);
}

int main() {
    int data = 42;
    
    // 使用Lambda表达式定义回调函数
    auto callback = [](int data) {
        std::cout << "Callback executed with data: " << data << std::endl;
    };
    
    // 调用函数并传递Lambda表达式作为回调函数
    performOperation(data, callback);
    
    return 0;
}
```

示例 3: 使用函数对象作为回调函数

```cpp
#include <iostream>

// 定义回调函数的函数对象
class CallbackFunctor {
public:
    void operator()(int data) {
        std::cout << "Callback executed with data: " << data << std::endl;
    }
};

// 接受回调函数作为参数的函数
void performOperation(int data, const CallbackFunctor& callback) {
    // 执行某些操作
    // ...
    
    // 调用回调函数
    callback(data);
}

int main() {
    int data = 42;
    
    // 创建回调函数对象
    CallbackFunctor callback;
    
    // 调用函数并传递回调函数对象
    performOperation(data, callback);
    
    return 0;
}
```

这些示例展示了不同的回调函数用法，包括使用函数指针、Lambda表达式和函数对象作为回调函数。根据您的需求和编程风格，选择适当的方法来实现回调函数，并根据具体的应用场景来定义和使用回调函数。

## 回调函数 编程技巧 建议

当涉及到使用回调函数的编程技巧时，以下是一些实用的建议和技巧：

1. 使用函数指针或函数对象：C++中回调函数可以通过函数指针或函数对象进行实现。函数指针是一种直接的方法，它允许您将函数的地址传递给其他函数作为回调。而函数对象（可调用对象）是一个类对象，它可以像函数一样被调用，并作为回调函数传递。选择函数指针或函数对象取决于您的需求和编程风格。

2. 使用函数模板：使用函数模板可以使回调函数更加通用和灵活。通过模板参数，可以将不同类型的回调函数传递给函数模板，从而实现更广泛的适用性。这样可以减少代码的重复性，提高代码的可复用性。

3. 使用Lambda表达式：Lambda表达式是C++11引入的一种匿名函数形式，它可以用作回调函数。Lambda表达式允许您在需要时定义并传递函数逻辑，而不需要单独定义函数或函数对象。它提供了一种更紧凑和方便的方式来编写回调函数，尤其是对于简单的逻辑或临时需求。

4. 传递上下文信息：在回调函数中，有时候可能需要访问一些外部的上下文信息或数据。为了确保回调函数能够访问这些信息，可以通过函数参数或捕获列表将其传递给回调函数。这样，回调函数就可以访问和操作相关的上下文数据。

5. 使用函数对象状态：函数对象作为回调函数时，可以存储状态信息，并在多次调用之间保留状态。这种状态可以在回调函数的不同调用之间共享，并且可以用于跟踪和处理状态相关的信息。

6. 错误处理和异常安全性：在使用回调函数时，要注意错误处理和异常安全性。确保在回调函数中适当处理错误和异常，以避免潜在的问题。这可能包括对异常的捕获和处理，以及在出现错误时返回适当的错误码或执行相应的错误处理逻辑。

7. 文档和清晰的接口设计：在使用回调函数的代码中，提供清晰的文档和接口设计是非常重要的。确保文档中清楚地描述回调函数的目的、参数和预期行为。同时，定义清晰的接口和回调函数签名，使得使用回调函数的代码更加易于理解和使用。

这些技巧可以帮助您更好地使用回调函数，在C++中实现灵活和可扩展的编程。根据您的具体需求和编程场景，选择适

当的技巧和方法来使用回调函数，并确保代码的可读性、可维护性和稳定性。

### C++ write 将整数写入文件

+ 可以使用`std::to_string()`函数将整数转换为字符串，然后依次获取字符串的每个字符，存入到`std::vector<char>`容器中
+ 使用`write()`函数，将容器中的数据写入即可

+ 示例
```cpp
#include <string>
#include <unistd.h>

int main()
{
    num = 4;
    std::string num_string {};
    std::vector<char> buf(20);
    num_string = std::to_string(num);
    for (auto &it : num_string)
    {
        buf.push_back(it);
    }
    ret = write(shm_fd, buf.data(), buf.size());
    if (ret != -1)
    {
        std::cerr << "Success to write data to shared memory file" << std::endl;
    }

    return 0;
}
```

### C write 将整数写入文件

在 C 语言中，使用 `write()` 函数可以将整数写入到文件描述符中。`write()` 函数的原型如下：

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);
```

- `fd` 是文件描述符，表示要写入的文件或套接字的标识符。
- `buf` 是指向要写入数据的缓冲区的指针。
- `count` 是要写入的字节数。

要将整数写入文件，需要将整数转换为字符串形式，然后将字符串写入文件。可以使用 `sprintf()` 函数将整数转换为字符串，然后将字符串传递给 `write()` 函数进行写入。下面是一个示例：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    int number = 12345;
    char buffer[20];
    int bytes_written;

    sprintf(buffer, "%d", number);
    bytes_written = write(STDOUT_FILENO, buffer, strlen(buffer));

    if (bytes_written == -1) {
        perror("Error writing to file");
        return 1;
    }

    return 0;
}
```

上述示例中，将整数 `number` 转换为字符串形式，并将字符串写入标准输出。`STDOUT_FILENO` 表示标准输出的文件描述符。请注意，在实际使用中，你需要将文件描述符替换为要写入的文件或套接字的有效文件描述符。

### 文件读取到内存，写入到新文件

在 C++11 中，可以使用 `std::ifstream` 类来读取文件内容，并使用 `std::ofstream` 类来写入文件内容。下面是一个示例代码，演示如何将文件读取到内存中，然后保存为新文件：

```cpp
#include <iostream>
#include <fstream>
#include <vector>

// 读取文件内容到内存
std::vector<char> ReadFileToMemory(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    
    if (!file) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return {};
    }
    
    // 获取文件大小
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    
    // 分配内存缓冲区
    std::vector<char> buffer(fileSize);
    
    // 读取文件内容到缓冲区
    if (!file.read(buffer.data(), fileSize)) {
        std::cerr << "Failed to read file: " << filename << std::endl;
        return {};
    }
    
    return buffer;
}

// 将内存内容保存为新文件
bool SaveMemoryToFile(const std::vector<char>& data, const std::string& filename) {
    std::ofstream file(filename, std::ios::binary);
    
    if (!file) {
        std::cerr << "Failed to open file for writing: " << filename << std::endl;
        return false;
    }
    
    // 将内存内容写入文件
    if (!file.write(data.data(), data.size())) {
        std::cerr << "Failed to write file: " << filename << std::endl;
        return false;
    }
    
    return true;
}

int main() {
    std::string inputFile = "input.txt";
    std::string outputFile = "output.txt";
    
    // 读取文件到内存
    std::vector<char> fileData = ReadFileToMemory(inputFile);
    
    if (fileData.empty()) {
        std::cerr << "Failed to read file: " << inputFile << std::endl;
        return 1;
    }
    
    // 将内存内容保存为新文件
    if (!SaveMemoryToFile(fileData, outputFile)) {
        std::cerr << "Failed to save file: " << outputFile << std::endl;
        return 1;
    }
    
    std::cout << "File saved successfully: " << outputFile << std::endl;
    
    return 0;
}
```

在上述代码中，`ReadFileToMemory` 函数接收一个文件名作为参数，并返回一个 `std::vector<char>`，其中包含了文件的内容。函数使用 `std::ifstream` 打开文件，并根据文件大小分配一个足够大的缓冲区。然后，它将文件内容读取到缓冲区中，并返回缓冲区。

`SaveMemoryToFile` 函数接收一个 `std::vector<char>` 和一个文件名作为参数，并将内存中的数据写入到指定文件中。函数使用 `std::ofstream` 打开文件，并将内存中的数据写入文件。

在 `main` 函数中，首先指定要读取的输入文件名和要保存的输出文件名。然后，调用 `ReadFileToMemory` 函数将

文件读取到内存中，并检查是否成功。最后，调用 `SaveMemoryToFile` 函数将内存中的数据保存为新文件，并检查是否成功。

请根据实际需求修改文件名和路径，并确保有读取和写入文件的权限。

### 递归创建目录

在C++中，可以使用递归函数来判断路径是否存在并创建目录。以下是一个示例代码，演示了如何递归判断路径并创建目录：

```cpp
#include <iostream>
#include <sys/stat.h>

bool createDirectory(const std::string& path) {
    // 检查路径是否存在
    struct stat info;
    if (stat(path.c_str(), &info) != 0) {
        // 路径不存在，创建目录
        if (mkdir(path.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0) {
            std::cout << "Created directory: " << path << std::endl;
            return true;
        } else {
            std::cerr << "Failed to create directory: " << path << std::endl;
            return false;
        }
    } else if (info.st_mode & S_IFDIR) {
        // 路径已存在且为目录
        std::cout << "Directory already exists: " << path << std::endl;
        return true;
    } else {
        // 路径已存在但不是目录
        std::cerr << "Path already exists but not a directory: " << path << std::endl;
        return false;
    }
}

bool createDirectoriesRecursive(const std::string& path) {
    size_t pos = 0;
    std::string subPath;
    
    while ((pos = path.find_first_of("/\\", pos + 1)) != std::string::npos) {
        subPath = path.substr(0, pos);
        if (!createDirectory(subPath)) {
            return false;
        }
    }
    
    return createDirectory(path);
}

int main() {
    std::string path = "/path/to/my/directory";
    if (createDirectoriesRecursive(path)) {
        std::cout << "All directories created successfully!" << std::endl;
    } else {
        std::cerr << "Failed to create directories." << std::endl;
    }
    
    return 0;
}
```

上述代码中的`createDirectory`函数用于判断单个路径是否存在并创建目录。`createDirectoriesRecursive`函数使用递归方式，逐级判断并创建目录，如果某一级目录已存在，则跳过创建。在`main`函数中，我们可以调用`createDirectoriesRecursive`函数来创建目录。

请注意，代码中使用了`sys/stat.h`头文件和相关的系统调用来判断路径是否存在和创建目录。此外，还使用了一些文件权限标志（`S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH`），以确保创建的目录具有适当的权限。

### 异常捕获

在C++中，您可以使用多个`catch`块来捕获不同类型的异常，并采取相应的处理措施。每个`catch`块可以捕获一个特定类型的异常，并执行相应的代码块。

下面是一个示例，展示了如何在C++中使用多个`catch`块：

```cpp
try {
    // 可能引发异常的代码
    // ...
}
catch (ExceptionType1& ex) {
    // 处理 ExceptionType1 类型的异常
    // ...
}
catch (ExceptionType2& ex) {
    // 处理 ExceptionType2 类型的异常
    // ...
}
catch (...) {
    // 处理其他类型的异常
    // ...
}
```

在上述示例中，`try`块中的代码可能会引发异常。如果发生异常，程序会尝试与每个`catch`块中的异常类型进行匹配。如果匹配成功，则会执行对应的`catch`块中的代码。如果没有找到匹配的`catch`块，则异常会继续传播到上一级的`try`块或最终导致程序终止。

请注意以下几点：
  1. `catch`块中的异常类型应该与实际可能引发的异常类型匹配。可以使用具体的异常类类型（如`ExceptionType1`、`ExceptionType2`）或其基类来捕获相关异常。
  2. `catch (...)`是一个特殊的`catch`块，用于捕获所有类型的异常。它可以用作最后一个`catch`块，以处理未被前面的`catch`块捕获的异常。但是，请谨慎使用它，因为它会捕获所有异常，包括标准库和其他代码中可能引发的异常，这可能会导致不可预测的行为。
  3. 捕获异常时，可以访问异常对象并执行适当的处理操作，如打印错误消息、记录日志、回滚操作等。
  4. 可以根据需要嵌套使用`try-catch`块，以处理更复杂的异常情况。
需要注意的是，异常处理应该根据实际需求进行适当的设计，并遵循良好的异常处理原则，以确保程序的可靠性和稳定性。

### std::function 与 函数指针 互换

在某些情况下，我们可能需要将 `std::function` 对象转换为函数指针，或者将函数指针转换为 `std::function` 对象。虽然直接的互相转换是不可行的，但可以通过一些技巧来实现类似的效果。

将 `std::function` 转换为函数指针可以使用 `std::function` 的 `target` 成员函数和函数指针类型的静态转换来实现。下面是一个示例：

```cpp
#include <iostream>
#include <functional>

void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    std::function<void(int)> func = foo;  // 将函数指针赋值给 std::function 对象
    void (*funcPtr)(int) = static_cast<void (*)(int)>(func.target<void(*)(int)>());

    if (funcPtr != nullptr) {
        funcPtr(42);  // 调用函数指针，等同于调用 foo 函数
    }

    return 0;
}
```

在上面的示例中，我们首先将函数 `foo` 赋值给 `std::function<void(int)>` 对象 `func`。然后，我们使用 `func.target<void(*)(int)>()` 来获取函数指针类型的目标对象，并使用静态转换将其赋值给函数指针变量 `funcPtr`。通过调用 `funcPtr(42)`，我们实际上调用了函数 `foo`。

将函数指针转换为 `std::function` 对象可以使用 `std::function` 的构造函数来实现。下面是一个示例：

```cpp
#include <iostream>
#include <functional>

void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    void (*funcPtr)(int) = foo;  // 函数指针
    std::function<void(int)> func(funcPtr);  // 将函数指针转换为 std::function 对象

    func(42);  // 调用 std::function 对象，等同于调用 foo 函数

    return 0;
}
```

在上面的示例中，我们首先定义了一个函数指针 `funcPtr` 并将其初始化为函数 `foo`。然后，我们使用 `std::function<void(int)>` 的构造函数将函数指针转换为 `std::function` 对象 `func`。通过调用 `func(42)`，我们实际上调用了函数 `foo`。

需要注意的是，函数指针和 `std::function` 对象之间的转换可能会丢失某些功能或引入性能开销，因为它们在实现和语义上是不同的。因此，在进行这种转换时，需要仔细考虑相关的设计和性能问题。

### 链接静态库顺序问题

+ 默认情况下要求被依赖的库放在依赖它的库后面，当一个程序或共享库依赖的静态库较多时，可能会陷入解决链接问题的坑中
+ 如果对静态库不熟悉，需要结构nm等工具来解决顺序问题。
+ 但也可以偷懒，不关心静态库的顺序问题，ld为此提供了start-group和end-group两个选项，让包含在这两者间的静态库顺序可以随意。

+ 以CMake为例，假设程序x依赖三个静态库：libX1.a、libX2.a和libX3.a，而libX2.a又依赖libX1.a，libX3.a依赖libX2.a和libX1.a，正常情况下的CMakeLists.txt格式如下：
  ```
    add_executable(

        x

        x.cpp

    )

    target_link_libraries(

        x

        libX1.a

        libX2.a

        libX3.a

    )
  ```

+ 上面的写法libX1.a、libX2.a和libX3.a的顺序不能变，只能按上面的先后顺序。如果去掉顺序的烦恼和痛苦，可以采用如下的写法：
  ```
    target_link_libraries(

        x

        -Wl,--start-group

        libX1.a

        libX3.a

        libX2.a

        -Wl,--end-group

    )

    或

    target_link_libraries(

        x

        -Wl,--start-group

        libX3.a

        libX2.a

        libX1.a

        -Wl,--end-group

    )
  ``` 

+ 前面说了start-group和end-group是ld的选项，是链接选项，不是gcc/g++的编译选项，直接命令行或其它编译方式也可以使用，比如命令行方式：
  + `g++ -g -o x x.cpp -Wl,--start-group libX2.a libX1.a libX3.a -Wl,--end-group`

### `-Wl`的使用

+ -Wl表示后面的参数传递给链接器，其中l是linker的意思。
+ 链接时指定共享库的搜索路径（类似于设置LD_LIBRARY_PATH）：`-Wl,-rpath=/usr/local/abc:/data/abc`
+ 以上也可以分开写：`-Wl,-rpath=/usr/local/abc -Wl,-rpath=/data/abc`

+ 部分库链接它的静态库，部分库链接它的共享库：`-Wl,-static -lb -Wl,-call_shared -la -lz`
+ 指定链接器：`-Wl,-dynamic-linker /lib/ld-linux.so.2 -e _so_start`
+ 指定导出的符号：`-Wl,--export-dynamic,--version-script,exports.lds`
+ 指定共享库的soname：`-Wl,--export-dynamic,--version-script,exports.lds,-soname=libqhttpd.so`

+ -rpath 增加共享库搜索路径
+ --retain-symbols-file表示不丢弃未定义的符号和需要重定位的符号
+ --export-dynamic 创建一个动态连接的可执行程序时, 把所有的符号加到动态符号表中

+ 用“-Wl,-Bstatic”指定链接静态库，使用“-Wl,-Bdynamic”指定链接共享库，使用示例：
  + `-Wl,-Bstatic -lmysqlclient_r -lssl -lcrypto -Wl,-Bdynamic -lrt -Wl,-Bdynamic -pthread -Wl,-Bstatic -lgtest`

### C/C++ 浮点数比较

+ 首先，声明一个C/C++中非常重要的原则：
  + 除了可以表示为2的幂次以及整数数乘的浮点数可以准确表示外，其余的数的值都是近似值。

+ 一般解决方法：
  + 保留指定精度，强制转成整型，在进行判断
+ 代码
  ```
    double r {0.016392123};
    double m {0.0163922131};

    int r2 = static_cast<int>(r * 1e6);
    int m2 = static_cast<int>(m * 1e6);
  ``` 

### std::vector

+ 初始化
  + `std::vector<int> ids(10,-1);`
+ 参数：
  + 10 , 初始化10个元素
  + -1 , 将默认值设置为-1

### 类型转换

+ 移除const属性
  + `const_cast()`

+ 语言支持的显示强制转换，将int转换为double，将int转换为bool
  + `static_cast()`

+ 用户定义的构造函数或转换函数支持的显示强制转换
  + `static_cast()`

+ 一个类的对象转换为另一个（无关）的类的对象
  + `bit_cast()`

+ 在同一继承层次结构中，一个类的指针转换为另一个类的指针
  + 建议`dynamic_cast()`，或`static_cast()`

+ 在同一继承层次结构中，一个类的引用转换为另一个类的引用
  + 建议`dynamic_cast()`，或`static_cast()`

+ 指向一种类型的指针转换为指向其他不相关类型的指针
  + `reinterpret_cast()`

+ 一种类型的引用转换为其他不相关的类型的引用
  + `reinterpret_cast()`

+ 指向函数的指针转换为指向函数的指针
  + `reinterpret_cast()`

### typeid

### 函数参数设置默认值

+ 示例：
  + `auto connect(const std::string &remote_ip = std::string(), const std::string &port = std::string())->void;`
+ 作用：
  + 为函数`connect()`的两个参数`remote_ip`和`port`设置默认值，默认值是`std::string()`对象的引用，为空

+ 原理
  + 在C++中，可以为函数的参数提供默认值，以便在调用函数时可以省略该参数。
  + 要为函数的参数提供默认值，需要在声明函数时在该参数的类型后面放置一个等于号和默认值

### 将float类型转为string类型

+ 方法一
  ```
    //c++ 将float 类型转换成string 类型:
    #include<sstream>

    std::string Convert(float Num)
    {
        std::ostringstream oss;
        oss<<Num;
        std::string str(oss.str());
        return str;
    }

    int main(){
        float num = 10.11;
        std::string data = Convert(num);
        printf("data:  %s\n", data.c_str());
        return 0;
    }
  ```

+ 方法二：(C++11)
  ```
    //c++ 将float 类型转换成string 类型:
    #include<sstream>

    int main(){
        float num = 10.11;

        std::string data = std::to_string(num);
        printf("data:  %s\n", data.c_str());

        return 0;
    }
  ``` 

### 类中声明并初始化静态变量

+ 在类中，如果想要直接声明并且初始化一个静态成员，则这个静态变量必须是静态常量
  ```
    class DataBase {
      private:
        static const int num = 123;
      DataBase() = default;
      ~DataBase() = default;
    };
  ``` 

### 使用using定义函数指针

+ `using Func_ptr = int (*)(int, string);` : 定义了一个指向返回值为int， 形参有两个，分别是int，string的函数指针

### 日志 -- 获取函数的名字，行号，文件名

+ ANSI C标准中有几个标准预定义宏（也是常用的）：
  + `__LINE__`：在源代码中插入当前源代码行号；
  + `__FILE__`：在源文件中插入当前源文件名；
  + `__DATE__`：在源文件中插入当前的编译日期
  + `__TIME__`：在源文件中插入当前编译时间；
  + `__STDC__`：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
  + `__cplusplus`：当编写C++程序时该标识符被定义。

+ 代码：
  ```
    #define LOG(level, format, ...) /
        do { /
            fprintf(stderr, "[%s|%s@%s,%d] " format "/n", /
                level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); /
        } while (0)
     
    int main()
    {
        LOG(LOG_DEBUG, "a=%d", 10);
        return 0;
    }
  ```
+ 限制是format不能是变量，必须是常量字符串，如果要记录一个变量字符串，不能像printf那样printf(s)了，要LOG("DEBUG", "%s", s)。 

### 函数返回类型写在后面

+ 返回类型写在前面：
  + `return-type identifier ( argument-declarations... )`
  + `int func (int a);`
+ 返回类型写在后面：
  + `auto identifier ( argument-declarations... ) -> return_type`
  + `auto func(int a)->int;`

+ 当使用decltype进行返回类型推导的时候，是无法获取到模板参数的，需要使用declval进行辅助推导
  ```
    //这种方法无法做到
    template <typename T1, typename T2>
    decltype(a + b) compose(T1 a, T2 b);

    //需要使用declval
    template <typename T1, typename T2>
    decltype(std::declval<T1>() + std::declval<T2>()) compose(T1 a, T2 b);
  ``` 
+ 由于使用declval()这种方法太过于繁琐，所以搞出了这东西
  ```
    template <typename T1, typename T2>
    auto compose(T1 a, T2 b) -> decltype(a + b);
  ``` 

### 函数后面加const

+ c++ 函数前面和后面 使用 const 的作用：
  + 前面使用 const  表示返回值为 const 
  + 后面加 const 表示函数不可以修改 class 的成员

+ c++　在函数后加const的意义：
  + 我们定义的类的成员函数中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是"只读"函数，而有一些函数要修改类数据成员的值。
  + 如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，它还能提高程序的可靠性，已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理。
  + const成员函数和const对象 实际上，const成员函数还有另外一项作用，即常量对象相关。对于内置的数据类型，我们可以定义它们的常量，用户自定义的类也一样，可以定义它们的常量对象。

+ 非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）
+ 表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）；
+ 唯一的例外是对于mutable修饰的成员。 加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用

### 防止头文件重复编译

+ C/C++防止头文件被重复引入的3种方法:
  + 使用宏定义避免重复引入
  + 使用`#pragma once`避免重复引入
  + 使用`_Pragma`操作符

+ 使用宏定义避免重复引入:
  ```
    #ifndef _NAME_H
    #define _NAME_H
    //头文件内容
    #endif
  ``` 
  + 其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。
  + 当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

+ 使用`#pragma once`避免重复引入
  + 使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。
  + 我们知道，#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。
  + 和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高
  + 但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好。
  + 目前，几乎所有常见的编译器都支持 #pragma once 指令，甚至于 Visual Studio 2017 新建头文件时就会自带该指令。可以这么说，在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
  + 除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。

+ 使用`_Pragma`操作符
  + C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。
  + 当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：_Pragma(“once”)

+ 无论是 C 语言还是 C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。
+ 3 种避免头文件被重复引入的方法，其中 
  + #pragma once 和 _Pragma(“once”) 可算作一类，其特点是编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；
  + 而 #ifndef 的特点是可移植性高，编译效率差。读者可根据实际情况，挑选最符合实际需要的解决方案。
+ 在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入。比如说：
  ```
    #pragma once
    #ifndef _STUDENT_H
    #define _STUDENT_H
    class Student {
        //......
    };
    #endif
  ``` 

### C/C++中冒号的用法

### struct和class中的成员变量使用冒号

+ 表示机构内位域的定义，即该变量占几个bit空间
  ```
    typedef struct _XXX{
     
      unsigned char a:4;
      
      unsigned char c;
     
    }; XXX
  ``` 

#### C++类的构造函数后加冒号

+ 例如：`Mat::Mat(const Mat &src):Mat();`

+ 单冒号的作用是：表示后面是初始化列表
+ 这样的写法一般有三种使用场景
  + 对父类进行初始化。
    + 目的：在创建子类对象时,能够把参数传给父类,从而先完成对父类的初始化.子类构造函数必须要调用父类的构造函数（无论显式还是隐式）
    + 调用格式：**`子类构造函数 : 父类构造函数`**
  + 对类成员进行初始化
    + 调用格式:`构造函数 : A(初始值),B(初始值),C(初始值)……`
  + 对类的const成员变量进行初始化
    + 由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值
+ 对于2、3中的应用场景，有以下两点说明
  + 构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关
  + 相对于在构造函数中赋值，初始化列表执行效率更高。

#### C++函数后面加一个冒号的含义

+ 冒号后面跟的是赋值，这种写法是C++的特性
  + 例如
    ```
      A(int aa, int bb):a(aa), b(bb){}
    ``` 
  + 相当于
    ```
      A(int aa, int bb)
      {
        a = aa;
        b = bb;
      }
    ``` 

+ C++构造函数后面加冒号，是初始化表达式。有四种情况下应该使用初始化表达式来初始化成员：
  + 初始化 const 成员
  + 初始化引用成员
  + 当调用基类的构造函数，而它拥有一组参数时
  + 当调用成员类的构造函数，而它拥有一组参数时

+ 在程序中定义变量并初始化的机制中，有两种形式：
  + 一个是我们传统的初始化的形式，即**赋值运算符**，例如：`int a = 10;`, `char b = 'r';`
  + 还有一种是括号赋值，例如：`int a(10);`, `char b('r');`
+ 以上定义并初始化的形式是正确的，可以通过编译的。但是括号赋值，只能在变量定义并初始化中，不能用在变量定义后再赋值；冒号初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员时，只要有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员时，函数体还未执行。对于在函数中初始化，是在所有的数据成员被分配内存空间后才进行的。
+ 这样是有好处的，有的数据成员需要在构造函数调入之后，函数体执行之前就进行初始化，例如引用数据成员，常量数据成员和对象数据成员

### C++11 `=default`和`=delete`

#### `=default`

+ C++的类有四类特殊的成员函数，分别是：默认构造函数，析构函数，拷贝函数以及拷贝赋值函数。如果程序没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，编译器就会隐式地为这个类生成一个默认的特殊成员函数
+ 例如：
  ```
    class X {
      private:
        int a;
    };
    X x;  // 可以编译通过，编译器隐式生成默认构造函数
  ``` 
+ 但是如果X 显式的自定义了非默认构造函数，却没有定义默认构造函数，下面的代码会出现编译错误
  ```
    class X {
      public:
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 错误，默认构造函数X::X()不存在
  ``` 
+ 为了解决上面的问题，我们需要自定义默认构造函数，例如：
  ```
    class X {
      public:
        X(){};  // 手动定义默认构造函数
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 正确，默认构造函数X::x()存在
  ``` 
+ 但是手动编写存在两个问题：
  + 程序员工作量变大
  + 没有编译器自动生成的默认特殊构造函数效率高
+ 为了解决上述的两个问题，C++11标准引入了一个新特性：`defaulted`函数

+ defaulted 函数特性仅用于类的特殊成员函数，且该特殊成员函数没有默认参数。
+ 例如：
  ```
    class X {
      public:
        int f() = default;  // 错误， f()非特殊成员函数
        X(int) = default; //错误， 非特殊成员函数
        X(int i = 1) = default; // 错误， 含有默认参数
    };//能够支持default的，都是编译器能够在该情形下明确要做什么（构造函数一般是逐bit拷贝）
  ``` 
+ 既可以在类体内定义(inline)，也可以在类体外(out-of-line)定义
+ 例如：
  ```
    class X {
    public:
        X() = default; // inline
        X(const X&); // 
        X& operator = (const X&);
        ~X() = default; // inline
    }

    X::X(const X&) = default; // out of line
    X& X::operator = (const X&) = default; // out of line
  ``` 

#### `=delete`

+ 为了显示的禁用某个函数，C++11标准引入了一个新特性：deleted函数

+ 使用：
  ```
    class X{            
    public: 
      X(); 
      X(const X&) = delete;  // 声明拷贝构造函数为 deleted 函数
      X& operator = (const X &) = delete; // 声明拷贝赋值操作符为 deleted 函数
    }; 

    class Y{ 
    public: 
        // 禁止使用者在堆上申请对象
      void *operator new(size_t) = delete; 
      void *operator new[](size_t) = delete; 
    }; 
  ``` 
+ 规则：
  + 必须在函数第一次声明的时候将其声明为deleted函数
  + 不同于default，delete没有限制为特殊成员函数才能使用delete

#### boost中的使用

+ 在支持C++11标准下,noncopyable类定义如下：
  ```
    class noncopyable {
        protected:
            noncopyable() = default;
            ~noncopyable() = defalult;

            noncopyable(const noncopyable& );
            noncopyable& operator= (const noncopyable&);
    };
  ``` 