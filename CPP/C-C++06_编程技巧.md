## C/C++ 常用编程技巧

### 日志 -- 获取函数的名字，行号，文件名

+ ANSI C标准中有几个标准预定义宏（也是常用的）：
  + `__LINE__`：在源代码中插入当前源代码行号；
  + `__FILE__`：在源文件中插入当前源文件名；
  + `__DATE__`：在源文件中插入当前的编译日期
  + `__TIME__`：在源文件中插入当前编译时间；
  + `__STDC__`：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
  + `__cplusplus`：当编写C++程序时该标识符被定义。

+ 代码：
  ```
    #define LOG(level, format, ...) /
        do { /
            fprintf(stderr, "[%s|%s@%s,%d] " format "/n", /
                level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); /
        } while (0)
     
    int main()
    {
        LOG(LOG_DEBUG, "a=%d", 10);
        return 0;
    }
  ```
+ 限制是format不能是变量，必须是常量字符串，如果要记录一个变量字符串，不能像printf那样printf(s)了，要LOG("DEBUG", "%s", s)。 

### 函数返回类型写在后面

+ 返回类型写在前面：
  + `return-type identifier ( argument-declarations... )`
  + `int func (int a);`
+ 返回类型写在后面：
  + `auto identifier ( argument-declarations... ) -> return_type`
  + `auto func(int a)->int;`

+ 当使用decltype进行返回类型推导的时候，是无法获取到模板参数的，需要使用declval进行辅助推导
  ```
    //这种方法无法做到
    template <typename T1, typename T2>
    decltype(a + b) compose(T1 a, T2 b);

    //需要使用declval
    template <typename T1, typename T2>
    decltype(std::declval<T1>() + std::declval<T2>()) compose(T1 a, T2 b);
  ``` 
+ 由于使用declval()这种方法太过于繁琐，所以搞出了这东西
  ```
    template <typename T1, typename T2>
    auto compose(T1 a, T2 b) -> decltype(a + b);
  ``` 

### 函数后面加const

+ c++ 函数前面和后面 使用const的作用：
  + 前面使用const 表示返回值为const
  + 后面加const表示函数不可以修改class的成员

+ c++　在函数后加const的意义：
  + 我们定义的类的成员函数中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是"只读"函数，而有一些函数要修改类数据成员的值。
  + 如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，它还能提高程序的可靠性，已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理。
  + const成员函数和const对象 实际上，const成员函数还有另外一项作用，即常量对象相关。对于内置的数据类型，我们可以定义它们的常量，用户自定义的类也一样，可以定义它们的常量对象。

+ 非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）
+ 表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）；
+ 唯一的例外是对于mutable修饰的成员。 加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用

### 防止头文件重复编译

+ C/C++防止头文件被重复引入的3种方法:
  + 使用宏定义避免重复引入
  + 使用`#pragma once`避免重复引入
  + 使用`_Pragma`操作符

+ 使用宏定义避免重复引入:
  ```
    #ifndef _NAME_H
    #define _NAME_H
    //头文件内容
    #endif
  ``` 
  + 其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。
  + 当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

+ 使用`#pragma once`避免重复引入
  + 使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。
  + 我们知道，#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。
  + 和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高
  + 但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好。
  + 目前，几乎所有常见的编译器都支持 #pragma once 指令，甚至于 Visual Studio 2017 新建头文件时就会自带该指令。可以这么说，在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
  + 除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。

+ 使用`_Pragma`操作符
  + C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。
  + 当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：_Pragma(“once”)

+ 无论是 C 语言还是 C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。
+ 3 种避免头文件被重复引入的方法，其中 
  + #pragma once 和 _Pragma(“once”) 可算作一类，其特点是编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；
  + 而 #ifndef 的特点是可移植性高，编译效率差。读者可根据实际情况，挑选最符合实际需要的解决方案。
+ 在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入。比如说：
  ```
    #pragma once
    #ifndef _STUDENT_H
    #define _STUDENT_H
    class Student {
        //......
    };
    #endif
  ``` 

### C++函数后面加一个冒号的含义

+ 冒号后面跟的是赋值，这种写法是C++的特性
  + 例如
    ```
      A(int aa, int bb):a(aa), b(bb){}
    ``` 
  + 相当于
    ```
      A(int aa, int bb)
      {
        a = aa;
        b = bb;
      }
    ``` 

+ C++构造函数后面加冒号，是初始化表达式。有四种情况下应该使用初始化表达式来初始化成员：
  + 初始化 const 成员
  + 初始化引用成员
  + 当调用基类的构造函数，而它拥有一组参数时
  + 当调用成员类的构造函数，而它拥有一组参数时

+ 在程序中定义变量并初始化的机制中，有两种形式：
  + 一个是我们传统的初始化的形式，即赋值运算符，例如：`int a = 10;`, `char b = 'r';`
  + 还有一种是括号赋值，例如：`int a(10);`, `char b('r');`
+ 以上定义并初始化的形式是正确的，可以通过编译的。但是括号赋值，只能在变量定义并初始化中，不能用在变量定义后再赋值；冒号初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员时，只要有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员时，函数体还未执行。对于在函数中初始化，是在所有的数据成员被分配内存空间后才进行的。
+ 这样是有好处的，有的数据成员需要在构造函数调入之后，函数体执行之前就进行初始化，例如引用数据成员，常量数据成员和对象数据成员

### C++11 `=default`和`=delete`

#### `=default`

+ C++的类有四类特殊的成员函数，分别是：默认构造函数，析构函数，拷贝函数以及拷贝赋值函数。如果程序没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，编译器就会隐式地为这个类生成一个默认的特殊成员函数
+ 例如：
  ```
    class X {
      private:
        int a;
    };
    X x;  // 可以编译通过，编译器隐式生成默认构造函数
  ``` 
+ 但是如果X 显式的自定义了非默认构造函数，却没有定义默认构造函数，下面的代码会出现编译错误
  ```
    class X {
      public:
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 错误，默认构造函数X::X()不存在
  ``` 
+ 为了解决上面的问题，我们需要自定义默认构造函数，例如：
  ```
    class X {
      public:
        X(){};  // 手动定义默认构造函数
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 正确，默认构造函数X::x()存在
  ``` 
+ 但是手动编写存在两个问题：
  + 程序员工作量变大
  + 没有编译器自动生成的默认特殊构造函数效率高
+ 为了解决上述的两个问题，C++11标准引入了一个新特性：`defaulted`函数

+ defaulted 函数特性仅用于类的特殊成员函数，且该特殊成员函数没有默认参数。
+ 例如：
  ```
    class X {
      public:
        int f() = default;  // 错误， f()非特殊成员函数
        X(int) = default; //错误， 非特殊成员函数
        X(int i = 1) = default; // 错误， 含有默认参数
    };//能够支持default的，都是编译器能够在该情形下明确要做什么（构造函数一般是逐bit拷贝）
  ``` 
+ 既可以在类体内定义(inline)，也可以在类体外(out-of-line)定义
+ 例如：
  ```
    class X {
    public:
        X() = default; // inline
        X(const X&); // 
        X& operator = (const X&);
        ~X() = default; // inline
    }

    X::X(const X&) = default; // out of line
    X& X::operator = (const X&) = default; // out of line
  ``` 

#### `=delete`

+ 为了显示的禁用某个函数，C++11标准引入了一个新特性：deleted函数

+ 使用：
  ```
    class X{            
    public: 
      X(); 
      X(const X&) = delete;  // 声明拷贝构造函数为 deleted 函数
      X& operator = (const X &) = delete; // 声明拷贝赋值操作符为 deleted 函数
    }; 

    class Y{ 
    public: 
        // 禁止使用者在堆上申请对象
      void *operator new(size_t) = delete; 
      void *operator new[](size_t) = delete; 
    }; 
  ``` 
+ 规则：
  + 必须在函数第一次声明的时候将其声明为deleted函数
  + 不同于default，delete没有限制为特殊成员函数才能使用delete

#### boost中的使用

+ 在支持C++11标准下,noncopyable类定义如下：
  ```
    class noncopyable {
        protected:
            noncopyable() = default;
            ~noncopyable() = defalult;

            noncopyable(const noncopyable& );
            noncopyable& operator= (const noncopyable&);
    };
  ``` 