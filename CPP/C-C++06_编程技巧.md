## C/C++ 常用编程技巧

### 异常捕获

在C++中，您可以使用多个`catch`块来捕获不同类型的异常，并采取相应的处理措施。每个`catch`块可以捕获一个特定类型的异常，并执行相应的代码块。

下面是一个示例，展示了如何在C++中使用多个`catch`块：

```cpp
try {
    // 可能引发异常的代码
    // ...
}
catch (ExceptionType1& ex) {
    // 处理 ExceptionType1 类型的异常
    // ...
}
catch (ExceptionType2& ex) {
    // 处理 ExceptionType2 类型的异常
    // ...
}
catch (...) {
    // 处理其他类型的异常
    // ...
}
```

在上述示例中，`try`块中的代码可能会引发异常。如果发生异常，程序会尝试与每个`catch`块中的异常类型进行匹配。如果匹配成功，则会执行对应的`catch`块中的代码。如果没有找到匹配的`catch`块，则异常会继续传播到上一级的`try`块或最终导致程序终止。

请注意以下几点：
  1. `catch`块中的异常类型应该与实际可能引发的异常类型匹配。可以使用具体的异常类类型（如`ExceptionType1`、`ExceptionType2`）或其基类来捕获相关异常。
  2. `catch (...)`是一个特殊的`catch`块，用于捕获所有类型的异常。它可以用作最后一个`catch`块，以处理未被前面的`catch`块捕获的异常。但是，请谨慎使用它，因为它会捕获所有异常，包括标准库和其他代码中可能引发的异常，这可能会导致不可预测的行为。
  3. 捕获异常时，可以访问异常对象并执行适当的处理操作，如打印错误消息、记录日志、回滚操作等。
  4. 可以根据需要嵌套使用`try-catch`块，以处理更复杂的异常情况。
需要注意的是，异常处理应该根据实际需求进行适当的设计，并遵循良好的异常处理原则，以确保程序的可靠性和稳定性。

### std::function 与 函数指针 互换

在某些情况下，我们可能需要将 `std::function` 对象转换为函数指针，或者将函数指针转换为 `std::function` 对象。虽然直接的互相转换是不可行的，但可以通过一些技巧来实现类似的效果。

将 `std::function` 转换为函数指针可以使用 `std::function` 的 `target` 成员函数和函数指针类型的静态转换来实现。下面是一个示例：

```cpp
#include <iostream>
#include <functional>

void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    std::function<void(int)> func = foo;  // 将函数指针赋值给 std::function 对象
    void (*funcPtr)(int) = static_cast<void (*)(int)>(func.target<void(*)(int)>());

    if (funcPtr != nullptr) {
        funcPtr(42);  // 调用函数指针，等同于调用 foo 函数
    }

    return 0;
}
```

在上面的示例中，我们首先将函数 `foo` 赋值给 `std::function<void(int)>` 对象 `func`。然后，我们使用 `func.target<void(*)(int)>()` 来获取函数指针类型的目标对象，并使用静态转换将其赋值给函数指针变量 `funcPtr`。通过调用 `funcPtr(42)`，我们实际上调用了函数 `foo`。

将函数指针转换为 `std::function` 对象可以使用 `std::function` 的构造函数来实现。下面是一个示例：

```cpp
#include <iostream>
#include <functional>

void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    void (*funcPtr)(int) = foo;  // 函数指针
    std::function<void(int)> func(funcPtr);  // 将函数指针转换为 std::function 对象

    func(42);  // 调用 std::function 对象，等同于调用 foo 函数

    return 0;
}
```

在上面的示例中，我们首先定义了一个函数指针 `funcPtr` 并将其初始化为函数 `foo`。然后，我们使用 `std::function<void(int)>` 的构造函数将函数指针转换为 `std::function` 对象 `func`。通过调用 `func(42)`，我们实际上调用了函数 `foo`。

需要注意的是，函数指针和 `std::function` 对象之间的转换可能会丢失某些功能或引入性能开销，因为它们在实现和语义上是不同的。因此，在进行这种转换时，需要仔细考虑相关的设计和性能问题。

### 链接静态库顺序问题

+ 默认情况下要求被依赖的库放在依赖它的库后面，当一个程序或共享库依赖的静态库较多时，可能会陷入解决链接问题的坑中
+ 如果对静态库不熟悉，需要结构nm等工具来解决顺序问题。
+ 但也可以偷懒，不关心静态库的顺序问题，ld为此提供了start-group和end-group两个选项，让包含在这两者间的静态库顺序可以随意。

+ 以CMake为例，假设程序x依赖三个静态库：libX1.a、libX2.a和libX3.a，而libX2.a又依赖libX1.a，libX3.a依赖libX2.a和libX1.a，正常情况下的CMakeLists.txt格式如下：
  ```
    add_executable(

        x

        x.cpp

    )

    target_link_libraries(

        x

        libX1.a

        libX2.a

        libX3.a

    )
  ```

+ 上面的写法libX1.a、libX2.a和libX3.a的顺序不能变，只能按上面的先后顺序。如果去掉顺序的烦恼和痛苦，可以采用如下的写法：
  ```
    target_link_libraries(

        x

        -Wl,--start-group

        libX1.a

        libX3.a

        libX2.a

        -Wl,--end-group

    )

    或

    target_link_libraries(

        x

        -Wl,--start-group

        libX3.a

        libX2.a

        libX1.a

        -Wl,--end-group

    )
  ``` 

+ 前面说了start-group和end-group是ld的选项，是链接选项，不是gcc/g++的编译选项，直接命令行或其它编译方式也可以使用，比如命令行方式：
  + `g++ -g -o x x.cpp -Wl,--start-group libX2.a libX1.a libX3.a -Wl,--end-group`

### `-Wl`的使用

+ -Wl表示后面的参数传递给链接器，其中l是linker的意思。
+ 链接时指定共享库的搜索路径（类似于设置LD_LIBRARY_PATH）：`-Wl,-rpath=/usr/local/abc:/data/abc`
+ 以上也可以分开写：`-Wl,-rpath=/usr/local/abc -Wl,-rpath=/data/abc`

+ 部分库链接它的静态库，部分库链接它的共享库：`-Wl,-static -lb -Wl,-call_shared -la -lz`
+ 指定链接器：`-Wl,-dynamic-linker /lib/ld-linux.so.2 -e _so_start`
+ 指定导出的符号：`-Wl,--export-dynamic,--version-script,exports.lds`
+ 指定共享库的soname：`-Wl,--export-dynamic,--version-script,exports.lds,-soname=libqhttpd.so`

+ -rpath 增加共享库搜索路径
+ --retain-symbols-file表示不丢弃未定义的符号和需要重定位的符号
+ --export-dynamic 创建一个动态连接的可执行程序时, 把所有的符号加到动态符号表中

+ 用“-Wl,-Bstatic”指定链接静态库，使用“-Wl,-Bdynamic”指定链接共享库，使用示例：
  + `-Wl,-Bstatic -lmysqlclient_r -lssl -lcrypto -Wl,-Bdynamic -lrt -Wl,-Bdynamic -pthread -Wl,-Bstatic -lgtest`

### C/C++ 浮点数比较

+ 首先，声明一个C/C++中非常重要的原则：
  + 除了可以表示为2的幂次以及整数数乘的浮点数可以准确表示外，其余的数的值都是近似值。

+ 一般解决方法：
  + 保留指定精度，强制转成整型，在进行判断
+ 代码
  ```
    double r {0.016392123};
    double m {0.0163922131};

    int r2 = static_cast<int>(r * 1e6);
    int m2 = static_cast<int>(m * 1e6);
  ``` 

### std::vector

+ 初始化
  + `std::vector<int> ids(10,-1);`
+ 参数：
  + 10 , 初始化10个元素
  + -1 , 将默认值设置为-1

### 类型转换

+ 移除const属性
  + `const_cast()`

+ 语言支持的显示强制转换，将int转换为double，将int转换为bool
  + `static_cast()`

+ 用户定义的构造函数或转换函数支持的显示强制转换
  + `static_cast()`

+ 一个类的对象转换为另一个（无关）的类的对象
  + `bit_cast()`

+ 在同一继承层次结构中，一个类的指针转换为另一个类的指针
  + 建议`dynamic_cast()`，或`static_cast()`

+ 在同一继承层次结构中，一个类的引用转换为另一个类的引用
  + 建议`dynamic_cast()`，或`static_cast()`

+ 指向一种类型的指针转换为指向其他不相关类型的指针
  + `reinterpret_cast()`

+ 一种类型的引用转换为其他不相关的类型的引用
  + `reinterpret_cast()`

+ 指向函数的指针转换为指向函数的指针
  + `reinterpret_cast()`

### typeid

### 函数参数设置默认值

+ 示例：
  + `auto connect(const std::string &remote_ip = std::string(), const std::string &port = std::string())->void;`
+ 作用：
  + 为函数`connect()`的两个参数`remote_ip`和`port`设置默认值，默认值是`std::string()`对象的引用，为空

+ 原理
  + 在C++中，可以为函数的参数提供默认值，以便在调用函数时可以省略该参数。
  + 要为函数的参数提供默认值，需要在声明函数时在该参数的类型后面放置一个等于号和默认值

### 将float类型转为string类型

+ 方法一
  ```
    //c++ 将float 类型转换成string 类型:
    #include<sstream>

    std::string Convert(float Num)
    {
        std::ostringstream oss;
        oss<<Num;
        std::string str(oss.str());
        return str;
    }

    int main(){
        float num = 10.11;
        std::string data = Convert(num);
        printf("data:  %s\n", data.c_str());
        return 0;
    }
  ```

+ 方法二：(C++11)
  ```
    //c++ 将float 类型转换成string 类型:
    #include<sstream>

    int main(){
        float num = 10.11;

        std::string data = std::to_string(num);
        printf("data:  %s\n", data.c_str());

        return 0;
    }
  ``` 

### 类中声明并初始化静态变量

+ 在类中，如果想要直接声明并且初始化一个静态成员，则这个静态变量必须是静态常量
  ```
    class DataBase {
      private:
        static const int num = 123;
      DataBase() = default;
      ~DataBase() = default;
    };
  ``` 

### 使用using定义函数指针

+ `using Func_ptr = int (*)(int, string);` : 定义了一个指向返回值为int， 形参有两个，分别是int，string的函数指针

### 日志 -- 获取函数的名字，行号，文件名

+ ANSI C标准中有几个标准预定义宏（也是常用的）：
  + `__LINE__`：在源代码中插入当前源代码行号；
  + `__FILE__`：在源文件中插入当前源文件名；
  + `__DATE__`：在源文件中插入当前的编译日期
  + `__TIME__`：在源文件中插入当前编译时间；
  + `__STDC__`：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
  + `__cplusplus`：当编写C++程序时该标识符被定义。

+ 代码：
  ```
    #define LOG(level, format, ...) /
        do { /
            fprintf(stderr, "[%s|%s@%s,%d] " format "/n", /
                level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); /
        } while (0)
     
    int main()
    {
        LOG(LOG_DEBUG, "a=%d", 10);
        return 0;
    }
  ```
+ 限制是format不能是变量，必须是常量字符串，如果要记录一个变量字符串，不能像printf那样printf(s)了，要LOG("DEBUG", "%s", s)。 

### 函数返回类型写在后面

+ 返回类型写在前面：
  + `return-type identifier ( argument-declarations... )`
  + `int func (int a);`
+ 返回类型写在后面：
  + `auto identifier ( argument-declarations... ) -> return_type`
  + `auto func(int a)->int;`

+ 当使用decltype进行返回类型推导的时候，是无法获取到模板参数的，需要使用declval进行辅助推导
  ```
    //这种方法无法做到
    template <typename T1, typename T2>
    decltype(a + b) compose(T1 a, T2 b);

    //需要使用declval
    template <typename T1, typename T2>
    decltype(std::declval<T1>() + std::declval<T2>()) compose(T1 a, T2 b);
  ``` 
+ 由于使用declval()这种方法太过于繁琐，所以搞出了这东西
  ```
    template <typename T1, typename T2>
    auto compose(T1 a, T2 b) -> decltype(a + b);
  ``` 

### 函数后面加const

+ c++ 函数前面和后面 使用 const 的作用：
  + 前面使用 const  表示返回值为 const 
  + 后面加 const 表示函数不可以修改 class 的成员

+ c++　在函数后加const的意义：
  + 我们定义的类的成员函数中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是"只读"函数，而有一些函数要修改类数据成员的值。
  + 如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，它还能提高程序的可靠性，已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理。
  + const成员函数和const对象 实际上，const成员函数还有另外一项作用，即常量对象相关。对于内置的数据类型，我们可以定义它们的常量，用户自定义的类也一样，可以定义它们的常量对象。

+ 非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）
+ 表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）；
+ 唯一的例外是对于mutable修饰的成员。 加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用

### 防止头文件重复编译

+ C/C++防止头文件被重复引入的3种方法:
  + 使用宏定义避免重复引入
  + 使用`#pragma once`避免重复引入
  + 使用`_Pragma`操作符

+ 使用宏定义避免重复引入:
  ```
    #ifndef _NAME_H
    #define _NAME_H
    //头文件内容
    #endif
  ``` 
  + 其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。
  + 当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

+ 使用`#pragma once`避免重复引入
  + 使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。
  + 我们知道，#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。
  + 和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高
  + 但值得一提的是，并不是每个版本的编译器都能识别 #pragma once 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 #pragma once 指令的兼容性不是很好。
  + 目前，几乎所有常见的编译器都支持 #pragma once 指令，甚至于 Visual Studio 2017 新建头文件时就会自带该指令。可以这么说，在 C/C++ 中，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
  + 除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。

+ 使用`_Pragma`操作符
  + C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。
  + 当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：_Pragma(“once”)

+ 无论是 C 语言还是 C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。
+ 3 种避免头文件被重复引入的方法，其中 
  + #pragma once 和 _Pragma(“once”) 可算作一类，其特点是编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；
  + 而 #ifndef 的特点是可移植性高，编译效率差。读者可根据实际情况，挑选最符合实际需要的解决方案。
+ 在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入。比如说：
  ```
    #pragma once
    #ifndef _STUDENT_H
    #define _STUDENT_H
    class Student {
        //......
    };
    #endif
  ``` 

### C/C++中冒号的用法

### struct和class中的成员变量使用冒号

+ 表示机构内位域的定义，即该变量占几个bit空间
  ```
    typedef struct _XXX{
     
      unsigned char a:4;
      
      unsigned char c;
     
    }; XXX
  ``` 

#### C++类的构造函数后加冒号

+ 例如：`Mat::Mat(const Mat &src):Mat();`

+ 单冒号的作用是：表示后面是初始化列表
+ 这样的写法一般有三种使用场景
  + 对父类进行初始化。
    + 目的：在创建子类对象时,能够把参数传给父类,从而先完成对父类的初始化.子类构造函数必须要调用父类的构造函数（无论显式还是隐式）
    + 调用格式：**`子类构造函数 : 父类构造函数`**
  + 对类成员进行初始化
    + 调用格式:`构造函数 : A(初始值),B(初始值),C(初始值)……`
  + 对类的const成员变量进行初始化
    + 由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值
+ 对于2、3中的应用场景，有以下两点说明
  + 构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关
  + 相对于在构造函数中赋值，初始化列表执行效率更高。

#### C++函数后面加一个冒号的含义

+ 冒号后面跟的是赋值，这种写法是C++的特性
  + 例如
    ```
      A(int aa, int bb):a(aa), b(bb){}
    ``` 
  + 相当于
    ```
      A(int aa, int bb)
      {
        a = aa;
        b = bb;
      }
    ``` 

+ C++构造函数后面加冒号，是初始化表达式。有四种情况下应该使用初始化表达式来初始化成员：
  + 初始化 const 成员
  + 初始化引用成员
  + 当调用基类的构造函数，而它拥有一组参数时
  + 当调用成员类的构造函数，而它拥有一组参数时

+ 在程序中定义变量并初始化的机制中，有两种形式：
  + 一个是我们传统的初始化的形式，即**赋值运算符**，例如：`int a = 10;`, `char b = 'r';`
  + 还有一种是括号赋值，例如：`int a(10);`, `char b('r');`
+ 以上定义并初始化的形式是正确的，可以通过编译的。但是括号赋值，只能在变量定义并初始化中，不能用在变量定义后再赋值；冒号初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员时，只要有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员时，函数体还未执行。对于在函数中初始化，是在所有的数据成员被分配内存空间后才进行的。
+ 这样是有好处的，有的数据成员需要在构造函数调入之后，函数体执行之前就进行初始化，例如引用数据成员，常量数据成员和对象数据成员

### C++11 `=default`和`=delete`

#### `=default`

+ C++的类有四类特殊的成员函数，分别是：默认构造函数，析构函数，拷贝函数以及拷贝赋值函数。如果程序没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，编译器就会隐式地为这个类生成一个默认的特殊成员函数
+ 例如：
  ```
    class X {
      private:
        int a;
    };
    X x;  // 可以编译通过，编译器隐式生成默认构造函数
  ``` 
+ 但是如果X 显式的自定义了非默认构造函数，却没有定义默认构造函数，下面的代码会出现编译错误
  ```
    class X {
      public:
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 错误，默认构造函数X::X()不存在
  ``` 
+ 为了解决上面的问题，我们需要自定义默认构造函数，例如：
  ```
    class X {
      public:
        X(){};  // 手动定义默认构造函数
        X(int i)
        {
          a = i;
        }
      private:
        int a;
    };
    X x;  // 正确，默认构造函数X::x()存在
  ``` 
+ 但是手动编写存在两个问题：
  + 程序员工作量变大
  + 没有编译器自动生成的默认特殊构造函数效率高
+ 为了解决上述的两个问题，C++11标准引入了一个新特性：`defaulted`函数

+ defaulted 函数特性仅用于类的特殊成员函数，且该特殊成员函数没有默认参数。
+ 例如：
  ```
    class X {
      public:
        int f() = default;  // 错误， f()非特殊成员函数
        X(int) = default; //错误， 非特殊成员函数
        X(int i = 1) = default; // 错误， 含有默认参数
    };//能够支持default的，都是编译器能够在该情形下明确要做什么（构造函数一般是逐bit拷贝）
  ``` 
+ 既可以在类体内定义(inline)，也可以在类体外(out-of-line)定义
+ 例如：
  ```
    class X {
    public:
        X() = default; // inline
        X(const X&); // 
        X& operator = (const X&);
        ~X() = default; // inline
    }

    X::X(const X&) = default; // out of line
    X& X::operator = (const X&) = default; // out of line
  ``` 

#### `=delete`

+ 为了显示的禁用某个函数，C++11标准引入了一个新特性：deleted函数

+ 使用：
  ```
    class X{            
    public: 
      X(); 
      X(const X&) = delete;  // 声明拷贝构造函数为 deleted 函数
      X& operator = (const X &) = delete; // 声明拷贝赋值操作符为 deleted 函数
    }; 

    class Y{ 
    public: 
        // 禁止使用者在堆上申请对象
      void *operator new(size_t) = delete; 
      void *operator new[](size_t) = delete; 
    }; 
  ``` 
+ 规则：
  + 必须在函数第一次声明的时候将其声明为deleted函数
  + 不同于default，delete没有限制为特殊成员函数才能使用delete

#### boost中的使用

+ 在支持C++11标准下,noncopyable类定义如下：
  ```
    class noncopyable {
        protected:
            noncopyable() = default;
            ~noncopyable() = defalult;

            noncopyable(const noncopyable& );
            noncopyable& operator= (const noncopyable&);
    };
  ``` 