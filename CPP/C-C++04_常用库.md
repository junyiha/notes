# 概述 --  各组件接口使用笔记

## libxmu-dev

`libxmu-dev` 是针对 Linux 操作系统的一个开发包，用于开发基于 X Window 系统的图形用户界面应用程序。下面我将为你详细解释一下这个开发包的相关内容。

1. **X Window 系统**：X Window 系统，也称为 X11，是一种用于图形界面的基础架构，允许在计算机屏幕上绘制图形和显示图像。它提供了基本的图形绘制、窗口管理、用户输入等功能，是许多图形用户界面环境的基础。

2. **libxmu-dev 包含的内容**：`libxmu-dev` 是一个开发包，提供了与 X Window 系统和 Xlib 相关的头文件和库文件，以便开发者能够创建使用 X Window 系统的图形界面应用程序。这个开发包的内容包括：

   - **头文件（Header Files）**：这些头文件包含了与 Xlib 库函数和数据结构相关的声明，使开发者能够在代码中使用这些函数和结构体。头文件的扩展名通常是 `.h`。

   - **库文件（Library Files）**：库文件包含了编译好的 Xlib 库函数的二进制代码，这些库可以在链接时与应用程序一起使用。库文件的扩展名通常是 `.a`（静态库）或 `.so`（共享库）。

3. **Xlib 库**：Xlib 是 X Window 系统的客户端库，它提供了一组函数和数据结构，用于与 X 服务器进行通信、创建窗口、处理事件、绘制图形等。通过使用 Xlib，开发者可以在应用程序中管理窗口、绘制图形元素、响应用户输入等。

4. **Xmu 库**：Xmu 是 X Window 系统的辅助库，它建立在 Xlib 之上，提供了一些常见的功能，如字符串处理、几何结构操作、资源管理等。`libxmu-dev` 中的文件可能包括 Xmu 库的头文件和库文件，使开发者能够更方便地使用这些功能。

总之，`libxmu-dev` 提供了开发基于 X Window 系统的图形界面应用程序所需的工具和资源，包括 Xlib 和 Xmu 库的头文件和库文件。通过使用这些工具，开发者可以创建具有丰富图形界面的应用程序，处理窗口、事件、图形绘制等任务。

## libmagic 

`libmagic` 是一个开源的库，用于识别文件类型。它能够通过分析文件的内容来判断文件的类型，而不仅仅依赖于文件的扩展名。这个库最初由 Ian F. Darwin 创建，并且后来被维护和扩展，成为一个广泛使用的文件类型检测工具。

以下是关于 `libmagic` 的一些详细解释：

1. 文件类型识别：
   `libmagic` 主要用于识别文件的类型。它可以根据文件的内容（magic bytes）来判断文件的类型，例如文本文件、二进制文件、图像、音频、视频、压缩文件等。

2. magic 文件：
   `libmagic` 使用一个名为 `magic` 的文件来描述文件类型的规则。这个文件包含了一系列的规则和魔术字节（magic bytes）来帮助识别文件类型。这些规则可以被定制和扩展，以适应不同的需求。

3. 魔术字节：
   魔术字节是一个文件中特定位置的字节序列，用于标识文件类型。例如，许多图像文件的开头会有特定的字节序列，用于识别该文件为图像类型。

4. 命令行工具：
   `libmagic` 提供了一个命令行工具 `file`，用于在命令行中直接识别文件类型。您可以在命令行中输入 `file filename` 来获取文件的类型信息。

5. 编程接口：
   `libmagic` 也提供了编程接口，使开发者可以将文件类型检测功能集成到自己的应用程序中。主要有 C、Python、Perl 和 Ruby 等语言的接口。

6. 跨平台支持：
   `libmagic` 是一个跨平台的库，在 Linux、Unix、macOS 和 Windows 等操作系统上都可以使用。

总的来说，`libmagic` 是一个非常有用的文件类型检测工具，能够帮助我们在文件处理和分析时更准确地判断文件类型，从而做出相应的处理。它被广泛用于文件管理、数据恢复、多媒体应用、网络传输等领域。

## linux-vdso.so

+ linux-vdso.so.1 是一个特殊的动态链接库，它在 Linux 系统中起着重要的作用。VDSO 是 Virtual Dynamic Shared Object（虚拟动态共享对象）的缩写，它是 Linux 内核提供的一种特殊的机制，用于在用户空间和内核空间之间进行高效的系统调用。
+ linux-vdso.so.1 库实际上不是一个真正的共享库文件，而是内核在每个进程的地址空间中映射的一个虚拟文件。它通过特殊的技术将一些常见的系统调用实现以内联汇编的方式嵌入到用户空间程序中，避免了频繁的用户态到内核态的切换。
+ 通过使用 VDSO，一些常见的系统调用，例如获取当前时间、获取进程 ID、获取系统调用号等，可以在用户空间直接执行，而无需陷入内核执行。这大大减少了系统调用的开销，提高了程序的性能。
+ linux-vdso.so.1 是一个系统生成的文件，其路径通常为 "/lib/ld-linux.so.2" 或 "/lib/ld-linux-armhf.so.3" 等，具体路径取决于系统架构和配置。
+ 需要注意的是，由于 linux-vdso.so.1 是在内核启动时动态生成的，因此你不会在文件系统中找到实际的库文件。它在运行时通过内核的机制自动映射到每个进程的地址空间中。

## libcrypto.so

+ libcrypto.so 是 OpenSSL 库中的一个动态链接库文件。OpenSSL 是一个开源的加密和安全套接字库，提供了密码学功能和安全通信协议的实现。
+ libcrypto.so 库包含了 OpenSSL 提供的各种加密算法、密码学函数和安全协议的实现。它提供了对对称加密算法（如 AES、DES）、哈希函数（如 SHA、MD5）、公钥加密算法（如 RSA、DSA）、数字签名和证书操作等功能的支持。
+ 通过链接 libcrypto.so，开发人员可以在他们的应用程序中使用 OpenSSL 提供的加密和安全功能。这对于需要进行加密通信、数字签名、证书验证和其他密码学操作的应用程序、网络服务器、安全工具等非常有用。
+ 需要注意的是，libcrypto.so 是 OpenSSL 库的一部分，它是一个开源项目，在多个操作系统和平台上可用。在不同的系统中，libcrypto.so 的具体名称和路径可能会有所不同，但提供的加密和安全功能基本相似。

## ld-linux-armhf.so

+ ld-linux-armhf.so 是 ARM 架构上的动态链接器，用于在 ARM 处理器上运行基于动态链接的可执行文件。它是 Linux 系统中的一部分，用于加载和解析可执行文件以及它们所依赖的动态链接库。
+ 动态链接器（linker）是一个系统组件，负责在运行时将可执行文件和动态链接库组合在一起，解决符号引用，建立程序的运行环境，并开始执行程序。
+ ld-linux-armhf.so 针对 ARM 架构上的硬浮点 ABI（Application Binary Interface）进行了优化。它确保可执行文件和动态链接库在 ARM 架构上以正确的方式加载和运行，并与其他系统组件协同工作。
+ 需要注意的是，ld-linux-armhf.so 的名称可能会因操作系统版本、发行版或具体的 ARM 架构变体而有所不同。不同的 ARM 架构和操作系统可能使用不同的链接器名称和路径。

## libpostproc.so

+ libpostproc.so 是 FFmpeg 多媒体处理库中的一个动态链接库（shared library）文件。FFmpeg 是一个开源的跨平台多媒体框架，用于处理音频、视频和其他多媒体数据。
+ libpostproc.so 库提供了视频后处理的功能，包括图像滤镜、色彩空间转换、图像调整等。它可以用于在视频处理过程中对图像进行修正、增强和优化，提供更好的视觉效果。
+ 通过链接 libpostproc.so，开发人员可以在他们的应用程序中使用 FFmpeg 提供的视频后处理功能。这对于需要进行视频处理和编辑的应用程序、媒体播放器、转码工具等非常有用。
+ 需要注意的是，libpostproc.so 是 FFmpeg 中的一部分，它是一个开源的项目，因此可以在多个平台上使用。在不同的操作系统和平台上，libpostproc.so 的具体名称和路径可能会有所不同，但提供的视频后处理功能基本相似。

## libdrm.so 

+ libdrm.so 是一个常见的动态链接库（shared library）文件，它是 Direct Rendering Manager（DRM）的一部分。DRM 是一个用于在 Linux 系统上管理图形设备的子系统，它提供了与显示服务器、图形驱动程序和用户空间应用程序之间的接口。
+ libdrm.so 库提供了一组函数，用于与 DRM 子系统进行交互和通信。它允许用户空间应用程序通过 DRM 接口与图形设备进行交互，进行诸如显示输出、图形渲染、硬件加速等操作。
+ 通过链接 libdrm.so，开发人员可以编写应用程序来管理图形设备，并利用 DRM 提供的功能，如显示模式设置、缓冲区管理、2D/3D 图形渲染等。
+ 需要注意的是，libdrm.so 是特定于 Linux 系统上的 DRM 子系统的库文件。它是在 DRM 子系统和图形驱动程序之间进行通信的桥梁，提供了对图形设备的访问和控制。在不同的 Linux 发行版和不同的图形硬件上，libdrm.so 的具体实现和用法可能会有所不同。

## libgcc_s.so

+ libgcc_s.so 是一个常见的动态链接库（shared library）文件，它是 GCC（GNU Compiler Collection）的运行时支持库之一。"libgcc_s" 代表 "libgcc support"，该库提供了在使用 GCC 编译的程序中所需的一些运行时支持。
+ libgcc_s.so 库提供了一些与编译器相关的支持函数和运行时环境，用于处理一些特定的语言特性、异常处理、类型转换、整数运算等。它通常用于支持编译器生成的一些代码，以提供必要的运行时支持。
+ 在某些情况下，使用 GCC 编译的程序可能依赖于 libgcc_s.so 库。当运行这些程序时，系统会自动加载和链接 libgcc_s.so，以提供所需的运行时支持。这通常是由于程序使用了一些与编译器相关的功能，或者使用了特定的编译选项。
+ 需要注意的是，libgcc_s.so 是特定于 GCC 的库，因此在使用其他编译器或不同版本的 GCC 上编译的程序可能会使用不同的运行时支持库。在不同的操作系统和平台上，libgcc_s.so 的具体名称和路径可能会有所不同，但其目的和功能基本相似。

## libstdc++.so.6

+ libstdc++.so 是一个常见的动态链接库（shared library）文件，它是 GNU C++ 标准库（GNU C++ Standard Library）的一部分。"libstdc++" 代表 "Standard C++"，该库提供了 C++ 标准库的实现
+ libstdc++.so 库包含了各种与 C++ 相关的函数和类，如容器（vector、list、map）、算法（sort、find、transform）、输入输出（iostream、fstream）、字符串处理（string、stringstream）等
+ 这个库是 C++ 编程中非常重要的一部分，它提供了 C++ 标准库的实现，包括常用的数据结构、算法、输入输出等功能，为 C++ 开发人员提供了丰富的工具和函数，简化了开发过程
+ 通过链接 libstdc++.so，应用程序可以使用这些标准库函数和类，从而实现各种 C++ 编程任务，如数据结构操作、算法实现、文件读写、字符串处理等
+ 需要注意的是，libstdc++.so 是在许多操作系统中的标准 C++ 库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libstdc++.so 的名称和具体实现可能会有所不同，但提供的标准库函数和用法基本上是相似的


## libc.so.6

+ libc.so 是一个常见的动态链接库（shared library）文件，它是 C 语言标准库（C Standard Library）的一部分。"libc" 代表 "C"，该库提供了一系列 C 语言的标准函数和常用工具函数的实现
+ libc.so 库包含了各种常用的函数，例如内存操作函数（如malloc、free、memcpy、memset）、字符串操作函数（如strcpy、strcat、strlen）、文件操作函数（如fopen、fclose、fread、fwrite）、数学函数（如abs、sqrt、sin、cos）等
+ 这个库是 C 语言编程中非常重要的一部分，它提供了许多基础的函数和工具，可以帮助开发人员进行内存管理、字符串处理、文件操作、数学计算等各种常见的任务。通过链接 libc.so，应用程序可以使用这些函数，从而简化了代码的编写和开发过程
+ 需要注意的是，libc.so 是在许多操作系统中的标准 C 库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libc.so 的名称和具体实现可能会有所不同，但提供的标准函数和用法基本上是相似的

## libm.so.6

+ libm.so 是一个常见的动态链接库（shared library）文件，它是数学库（Math Library）的一部分。"libm" 代表 "Math"，该库提供了许多数学函数的实现，供应用程序在运行时使用。
+ libm.so 库通常用于执行各种数学操作，例如三角函数、指数函数、对数函数、幂函数等。它包含了标准的数学函数库，使开发人员能够在程序中进行高级数学计算和操作，无需自己实现这些函数
+ 该库提供的函数包括但不限于：sin、cos、tan、exp、log、pow、sqrt 等。通过链接 libm.so，应用程序可以调用这些函数来执行各种数学运算，从而简化了数学计算的实现过程。
+ 需要注意的是，libm.so 是在许多操作系统中标准的数学库，包括 Linux、Unix 和类 Unix 系统。在不同的操作系统和平台上，libm.so 的名称和具体实现可能会有所不同，但提供的数学函数和用法基本上是相似的

## libdl.so 动态加载共享库

+ libdl.so 是一个动态链接库（shared library）文件，它是 Linux 操作系统中的一部分。"libdl" 代表 "Dynamic Loading"，该库提供了在运行时动态加载其他共享库的功能。在 Linux 系统中，动态链接库可以在程序执行过程中被加载和卸载，这样可以提供更灵活的代码组织和模块化开发的方式
+ libdl.so 库通常由应用程序使用，用于在运行时动态加载其他共享库。它提供了一组函数，例如 `dlopen()`、`dlsym()`、`dlclose()` 等，用于加载、查找和卸载其他库中的符号（函数、变量等）。这些函数可以让程序在运行时根据需要加载所需的库，并调用其中的函数或访问其中的变量。
+ 通过 libdl.so，程序可以实现插件化架构、动态加载模块、实现扩展性等。这对于一些需要在运行时动态加载功能的程序，如插件系统、动态链接器、动态加载器等，非常有用
+ 需要注意的是，libdl.so 是 Linux 系统中的库文件，而在其他操作系统中，类似的功能可能由其他库提供，而命名可能也有所不同

`libdl.so`是Linux系统上的动态链接库，它提供了动态加载和管理共享库的功能。与之对应的头文件是`dlfcn.h`，它包含了在使用`libdl.so`库时需要的函数和宏的声明。

以下是`dlfcn.h`头文件的常见函数和宏：

1. `dlopen`函数：
   ```cpp
   void* dlopen(const char* filename, int flags);
   ```
该函数用于打开一个共享库文件，并返回一个指向库句柄的指针。`filename`参数是共享库文件的路径，`flags`参数指定了打开库的方式，如`RTLD_LAZY`表示在需要时才解析符号，`RTLD_NOW`表示立即解析符号等。

1. `dlsym`函数：
   ```cpp
   void* dlsym(void* handle, const char* symbol);
   ```
该函数用于在打开的库中查找指定的符号，并返回符号对应的地址。`handle`参数是由`dlopen`返回的库句柄，`symbol`参数是要查找的符号的名称。

1. `dlclose`函数：
   ```cpp
   int dlclose(void* handle);
   ```
该函数用于关闭打开的库。`handle`参数是要关闭的库的句柄。

1. `dlerror`函数：
   ```cpp
   char* dlerror();
   ```
该函数返回上一个动态库函数调用的错误信息。如果没有错误发生，则返回`NULL`。

上述函数和宏的声明都可以在`dlfcn.h`头文件中找到。为了使用这些函数和宏，需要在C/C++源文件中包含`dlfcn.h`头文件：
   ```cpp
   #include <dlfcn.h>
   ```

这样，你就可以使用`libdl.so`库提供的动态加载和管理共享库的功能了。请注意，这些函数和宏在不同的操作系统和平台上可能会有所差异，因此在编写跨平台代码时需要注意相关的兼容性问题。

## 错误码

+ `EPERM`	  	` 1`	 Operation not permitted 
+ `ENOENT` 		` 2`	 No such file or directory 
+ `ESRCH`		  ` 3`	 No such process 
+ `EINTR`		  ` 4`	 Interrupted system call 
+ `EIO`		    ` 5`	 I/O error 
+ `ENXIO`		  ` 6`	 No such device or address 
+ `E2BIG`		  ` 7`	 Argument list too long 
+ `ENOEXEC`		` 8`	 Exec format error 
+ `EBADF`		  ` 9`	 Bad file number 
+ `ECHILD`		`10`	 No child processes 
+ `EAGAIN`		`11`	 Try again 
+ `ENOMEM`		`12`	 Out of memory 
+ `EACCES`		`13`	 Permission denied 
+ `EFAULT`		`14`	 Bad address 
+ `ENOTBLK`		`15`	 Block device required 
+ `EBUSY`		  `16`	 Device or resource busy 
+ `EEXIST`		`17`	 File exists 
+ `EXDEV`		  `18`	 Cross-device link 
+ `ENODEV`		`19`	 No such device 
+ `ENOTDIR`		`20`	 Not a directory 
+ `EISDIR`		`21`	 Is a directory 
+ `EINVAL`		`22`	 Invalid argument 
+ `ENFILE`		`23`	 File table overflow 
+ `EMFILE`		`24`	 Too many open files 
+ `ENOTTY`		`25`	 Not a typewriter 
+ `ETXTBSY`		`26`	 Text file busy 
+ `EFBIG`		  `27`	 File too large 
+ `ENOSPC`		`28`	 No space left on device 
+ `ESPIPE`		`29`	 Illegal seek 
+ `EROFS`		  `30`	 Read-only file system 
+ `EMLINK`		`31`	 Too many links 
+ `EPIPE`		  `32`	 Broken pipe 
+ `EDOM`		  `33`	 Math argument out of domain of func 
+ `ERANGE`		`34`	 Math result not representable 

## jsoncpp

### json 概述

+ JSON(`JavaScript Object Notation`, JavaScript 对象表示法) 是一种轻量级的数据交换格式。 
+ JSON是存储和交换文本信息的语法，类似于XML。但它比XML更小，更快，更易解析，易于人阅读和编写。同时也易于机器解析和生成。 
+ 它基于`JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999`的一个子集。 
+ JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括`C, C++, C#, Java, JavaScript, Perl, Python`等）。 
+ 这些特性使JSON成为理想的数据交换语言

+ 要明白，JSON 是一种轻量级的文本数据交换格式而非编程语言，其语法只支持字符串，数值，布尔值及null以及在此基础上的对象和数组，

+ JSON建构于两种结构：
  + “名称/值”对的集合（`A collection of name/value pairs`）,不同的语言中，它被理解为对象（`object`），纪录（`record`），结构（`struct`），字典（`dictionary`），哈希表（`hash table`），有键列表（`keyed list`），或者关联数组 （`associative array`）。
  + 值的有序列表（An ordered list of values）,在大部分语言中，它被理解为数组（`array`）

+ JSON具有以下这些形式：
  + 对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔

#### JSON语法规则

+ 数据在 名称/值对 里面
+ 数据由逗号分隔
+ 大括号保存对象
+ 中括号保存数组

+ JSON名称/值对
  + JSON 数据的书写格式是：名称/值对
  + 名称/值对 包括字段名称（在双引号中），后面写一个冒号，然后是值： `"name":"hello world"`
+ JSON名称（键）必须是字符串
+ JSON值可以是：
  + 数字（整数或浮点数）
  + 字符串（在双引号中）
  + 逻辑值（true 或 false）
  + 数组（在中括号中）
  + 对象（在大括号中）
  + null

+ JSON对象
  + JSON 对象在大括号（{}）中书写
  + 对象可以包含多个名称/值对：   `{"name":"hello world", "url":"www"}`

+ JSON数组
  + JSON 数组在中括号中书写
  + 数组可包含多个对象：`"sites":[{"name":"hello", "url":"www"}, {"name":"world", "url":"www"}]`
    + 对象sites是包含两个对象的数组，每个对象代表一条关于网站(name, url)的记录

+ 访问对象值
  + 可以使用点号来访问对象的值`var myobj,x; myobj = {"name":"json", "alex":1111, "site":"www"}; x = myobj.name;`
  + 可以使用中括号来访问对象的值`var myobj,x; myobj = {"name":"json", "alex":1111, "site":"www"}; x = myobj["name"];`

#### JSON.parse()

+ JSON通常用于与服务端交换数据
+ 在接收服务器数据时，一般是字符串，可以使用JSON.parse()方法将数据交换为JavaScript对象

+ 语法：`JSON.parse(text, reviver);`
+ 参数说明：
  + `text`  -- 一个有效的JSON字符串
  + `reviver` -- 一个转换结果的函数，将为对象的每个成员调用此函数

#### JSON.stringify()

+ JSON 通常用于与服务端交换数据。
+ 在向服务器发送数据时一般是字符串。
+ 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。

+ 语法：`JSON.stringify(value[, replacer[, space]])`
+ 参数说明：
  + `value`  --  要转换的 JavaScript 值（通常为对象或数组）。
  + `replacer` -- 用于转换结果的函数或数组
  + `space`  --  文本添加缩进、空格和换行符

### jsoncpp 详解

+ 开源程序：`libjsoncpp`
+ 地址：`https://github.com/open-source-parsers/jsoncpp`

+ 将仓库克隆到本地，cmake编译完成之后，当做第三方库的方式为：
  + 头文件：jsoncpp/include/json
  + 静态库和动态库文件：build/lib/

### jsoncpp 基本用法

+ jsonCpp主要包含三种类型的`class`：`value`、`reader`、`write`。
+ jsonCpp总所有对象、类名都在namespace json中

+ `Json::Value`
  + Json::Value时jsonCpp中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 `Json::ValueType` 枚举值。
  + 在把value插入值后再输出来，输出的值是按字母表的顺序排列。
    + `Json::Value root;`
    + `root["status"] = 1;			//新建一个key为status，赋予数值1`
    + `root["message"] = "OK";		//新建一个key为message，赋予字符串OK`
    + `root["array"].append("arr"); //新建一个key为array，类型为数组，对第一个元素赋值为字符串“arr”`
    + `root["array"].append(1234);  // 为数组 key_array 赋值，对第二个元素赋值为：1234。`
    + `Json::ValueType type = root.type();	//获得root的类型`

+ `Json::Writer`
  + `Json::Writer`负责将内存中的`Value`对象转换成`JSON`文档，输出到文件或者是字符串中
  + Json::Writer是一个纯虚类，不能直接使用，一般使用`Json::Writer`的子类：`Json::FasterWriter`, `Json::StyledWriter`、`Json::StyledStreamWriter`
  + 注：在新版中`Json::FasterWriter`, `Json::StyledWriter`、`Json::Reader`都被弃用，替代的是`Json::StreamWriterBuilder`、`Json::CharReaderBuilder`
    + `Json::FasterWriter`：速度最快
    + `Json::StyledWriter`：格式化后的json

+ `Json::Reader`
  + 用于读取，准确说是用于将字符串或者文件输入流转换为Json::Value对象的
  + `parse()`
  + 使用`Json::Reader`对`json`文件进行解析
    + 声明：`bool parse(const std::string& document, Value& root, bool collectComments = true);`
    + 参数：
      + `root`:（输出）Json::Value的对象
  + 使用Json::Reader对json输入流（文件）进行解析
    + 声明：`bool parse(std:stream& is, Value& root, bool collectComment = true);`
  + 使用Json::Reader对字符串进行解析
    + 声明：`bool parse(const char* beginDoc, const char* ednDoc, Value& root, bool collectComment = true);`

### JsonCpp其他操作

+ 判断key是否存在
  + 声明：`bool Json::Value::isMember ( const char * key) const；`
  + 存在返回1，否则返回0

+ 判断是否为null成员函数
+ 注：Json::Value和C++中的map有一个共同的特点，就是当你尝试访问一个不存在的 key 时，会自动生成这样一个key-value默认为null的值对。

+ 得到所有成员
  + `typedef std::vectorstd::string Json::Value::Members;`
  + `Value::Members Json::Value::getMemberNames ( ) const;`
  + 该函数的类型为一个string的vector。

+ 删除成员
  + `Value Json::Value::removeMember( const char* key)`
  + 返回删除的值，或者null

---

## sscanf() 正则表达式

+ C++处理字符串的工具函数
  + `strcpy, strcat, strlen, strstr`
  + `sscanf + 正则表达式`

+ 函数声明：`int sscanf(const char *buffer, const char *format, [ argument ]...);`
+ 其中最重要的参数就是`format`，它可以是一个或多个`{%[*][width][{h|I|I64|L}]type|' '|'\t'| '\n'|非%符号}`
+ 常用元字符释义
  + `*`也可以用于格式中, (即 `%*d` 和 `%*s`) 加了星号 (`*`) 表示跳过此数据不读入，也就是不把此数据读入参数中。
  + `{a|b|c}`表示a,b,c中选一，`[d]`表示可以有d也可以没有d
  + width表示读取宽度。
  + `{h | l | I64 | L}`:参数的`size`,通常`h`表示单字节size，`I`表示2字节 size，`L`表示4字节size(double例外)，`l64`表示8字节size。
  + `type`:这一项比较多，就是`%s`、`%d`之类。
  + 特别的：`%*[width] [{h | l | I64 | L}]type` 表示满足该条件的被过滤掉，不会向目标参数中写入值。
  + 未成功匹配返回0 ，否则返回格式化的参数个数。

## 宏定义，宏函数，内置宏，常用宏

+ 在C语言中，变量类型，循环控制，基础语法等与其他高级语言基本无异；
+ 而C语言(C++)特有的两把双刃剑--指针和宏定义/宏函数，使得C/C++在底层开发中披荆斩棘，无所不能

### 常用宏定义

+ 防止一个头文件被重复包含
  + `#ifndef ICE_BASE_HPP`
  + `#define ICE_BASE_HPP`
  + `#endif  //ICE_BASE_HPP`

+ 重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。
  + `typedef  unsigned long int  uint32;      	/* Unsigned 32 bit value */`

### 内置宏

+ ANSI标准
  + `__LINE__`
  + `__FILE__`
  + `__DATE__`
  + `__TIME__`
  + `__TIME__`
  + `__STDC__`

### `__BEGIN_DECLS`

+ 许多头文件中都有：
  + 文件开头有`__BEGIN_DECLS`
  + 文件结尾有`__END_DECLS`

+ 它们是两个宏定义，声明为：
  + `#define __BEGIN_DECLS extern "C"{`
  + `#define __END_DECLS   }`

## sys/epoll.h

### epoll_create()

+ 简述：创建一个关联`size`个文件的epoll实例
+ 声明：`int epoll_create(int size);`
+ 参数：
  + `size`  --  关联文件的个数
+ 返回值：
  + 成功  --  返回一个文件描述符`fd`
  + 失败  --  

### epoll_create1()

+ 简述：创建一个标记为`flag`的epoll实例
+ 声明：`int epoll_create1(int flags);`
+ 参数：
  + `flag`  --  
+ 返回值：
  + 成功  --  返回一个文件描述符
  + 失败  --  
+ 注意：
  + 与epoll_create()一样，只不过size参数弃用了

### epoll_ctl()

+ 简述：修改一个`epfd` epoll实例
+ 声明：`int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `op`    --  要执行的行为
    + `/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */`
    + `#define EPOLL_CTL_ADD 1	/* Add a file descriptor to the interface.  */`
    + `#define EPOLL_CTL_DEL 2	/* Remove a file descriptor from the interface.  */`
    + `#define EPOLL_CTL_MOD 3	/* Change file descriptor epoll_event structure.  */`
  + `fd`    --  操作的目标
  + `event` --  用户数据和触发该调用的事件
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1，并设置errno

### epoll_wait()

+ 简述：在一个epoll实例`opfd`中等待某一事件发生
+ 声明：`int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `events` -- 指向存放触发事件的缓冲区的结构体指针
  + `maxevents`  --  返回事件的最大数量
  + `timeout`  --  超时时间
+ 返回值：
  + 成功  --  返回触发事件在缓冲区`events`中的数字
  + 失败  --  返回-1，并设置errno

### epoll_pwait()

+ 简述：和`epoll_wait()`相似，增加了信号掩码，临时且原子
+ 声明：`int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *ss);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `events` -- 指向存放触发事件的缓冲区的结构体指针
  + `maxevents`  --  返回事件的最大数量
  + `timeout`  --  超时时间
  + `ss`   --  信号集指针
+ 返回值：
  + 成功  --  返回触发事件在缓冲区`events`中的数字
  + 失败  --  返回-1，并设置errno

## sys/socket.h

+ 套接字常量、类型和函数的声明。

### socket()

+ 简述：创建一个`type`类型，`domain`协议簇，`protocol`通信协议的socket，并返回一个文件描述符
+ 声明：`int socket(int domain, int type, int protocol);`
+ 参数：
  + `domain`  --  选择所用的协议族
    + `AF_INET`，代表IPv4
    + `AF_INET6`，代表IPv6
  + `type`    --  
    + `SOCK_STREAM`, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现
    + `SOCK_DGRAM`,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现
  + `protocol` -- 指定特定的通信type使用的协议。
    + 在大多数实现中，每个type参数只能使用一种协议。
    + `SOCK_STREAM`,使用`IPPROTO_TCP`
    + `SOCK_DGRAM`, 使用`IPPROTO_UDP`
    + 如果参数为0，则默认设置为1
+ 返回值：
  + 成功  --  返回文件描述符
  + 失败  --  

### socketpair()

+ 简述：创建两个`type`类型，`domain`协议簇，`protocol`通信协议的，互相连接的socket，将文件描述符放在`fds[0]`和`fds[1]`
+ 声明：`int socketpair(int domain, int type, int protocol, int fds[2]);`
+ 参数：
  + `domain`  --  选择所用的协议族
    + `AF_INET`，代表IPv4
    + `AF_INET6`，代表IPv6
  + `type`    --  
    + `SOCK_STREAM`, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现
    + `SOCK_DGRAM`,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现
  + `protocol` -- 指定特定的通信type使用的协议。
    + 在大多数实现中，每个type参数只能使用一种协议。
    + `SOCK_STREAM`,使用`IPPROTO_TCP`
    + `SOCK_DGRAM`, 使用`IPPROTO_UDP`
    + 如果参数为0，则默认设置为1
  + `fds[2]`  --  存放两个文件描述符的数组  --  Input/Output
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1

### bind()

+ 简述：将套接字通信端点的句柄(`socket FD`)与一个特定的逻辑网络连接关联起来
+ 声明：`int bind(int fd, const struct sockaddr *address, socklen_t address_len);`
+ 参数：
  + `fd`       --  通信端点的文件描述符
  + `address`  --  关联的地址
  + `len`      --  地址字节长度(the local address which is LEN bytes long)
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1，并设置errno

### getsockname()

+ 简述：通过本地文件描述符的地址和长度(单位:byte)，获取socket名字
+ 声明：`int getsockname(int fd, const struct sockaddr *address, socklent *len);`
+ 参数：
  + `fd`  --  文件描述符
  + `address`  --  地址
  + `len`      --  长度
+ 返回值：
  + 成功  -- 
  + 失败  --  

### connect()

+ 简述：创建一个socket文件描述符和地址的连接
+ 声明：`int connect(int fd, const struct sockaddr *addr, socklent_t len);`
+ 参数：
  + `fd`  --  文件描述符
  + `addr` --  要连接的地址
  + `len`  --  地址的长度(单位：字节)
+ 返回值：  
  + 成功  --  返回0
  + 失败  --  返回-1

### send()

+ 简述：发送N字节的BUF到socket FD。返回发送的数字或-1。
+ 声明：`ssize_t send (int fd, const void *buf, size_t n, int flags);`
+ 参数：
+ 返回值：

### recv()

+ 简述：从socket FD中读取N个字节，并输入到BUF中
+ 声明：`ssize_t recv(int fd, void *buf, size_t n, int flags);`
+ 参数：
  + `fd`  --  文件描述符
  + `buf` --  要存放的缓冲区
  + `n`   --  读取的数据大小
  + `flags` --  
+ 返回值：
  + 成功  --  返回读取的字节数
  + 失败  --  返回-1

### sendto()

+ 简述：在socket FD上向地址ADDR(长度为ADDR_LEN)发送N个字节的BUF
+ 声明：
  + `ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);`
+ 参数：
+ 返回值：
  + 成功  --  返回发送的字节数
  + 失败  --  返回-1

### recvfrom()

+ 简述：通过socket FD读取N个字节到BUF
+ 声明：`ssize_t recvfrom(int fd, void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);`
+ 参数：
+ 返回值：
  + 成功  --  返回读取的字节数
  + 失败  --  返回-1
+ 注意：
  + 如果ADDR不为空，将其`*ADDR_LEN`字节填充为发送方的地址，并将地址的实际大小存储在`*ADDR_LEN`中。返回读取的字节数或-1错误

### sendmsg()

+ 简述：在socket FD上发送一个由MESSAGE描述的信息
+ 声明：`ssize_t sendmsg(int fd, const struct msghdr *message, int flags);`
+ 参数：
+ 返回值：
  + 成功  --  返回发送的字节数
  + 失败  --  返回-1

### recvmsg()

+ 简述：从socket FD接收一个由MESSAGE描述的信息
+ 声明：`ssize_t recvmsg(int fd, struct msghdr *message, int flags);`
+ 参数：
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### getsockopt()

+ 简述：将套接字`FD`的选项`OPTNAME`在协议级别`level`上的当前值放入`OPTVAL` (`*OPTLEN`字节长)，并将`*OPTLEN`设置为该值的实际长度
+ 声明：`int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### setsockopt()

+ 简述：设置套接字`FD`的选项`OPTNAME`在协议级别`level`为`*OPTVAL` (`OPTLEN`字节长)
+ 声明：`int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### listen()

+ 简述：准备接受套接字FD上的连接。在进一步的请求被拒绝之前，将有N个连接请求排队
+ 声明：`int listen(int fd, int n);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### accept()

+ 简述：在套接字FD上等待连接.
  + 当连接到达时，打开一个新的套接字与之通信，将`*ADDR (*ADDR_LEN字节长)`设置为连接对等体的地址，将`*ADDR_LEN`设置为地址的实际长度，
  + 并返回新套接字的描述符，错误则返回-1
+ 声明：`int accept(int fd, const struct sockaddr *addr, socklen_t *addr_len);`
+ 返回值：
  + 成功  --  新套接字的描述符
  + 失败  --  返回-1

### shutdown()

+ 简述：关闭套接字FD上打开的全部或部分连接
+ 声明：`int shutdown(int fd, int how);`
+ 参数：
  + `fd`  --  套接字文件描述符
  + `how`  --
    + `SHUT_RD`  --  不再接收连接
    + `SHUT_WR`  --  不再传输数据
    + `SHUT_RDWR`  --  不再传输数据和接收连接
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1

## bits/socket.h

+ 特定于系统的套接字常量和类型
+ 这个特定于操作系统的头文件定义了`SOCK_*`、`PF_*`、`AF_*`、`MSG_*`、`SOL_*`和`SO_*`常量，以及`struct sockaddr `、`struct msghdr `和`struct linger `类型。

### struct sockaddr

+ 简述：描述通用套接字地址的结构
+ 声明：
  ```c
    struct sockaddr
      {
        __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  地址族 */
        char sa_data[14];		/* Address data.  14字节，包含套接字中的目标地址和端口信息    */
      };
  ```
+ 注意：
  + 结构体用来处理网络通信的地址。
  + sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了，

## netinet/in.h

+ 网络协议相关数据结构的声明和定义

+ 简述：描述因特网套接字地址的结构
+ 声明：
  ```c
    struct sockaddr_in
      {
        __SOCKADDR_COMMON (sin_);   /* Address Family.   地址族 */
        in_port_t sin_port;			    /* Port number.      16位TCP/UDP端口号 */
        struct in_addr sin_addr;		/* Internet address. 32位IP地址  */

        /* Pad to size of `struct sockaddr'.  不使用*/
        unsigned char sin_zero[sizeof (struct sockaddr) -
    			   __SOCKADDR_COMMON_SIZE -
    			   sizeof (in_port_t) -
    			   sizeof (struct in_addr)];
      };
  ```
+ 注意：
  + 结构体用来处理网络通信的地址。
  + 该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中
  + 该结构体中提到的另一个结构体in_addr定义如下
     ```c
        /* Internet address.  */
        typedef uint32_t in_addr_t;
        struct in_addr
          {
            in_addr_t s_addr;
          };
     ```
  + `sin_port`和`sin_addr`都必须是网络字节序（`NBO`），一般可视化的数字都是主机字节序（`HBO`）

## sockaddr_in和sockaddr

+ 二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。
+ 二者是并列结构，指向`sockaddr_in`结构的指针也可以指向`sockaddr`

+ `sockaddr`常用于`bind`、`connect`、`recvfrom`、`sendto`等函数的参数，指明地址信息，是一种通用的套接字地址。
+ `sockaddr_in` 是internet环境下套接字的地址形式。所以在网络编程中我们会对`sockaddr_in`结构体进行操作，使用`sockaddr_in`来建立所需的信息，最后使用类型转化就可以了。

+ 一般先把`sockaddr_in`变量赋值后，强制类型转换后传入用`sockaddr`做参数的函数：
  + `sockaddr_in`用于socket定义和赋值；
  + `sockaddr`用于函数参数

+ 另外 -- 两个函数 htons() 和 inet_addr()
  + `htons()`作用是将端口号由主机字节序转换为网络字节序的整数值。(`host to net`)
  + `inet_addr()`作用是将一个`IP`字符串转化为一个网络字节序的整数值，用于`sockaddr_in.sin_addr.s_addr`
  + `inet_ntoa()`作用是将一个`sin_addr`结构体输出成`IP`字符串(`network to ascii`)，例如
    + `printf("%s",inet_ntoa(mysock.sin_addr));`
  + `htonl()`作用和`htons()`一样，不过它针对的是32位的（`long`），而`htons()`针对的是两个字节，16位的（`short`）
  + 与`htonl()`和`htons()`作用相反的两个函数是：`ntohl()`和`ntohs()`
  + 它们的声明都在文件`netinet/in.h`中

## bits/sockaddr.h

+ `struct sockaddr_*`通用成员和大小的定义，通用版本。

+ `#define	__SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix##family`
+ 这个宏用于声明用于套接字地址的数据类型的初始公共成员，`struct sockaddr `、`struct sockaddr_in `、`struct sockaddr_un `等。

## arpa/inet.h

### inet_addr()

+ 简述：将互联网主机地址从数字和点符号在CP转换成二进制数据在网络字节顺序
+ 声明：`in_addr_t inet_addr (const char *cp);`
+ 参数：
+ 返回值：

### inet_lnaof()

+ 简述：在`in`返回Internet地址的本地主机地址部分。
+ 声明：`in_addr_t inet_lnaof(struct in_addr in);`
+ 参数：
+ 返回值：

### inet_makeaddr()

+ 简述：将网络编号NET与本机地址主机相结合，使Internet主机地址按网络字节序排列
+ 声明：`struct in_addr inet_makeaddr (in_addr_t net, in_addr_t host);`
+ 参数：
+ 返回值：

### inet_netof()

+ 简述：返回网络号码部分的互联网地址
+ 声明：`in_addr_t inet_netof (struct in_addr in);`
+ 参数：
+ 返回值：

### inet_network()

+ 简述：从CP开始的数字加点格式的地址中提取网络字节顺序的网络号
+ 声明：`in_addr_t inet_network (const char *cp);`
+ 参数：
+ 返回值：

### inet_ntoa()

+ 简述：将`in`中的因特网数字转换为`ASCII`表示。返回值是一个指向包含该字符串的内部数组的指针
+ 声明：`char *inet_ntoa (struct in_addr in);`
+ 参数：
+ 返回值：

### inet_pton()

+ 简述：从CP开始的缓冲区中Internet数字的表示格式转换为二进制网络格式，并将接口类型AF的结果存储在从BUF开始的缓冲区中
+ 声明：`int inet_pton (int af, const char *cp, void *buf);`
+ 参数：
+ 返回值：

## strings.h

### bcmp()

+ 简述：比较S1和S2的N个字节(与memcmp相同)
+ 声明：`int bcmp (const void *s1, const void *s2, size_t n);`
+ 参数：
+ 返回值：

### bcopy()

+ 简述：复制N字节的SRC到DEST(类似于memmove，但参数是相反的)
+ 声明：`int bcopy (const void *src, void *dest, size_t n);`
+ 参数：
+ 返回值：

### bzero()

+ 简述：设置S的N个字节为0
+ 声明：`void bzero (void *s, size_t n);`
+ 参数：
+ 返回值：

### ffs()

+ 简述：返回`I`中设置的第一个比特位的位置，如果没有设置，则返回0。最低有效位是位置1，最高有效位是32
+ 声明：`int ffs (int i);`
+ 参数：
+ 返回值：

### strcasecmp()

+ 简述：比较参数s1和s2字符串，比较时会自动忽略大小写的差异
+ 声明：`extern int strcasecmp (const char *s1, const char *s2)`
+ 参数：
  + `__s1`  -- 字符指针s1
  + `__s2`  -- 字符指针s2
+ 返回值：
  + 若参数s1和s2字符串相等则返回0；
  + s1大于s2，则返回大于0的值；
  + s1小于s2则返回小于0的值
  
### strncasecmp()

+ 简述：用来比较参数s1和s2字符串前n各字符，比较时会自动忽略大小写的差异
+ 声明：` int strncasecmp (const char* s1, const char* s2, size_t n);`
+ 参数：
  + `s1`  -- 字符指针s1
  + `s2`  -- 字符指针s2
  + `n`   -- 字符数n
+ 返回值
  + 如果参数s1和s2字符串相同，则返回0
  + s1若大于s2，则返回大于0的值
  + s1若小于s2，则返回小于0的值

### strcasecmp_l()

+ 简述：使用LOC中的排序规则比较S1和S2，忽略大小写
+ 声明：`int strcasecmp_l (const char *s1, const char *s2, locale_t loc);`
+ 参数：
+ 返回值：

### strncasecmp_l()

+ 简述：使用LOC中的排序规则，不超过N个字符的S1和S2进行比较，忽略大小写
+ 声明：`int strncasecmp_l (const char *s1, const char *s2, size_t n, locale_t loc);`
+ 参数：
+ 返回值：