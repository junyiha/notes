## 概述 -- 理论基础知识

## Linux C++与Windows C++

### 1.1 

+ 我之所以把这个标题单独列出来，是想纠正现在很多 C/C++ 新人和初学者一些不当的认识，一般有以下几种观点：
  + Linux C++ 开发就是后台开发，而 Windows C++ 开发就是客户端开发；
  + 后端开发比客户端开发（前端）高级，因此后端开发行业薪资水平比客户端开发薪资要高；
  + 我只学 Linux，不学 Windows。

+ Linux C++ 和 Windows C++ 一样，没有孰高孰低之分，只是两种不同的操作系统而已，不要觉得在 Linux 下敲命令就比在 Windows 的图形化界面点击鼠标达高级。
+ 图形化界面之于命令行，是人们对更高级、更方便的工具追求的必然结果。Linux C++ 也不一定就是后台开发，Windows C++ 也不一定就是客户端开发；所谓的服务器与客户端是个相对的概念，即谁给谁提供服务，提供服务的我们认为是服务端（后台），被服务的我们认为是客户端（前台）。而 Windows 作为后台服务的应用也比比皆是，如笔者之前所在的某交易所的服务器后台都是 Windows 下的 C++ 程序；另外如一些游戏类的服务器端，也不少是 Windows 的。
+ 借用《UNIX 编程艺术》这本书的观点，Windows 和 Linux 的哲学理念不一样，Windows 是假设你不会操作，它教你如何操作，而 Linux 是假设你会操作然后进行操作。根据这个理念，Windows 一般是普通人用的多，而 Linux 是程序员用的多。
+ 从编程的角度来说，Windows 的代码风格是所谓的匈牙利命名法，而 Linux 是短小精悍的连字符风格。例如同一个表示屏幕尺寸的整型变量，Windows 上可能被命名为 iScreen 或 cxScreen ，而 Linux 可能是 screen；再例如 Windows 上创建线程的函数叫 CreateThread，Linux 下叫 pthread_create。有时候，我觉得 Windows 的匈牙利命名法反而更容易理解代码。

+ 这里既然提到前端（客户端）开发和后端开发，这里不得不提一下，这二者没有优劣之分。其侧重点和开发思维是不一样的，
  + 前端（客户端）开发一般有较多的界面逻辑，它们是直接与用户打交道，因而一款客户端软件的好坏很大程度上取决于其界面的易用性和流畅性，开发者只要把这一端的“一亩三分地”给管理好即可；
  + 而后端服务，对于普通用户是透明的，开发者的程序必须尽量体现“服务”这个字眼，即更有效地为更多的客户端服务，这就要求兼顾请求响应的正确性、及时性和流畅性。
+ 由于服务软件也是运行在某台物理机器上的程序，鉴于 CPU、内存、网络带宽资源有限，而服务程序一般是长周期运行的，因此必须合理地分配和使用资源（如尽量回收不再使用的各种资源）。开发者应从全局考虑，不能在某个“客户端”这一棵树上“吊死”。
+ 从个人的职业发展来看，建议从事客户端开发的人员适当地了解一下服务器开发的思路，反过来也建议从事后端开发的人员去学习一下客户端开发，二者相得益彰。从个人的技术提高来说，也是很有帮助的。
+ 例如您要学习一套开源的软件代码，如果您熟悉客户端和服务器的基本开发和调试技巧，您可以更好地学习它。而在工作上，一个项目，往往是由客户端和服务器程序组成，如果您都熟悉，您可以站在一个更高的角度去审视它、规划它，这也是架构师的基本要求之一。

## 如何看待 C++ 11/14/17 新标准

### 1.1 

+ C++ 开发者有个不成文的规定：即使您对 C++ 很熟悉，也不要在简历上写上您精通 C++，原因很简单—— C++ 这门语言包含的东西实在太多了，没有人能真正“精通”所有。
+ C++ 既支持面向对象设计（OOP），也支持以模板语法为代表的泛型编程（GP）。而且新的 C++ 标准和遵循 C++ 新标准的编译器也层出不穷，这些年，C++ 变化越来越大、越来越快，从最初业界和开发者翘首以盼的 C++11 标准，历经 C++14、C++17 到今天的 C++20，这门语言与之前的版本差别越来越大，更多原来需要使用第三库的功能也被陆续添加到 C++ 标准库中。

+ 就我个人经验来说，对于C++11、C++14、C++17 乃至 C++20，我们学习它们的准则应该是以实用为主，也就是说我们应该学习其实用的部分，至于新标准提到的一些高级特性和各种复杂的模板，我们大可不必去了解。我们并不是做学术研究，我们学习 C++ 是为了投入实际的生产开发，所以应该去学习 C++ 新标准中实用的语法和工具库。关于 C++11 常用一些知识点，这里也简单地给读者列举一下。
  + auto 关键字
  + for-each 循环
  + 右值及移动构造函数 + std::forward + std::move + stl 容器新增的 emplace_back() 方法
  + std::thread 库、std::chrono 库
  + 智能指针系列（std::shared_ptr/std::unique_ptr/std::weak_ptr），智能指针的实现原理一定要知道，最好是自己实现过
  + 线程库 std::thread + 线程同步技术库 std::mutex/std::condition_variable/std::lock_guard 等
  + Lamda 表达式（Java 中现在也常常考察 Lamda 表达式的作用）
  + std::bind/std::function 库
  + 其他的就是一些关键字的用法（override、final、delete），还有就是一些细节如可以像 Java 一样在类成员变量定义处给出初始化值。

## C++ 语言基础与进阶

+ 这里说的基础不是狭义上的 C++ 语言基础，而是包括 C++ 开发这一生态体系的基础，笔者认为的基础包括：
  + C++ 语言本身熟练使用程度。
  + 前面也介绍了单纯的 C++ 您啥也干不了，您必须结合一个具体的操作系统平台，所以得熟悉某个操作系统平台的 API 函数，比如Linux，以及该操作系统的原理。这里说的操作系统的原理不局限于您在操作系统原理图书上看的知识，而是实实在在与系统 API 关联起来的，如熟练使用各种进程与线程函数、多线程资源同步函数、文件操作函数、系统时间函数、窗口自绘与操作函数（这点针对 Windows）、内存分配与管理函数、PE 或 ELF 文件的编译、链接原理等等。
  + 网络通信，网络通信在这里具体一点就是 Socket 编程。这里的 Socket 编程不仅要求熟练使用各种网络 API 函数，还要求理解和灵活运用像三次握手四次挥手等各种基础网络通信协议与原理。关于 Socket 编程实践，《TCP/IP 网络编程》这本书是非常好的入门教材。
+ 总结起来，可以得到如下公式：
  + **一款 C++ 软件 = C++ 语法 + 操作系统 API 函数调用**

+ 如果您达到了我上面说的三点后，可以再找一些高质量的开源项目去实战一下。需要注意的是，最好找一些没有复杂业务或者您熟悉其业务的开源项目（如开源的 IM 系统）。如果你不熟悉其业务，不仅要学习其业务（软件功能），还需要再去学习它的源码，最后可能让我们迷失了最初学习这款软件的目的。
+ 学习这些项目的同时，读者应该先确定自己的学习目的，如果您的目的是学习和借鉴这款软件的架构，那么先从整体去把握，不要一开始就迷失在细枝末节中，这类我称之为“粗读”；或者您的目的是学习开源软件在一些细节上的处理与做法，这个时候，您可以针对性地去阅读您感兴趣的模块，深入到每一行代码上

+ 学习开源软件存在一种风气，许多新手喜欢道听途说，一听别人说这个软件不好，那个软件存在某某瑕疵就放弃阅读它的打算了。然后到了实际开发中，因为心中没有任何已有软件开发问题的解决方案，产生挫败感，久而久之就对本来喜欢的 C/C++ 开发失去了兴趣。
+ 学习的过程是先接触，再熟悉，再模仿，再创造。不管什么开源项目，在您心中没有任何思路或者解决方案时，您应该先接触熟悉，不断模仿，做到至少心中有一套对于某场景的解决方案，然后再来谈创新谈批判、改造别人的项目。
+ 我个人学习一套陌生的开源项目时，总是喜欢将程序用调试器正常跑起来，然后再中断下来，统计当前的线程数目，然后通过程序入口 main 函数从主线程追踪其他工作线程是如何创建的；接着，分析和研究每个线程的用途以及线程之间交互的，这就是整体把握，接着找我感兴趣的细节去学习。

## C++面试

+ 对于社会人士参加的 C++ 职位的面试，如果是大型互联网公司，虽然社会招聘问的更多的是项目经验，适当地为一些基础的算法和数据结构知识做一些准备也是非常有用的。举个例子，如果问到二分查找这一类基础算法，如果答不出来未免会让面试官印象不太好，场面也比较尴尬。另外，C++ 是一门讲究深度的编程技能，对于有一定工作年限的面试者，面试官往往会问很多原理性的细节，这就要求广大 C++ 开发者在平常多留心、多积累、多思考技术背后的原理。
+ 对于大多数小型企业，无论是应届生还是社会人士，只要有能力胜任一定的工作即可。一般只要对所面试的公司项目有类似经验或者相关的技术能力，基本上就可以通过面试。大多数小公司在乎的是您来了能不能干活，所以这类公司对实际项目经验和技能要求更高一点。
+ 关于项目经验，许多人可能觉得项目经验一定是自己参与的项目，其实不然，项目经验也可以来源于您阅读和学习其他人的项目代码或者开源软件，只要您能看懂并理解它们，在面试的时候提及到，能条理清晰、自圆其说即可。当然，如果不熟悉或者只是了解些皮毛，切记不可信口开河、胡编乱造甚至张冠李戴。
+ 我曾经面试过一些开发者，看简历项目经验丰富，实际一问的时候，只是把别人的框架或者库拿来包装调用一下，问及其技术原理时，不是顾左右而言他就是说不清道不明模棱两可含糊不清，这一类人往往比不知道还让人讨厌，面试官一般反感这一类面试者所谓的项目经验。

## 学生与社会人士学习 C++ 方式的区别

+ 作为学生有充裕的时间，建议除了把 C++ 语法学好，系统地多读一点基础的书籍，如操作系统原理、网络编程、数据结构与算法等相关各方各面的经典书籍。
+ 社会人士由于已经走上工作岗位，家庭、工作的琐事繁多，没有太多的时间去系统地阅读一些相关基础书籍，如果您当前工作正好是从事 C/C++ 开发，那么请结合您当前的项目来学习，搞清楚项目的体系结构、吸收项目中优秀的实现细节，针对性地补充相关知识，这是进步最快的方式。
+ 但是实际情形中，很多人觉得公司的项目代码又烂又杂，不愿意去研究。这种思想千万不能有的，在您没有自己足够好的能力给公司提供更好的解决方案，请先学习和模仿，我们此时要保持“空杯”心态，公司的代码再烂，它也是公司的商业价值所在；即使是纯粹的业务代码，也有它的可取之处，择其善者而从之，其不善者而改之。尤其是开发者处于一些初中级的开发岗位时，可能接触不到公司核心框架的源码，此时千万不要盲目地去排斥。学业务，补基础，时刻意识清醒自己所需，明白自己想要学的东西。
+ 如果从事的不是 C++ 相关的开发，那么可以挤出一些时间去学习一些开源的代码，在阅读开源代码的过程中，针对性地补缺补差。不建议系统地去看《C++ Primer 中文版》《UNIX 环境高级编程》诸如此类的大部头书籍，实际开发中不需要太多这类书中的细枝末节，阅读这类书往往只会事倍功半，甚至最后因书籍太厚、时间不够，最后坚持不下去，最终放弃。

+ 当然，对于社会人士，当您有一定的时间的时候一定要去补充一些基础的、原理性的东西，千万不要沉溺于“面向搜索引擎编程”或者“面向工资编程”，有些问题虽然当时通过搜索引擎解决了，但如果想在技术或职业上有长足的发展，一定要系统地去读一些经典的、轻量级的书籍（如《C++ 对象模型》）。长期在网上的文章中寻章摘句，只会让您的知识结构碎片化、凌乱化，甚至混乱化。而且互联网上的技术文章质量良莠不齐，有时候也容易对自己形成误导和依赖。总而言之，作为技术开发人员，提高自己技术水平是改变现状、改善生活最直接的途径。

+ 关于 C/C++，暂且就讨论这么多。最后再强调一遍，C++ 是一门讲究深度的语言，其“深度”不是体现在会多少 C++ 语法，而是能够洞察您所写的 C++ 代码背后的系统原理，这是需要长期不断的积累的，没有速成之法。反过来一旦学成，可以快速地学习其他语言和框架。个人觉得，如果自主创业或者想在二三线城市长期发展的读者，C/C++ 应该是优选语言，有了它作为基础，您可以跳出依赖各种环境和框架的窠臼，快速地学习和开发您想要的软件，完成您想要的业务产品。

## 回调函数

### 笔记-0

+ 参考：
  + `https://www.cnblogs.com/swordzj/archive/2007/04/24/2034769.html`

#### 1.1 什么是回调？

+ 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用
  + 同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；
  + 回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；
  + 异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）

+ 回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。
+ 同步调用是三者当中最简单的，而回调又常常是异步调用的基础，
+ 对于不同类型的语言（如结构化语言和对象语言）、平台（Win32、JDK）或构架（CORBA、DCOM、WebService），客户和服务的交互除了同步方式以外，都需要具备一定的异步通知机制，让服务方（或接口提供方）在某些情况下能够主动通知客户，而回调是实现异步的一个最简捷的途径。
+ 对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。
+ 在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。
+ Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。由于Windows平台的API是用C语言来构建的，我们可以认为它也是回调函数的一个特例。
+ 对于分布式组件代理体系CORBA，异步处理有多种方式，如回调、事件服务、通知服务等。事件服务和通知服务是CORBA用来处理异步消息的标准服务，他们主要负责消息的处理、派发、维护等工作。对一些简单的异步处理过程，我们可以通过回调机制来实现。

#### 1.2 面向对象语言中的回调

+ 对于回调的实现，也有两种截然不同的模式：
  + 一种是结构化的函数回调模式
  + 一种是面向对象的接口模式

+ 回调对象，什么叫做回调对象？它具体用在那些场合？
  + 首先，让我们把它与回调函数对比一下，回调函数是一个定义了函数的原型，函数体则交由第三方来实现的一种动态应用模式。要实现一个回调函数，我们必须明确知道几点：该函数需要那些参数，返回什么类型的值。
  + 同样，一个回调对象也是一个定义了对象接口，但是没有具体实现的抽象类（即接口）。要实现一个回调对象，我们必须知道：它需要实现哪些方法，每个方法中有哪些参数，该方法需要放回什么值。
+ 因此，在回调对象这种应用模式中，我们会用到接口。接口可以理解成一个定义好了但是没有实现的类，它只能通过继承的方式被别的类实现。

+ 回调方法(Callback Method)，可以看做是回调对象的一部分。
  + 在有些场合，我们不需要按照给定的要求实现整个对象，而只要实现其中的一个方法就可以了，这时我们就会用到回调方法

### 笔记-1 

+ 参考：
  + `https://www.cnblogs.com/cyyz-le/p/11278903.html`

#### 1.1 回调函数的作用

+ 官方定义：
  + 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

+ 函数指针：
  + **函数指针也是一种指针，只是它指向的不是整型，字符型，而是函数**。在C中，每个函数在编译后都是存储在内存中，并且每个函数都有一个入口地址，根据这个地址，我们便可以访问并使用这个函数。函数指针就是通过指向这个函数的入口，从而调用这个函数。

+ `int func();`, `int (*p)();`
  + `func`是一个返回值为整型的函数
  + `p`是一个指针，指针指向一个函数，函数的返回值是整型
  + `p = func;`，函数func把地址赋给函数指针p
  + 下一次调用`func()`的时候，可以直接调用`(*p)()`或者`p()`，为什么可以直接使用`p()`?
    + 因为函数名本质也是一个地址，函数指针本质也是一个地址，把地址`func`赋给了`p`，`p`就等于`func`
    + `(*p)()`和`p()`相当于间接访问和直接访问的关系，不用纠结过多

+ 回调函数：
  + 回调函数就是你写一个函数，把函数地址赋值一个函数指针，然后把这个函数指针当作参数赋给另一个函数，另一个函数通过函数指针的地址调用这个函数，就是回调函数

### 笔记-2

+ 参考：
  + `https://www.cnblogs.com/danshui/archive/2012/01/02/2310114.html`

#### 1.1 概述

+ 回调函数，就是一个通过**函数指针**调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 

+ 回调函数机制：
  + 定义一个函数（普通函数即可）
  + 将此函数的地址注册给调用者
  + 特定的事件或条件发生时，调用者使用函数指针调用回调函数
+ 注意：
  + 为什么要特定事件或条件发生？
  + 不应该随时都可以调用回调函数吗？
  + 可以把回调函数和调用函数封装承类再调用

#### 1.2 函数指针

+ 概念：
  + 指针是一个变量，是用来指向内存地址的。
  + 一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。
  + 函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种**指向函数入口地址的指针**称为函数指针

```
  void Invoke(char* s);

  int main()
  {
      void (*fp)(char* s);    //声明一个函数指针(fp)        
      fp=Invoke;              //将Invoke函数的入口地址赋值给fp
      fp("Hello World!\n");   //函数指针fp实现函数调用
      return 0;
  }

  void Invoke(char* s)
  {
      printf(s);
  }
```
+ 由上可知：
  + 函数指针函数的声明之间唯一区别就是，用指针名`（*fp）`代替了函数名`Invoke`，这样这声明了一个函数指针，然后进行赋值`fp=Invoke`就可以进行函数指针的调用了。
  + 声明函数指针时，只要函数返回值类型、参数个数、参数类型等保持一致，就可以声明一个函数指针了。
  + 注意，函数指针必须用括号括起来 `void (*fp)(char* s)`

+ 实际中，为了方便，通常用宏定义的方式来声明函数指针，实现程序如下：
  ```
    typedef void (*FP)(char* s);
    void Invoke(char* s);

    int main(int argc,char* argv[])
    {
        FP fp;      //通常是用宏FP来声明一个函数指针fp
        fp=Invoke;
        fp("Hello World!\n");
        return 0;
    }

    void Invoke(char* s)
    {
        printf(s);
    }
  ``` 

#### 1.3 回调函数 - 详解

+ 概念：
  + 回调函数，顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。
  + 函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数

+ 示例：
  + 标准Hello World程序：
    ```
      int main(int argc,char* argv[])
      {
          printf("Hello World!\n");
          return 0;
      }
    ``` 
  + 将它修改成函数回调样式：
    ```
      //定义回调函数
      void PrintfText() 
      {
          printf("Hello World!\n");
      }

      //定义实现回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)())
      {
          callfuct();
      }

      //在main函数中实现函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText);
          return 0;
      }
    ```
  + 修改成带参的回调样式：
    ```
      //定义带参回调函数
      void PrintfText(char* s) 
      {
          printf(s);
      }

      //定义实现带参回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)(char*),char* s)
      {
          callfuct(s);
      }

      //在main函数中实现带参的函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText,"Hello World!\n");
          return 0;
      }
    ``` 

## C++11中变量初始化方法汇总

+ 参考资料：`https://blog.csdn.net/Q1302182594/article/details/47423347`

### 1.1 背景

+ 在C++语言中，初始化 和 赋值 并不是同一个概念
  + 初始化：创建变量时赋予其一个初始值
  + 赋值：把对象（已经创建）的 当前值 擦除，而用一个新值来代替

### 1.2 列表初始化

+ 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用（在此之前，只是在初始化数组的时候用到）
+ 列表初始化有两种形式:
  + `int a = {0};  //  列表初始化方式1`
  + `int a{0};     //  列表初始化方式2`
+ 上述的两种方式都可以将变量a初始化为0

+ 当对内置类型使用列表初始化时，若初始值存在丢失的风险，编译将报错，如：
  ```
    int a = 3.14;   // 正确，虽然会丢失小数部分，但是编译器不报错。
    int a = {3.14}; // 错误，因为将会丢失小数部分（其实，g++只是对此提示警告而已，并非错误）。
  ``` 

+ 由花括号括起来的初始值，不仅可以用于初始化变量，还可以用于为对象（旧变量）赋新值。
  ```
    int a = 1;   // 定义变量，并且初始化为1
    a = {3};     // 为变量a赋新值3
  ``` 

+ 用处：
  + 可以用在任何需要变量初始化的地方，例如第6章的类成员初始化，以及在for()中定义的变量：
    ```
      for (int i{0}; i < 10; i++) {
      ...
      }
    ``` 

### 1.3 拷贝初始化

+ 如果使用等号初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去
+ 示例：
  ```
    string s1;       // 默认初始化为空字符串
    string s2 = s1;  // 拷贝初始化，s2是s1的副本
  ``` 

### 1.4 直接初始化

+ 如果在新创建的变量右侧使用括号将初始值括住（不用等号），则执行的是直接初始化（direct initialization）
  ```
    string s1();        // 直接初始化为空字符串 
    string s2("hi");    // 直接初始化
    string s3(3, 'c');  // 直接初始化，s2的内容是ccc
  ``` 
+ 使用圆括号提供初值是用来构造(construct)对象，因此可以知道，所谓的直接初始化就是显式的调用相应的构造函数

+ 值初始化的三种情况
  + 在数组初始化过程中如果提供的初值数量少于数组大小时；
  + 当不使用初始值定义一个局部静态变量时；
  + 当通过T()形式的表达式显式地请求值初始化时（T是类型名）
+ explicit构造函数只能用于直接初始化

## `std::cout` 输出流和字符指针

+ 相关知识：
  + C-C++01_语言基础.md: 字符串 -- C++

### `std::cout` 输出流

+ `std::cout`语句的一般格式为：`std::cout << 表达式1 << 表达式2 << …… << 表达式n;`
+ `std::cin`语句的一般格式为：`std::cin >> 变量1 >> 变量2 >> …… >> 变量n;`

+ 在定义流对象时,系统会在内存中开辟一段缓冲区,用来暂存输入输出流的数据｡
+ 在执行`std::cout`语句时,先把插入的数据顺序存放在输出缓冲区中,直到输出缓冲区满或遇到`std::cout`语句中的`std::endl`(或`'\n'`,`ends`,`flush`)为止,此时将缓冲区中已有的数据一起输出,并清空缓冲区｡输出流中的数据在系统默认的设备(一般为显示器)输出｡

### 字符指针

+ 以字符串形式出现的，编译器都会为该字符串自动添加一个0作为结束符，如在代码中写：`"abc"`,那么编译器帮你存储的是`"abc\0"`

+ `"abc"`是常量吗？答案是有时是，有时不是。
  + 不是常量的情况：`"abc"`作为字符数组初始值的时候就不是，如`char str[] = "abc";`
    + 因为定义的是一个字符数组，所以就相当于定义了一些空间来存放`"abc"`，而又因为字符数组就是把字符一个一个地存放的，所以编译器把这个语句解析为 `char str[3] = {‘a’,’b’,’c’};`又根据上面的总结1，所以`char str[] = “abc”;`的最终结果是 `char str[4] = {‘a’,’b’,’c’,’\0’};`
    + 做一下扩展，如果`char str[] = “abc”;`是在函数内部写的话，那么这里的”abc\0”因为不是常量，所以应该被放在栈上
  + 是常量的情况： 把`"abc"`赋给一个字符指针变量时，如`char* ptr = "abc";`
    + 因为定义的是一个普通指针，并没有定义空间来存放`"abc"`，所以编译器得帮我们找地方来放`"abc"`，显然，把这里的`"abc"`当成常量并把它放到程序的常量区是编译器最合适的选择。
    + 所以尽管`ptr`的类型不是`const char*`，并且`ptr[0] = ‘x’;`也能编译通过，但是执行`ptr[0] = ‘x’;`就会发生运行时异常，因为这个语句试图去修改程序常量区中的东西。
    + 记得哪本书中曾经说过`char* ptr = “abc”;`这种写法原来在c++标准中是不允许的，但是因为这种写法在c中实在是太多了，为了兼容c，不允许也得允许。虽然允许，但是建议的写法应该是`const char* ptr = “abc”;`这样如果后面写`ptr[0] = ‘x’`的话编译器就不会让它编译通过，也就避免了上面说的运行时异常
    + 又扩展一下，如果`char* ptr = “abc”;`写在函数体内，那么虽然这里的`”abc\0”`被放在常量区中，但是ptr本身只是一个普通的指针变量，所以ptr是被放在栈上的, 只不过是它所指向的东西被放在常量区罢了。

---

+ 字符数组和字符指针最根本的区别是:
  + 在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限

### 使用`std::cout`输出字符串指针地址

+ 由于C++标准库中I/O类对<<操作符重载，因此在遇到字符型指针时会将其当作字符串名来处理，输出指针所指的字符串。
+ 既然这样，那么我们就别让它知道那是字符型指针，所以得用到强制类型转换，不过不是C的那套，我们得用static_cast来实现，把字符串指针转换成无类型指针，这样更规范，如下：
  ```
    #include <iostream>

    int main()
    {
      const char *ptr = "this is a string";

      // C
      printf("string value is : %s \n", ptr);
      printf("the pointer of string is : %p \n", ptr);

      // C++
      std::cout << "string value is :" << ptr << std::endl;
      std::cout << "the pointer of string is :" << static_cast<const char *>(ptr) << std::endl;

      return 0;
    }
  ``` 

## c++中函数参数返回值用`std::string`好还是`const char *`好

### 函数参数传递

#### 1.1

+ 有这样一个函数test需要两个字符串作为参数，那么test的原型定义成`test(string, string)`呢还是定义成`test(const char*, const char*)`还是其他呢？

+ 当这样使用时 test("hello", "world"):
  +  如果原型是第一种`test(string, string)`，就需要首先构建string对象，然后因为是值传递需要内存拷贝。
  +  如果原型是第二种`test(const char*, const char*)`，由于需求是需要两个string型变量，参数传进来之后还得转换成string型，如：`string a(A);string b(B);`

+ 这也不省事，如果用另外一种就非常好了，就是传递string引用，原型声明为`test(const string& A, const string& B)`:
  + 字符串传递进来时，并没有发生内存拷贝，效率会很高，并且AB可以直接当成string型来用，也比第二种方便。

#### 1.2

+ 如果该函数是作为接口给其他人使用(非源码级)，那么使用`const char*`，比如lib或dll
+ 如果函数内部使用的是`const char*`，不会转换为`std::string`，函数调用方也是`const char*`，那么使用`const char*`
+ 其它情况都用`const std::string&`

### 函数返回值

+ 关于函数的返回值，最好还是返回“值”吧，最好不要返回地址啊引用啊什么的，因为你不清楚使用者会不会改变这些值，如果返回的是引用，内存中只有一份，如果用户修改了值，势必会影响到其他的。
+ 所以这个函数的原型最好是 `string test(const string& A, const string& B)`

## `std::vector`的用法