## 概述 -- 理论基础知识

## 回调函数

### 1.1 概述

+ 回调函数，就是一个通过**函数指针**调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 

+ 回调函数机制：
  + 定义一个函数（普通函数即可）
  + 将此函数的地址注册给调用者
  + 特定的事件或条件发生时，调用者使用函数指针调用回调函数
+ 注意：
  + 为什么要特定事件或条件发生？
  + 不应该随时都可以调用回调函数吗？
  + 可以把回调函数和调用函数封装承类再调用

### 1.2 函数指针

+ 概念：
  + 指针是一个变量，是用来指向内存地址的。
  + 一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。
  + 函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种**指向函数入口地址的指针**称为函数指针

```
  void Invoke(char* s);

  int main()
  {
      void (*fp)(char* s);    //声明一个函数指针(fp)        
      fp=Invoke;              //将Invoke函数的入口地址赋值给fp
      fp("Hello World!\n");   //函数指针fp实现函数调用
      return 0;
  }

  void Invoke(char* s)
  {
      printf(s);
  }
```
+ 由上可知：
  + 函数指针函数的声明之间唯一区别就是，用指针名`（*fp）`代替了函数名`Invoke`，这样这声明了一个函数指针，然后进行赋值`fp=Invoke`就可以进行函数指针的调用了。
  + 声明函数指针时，只要函数返回值类型、参数个数、参数类型等保持一致，就可以声明一个函数指针了。
  + 注意，函数指针必须用括号括起来 `void (*fp)(char* s)`

+ 实际中，为了方便，通常用宏定义的方式来声明函数指针，实现程序如下：
  ```
    typedef void (*FP)(char* s);
    void Invoke(char* s);

    int main(int argc,char* argv[])
    {
        FP fp;      //通常是用宏FP来声明一个函数指针fp
        fp=Invoke;
        fp("Hello World!\n");
        return 0;
    }

    void Invoke(char* s)
    {
        printf(s);
    }
  ``` 

### 1.3 回调函数 - 详解

+ 概念：
  + 回调函数，顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。
  + 函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数

+ 示例：
  + 标准Hello World程序：
    ```
      int main(int argc,char* argv[])
      {
          printf("Hello World!\n");
          return 0;
      }
    ``` 
  + 将它修改成函数回调样式：
    ```
      //定义回调函数
      void PrintfText() 
      {
          printf("Hello World!\n");
      }

      //定义实现回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)())
      {
          callfuct();
      }

      //在main函数中实现函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText);
          return 0;
      }
    ```
  + 修改成带参的回调样式：
    ```
      //定义带参回调函数
      void PrintfText(char* s) 
      {
          printf(s);
      }

      //定义实现带参回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)(char*),char* s)
      {
          callfuct(s);
      }

      //在main函数中实现带参的函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText,"Hello World!\n");
          return 0;
      }
    ``` 

## C++11中变量初始化方法汇总

+ 参考资料：`https://blog.csdn.net/Q1302182594/article/details/47423347`

### 1.1 背景

+ 在C++语言中，初始化 和 赋值 并不是同一个概念
  + 初始化：创建变量时赋予其一个初始值
  + 赋值：把对象（已经创建）的 当前值 擦除，而用一个新值来代替

### 1.2 列表初始化

+ 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用（在此之前，只是在初始化数组的时候用到）
+ 列表初始化有两种形式:
  + `int a = {0};  //  列表初始化方式1`
  + `int a{0};     //  列表初始化方式2`
+ 上述的两种方式都可以将变量a初始化为0

+ 当对内置类型使用列表初始化时，若初始值存在丢失的风险，编译将报错，如：
  ```
    int a = 3.14;   // 正确，虽然会丢失小数部分，但是编译器不报错。
    int a = {3.14}; // 错误，因为将会丢失小数部分（其实，g++只是对此提示警告而已，并非错误）。
  ``` 

+ 由花括号括起来的初始值，不仅可以用于初始化变量，还可以用于为对象（旧变量）赋新值。
  ```
    int a = 1;   // 定义变量，并且初始化为1
    a = {3};     // 为变量a赋新值3
  ``` 

+ 用处：
  + 可以用在任何需要变量初始化的地方，例如第6章的类成员初始化，以及在for()中定义的变量：
    ```
      for (int i{0}; i < 10; i++) {
      ...
      }
    ``` 

### 1.3 拷贝初始化

+ 如果使用等号初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去
+ 示例：
  ```
    string s1;       // 默认初始化为空字符串
    string s2 = s1;  // 拷贝初始化，s2是s1的副本
  ``` 

### 1.4 直接初始化

+ 如果在新创建的变量右侧使用括号将初始值括住（不用等号），则执行的是直接初始化（direct initialization）
  ```
    string s1();        // 直接初始化为空字符串 
    string s2("hi");    // 直接初始化
    string s3(3, 'c');  // 直接初始化，s2的内容是ccc
  ``` 
+ 使用圆括号提供初值是用来构造(construct)对象，因此可以知道，所谓的直接初始化就是显式的调用相应的构造函数

+ 值初始化的三种情况
  + 在数组初始化过程中如果提供的初值数量少于数组大小时；
  + 当不使用初始值定义一个局部静态变量时；
  + 当通过T()形式的表达式显式地请求值初始化时（T是类型名）
+ explicit构造函数只能用于直接初始化