## 概述 -- 理论基础知识

## 回调函数

### 1.1 概述

+ 回调函数，就是一个通过**函数指针**调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 

+ 回调函数机制：
  + 定义一个函数（普通函数即可）
  + 将此函数的地址注册给调用者
  + 特定的事件或条件发生时，调用者使用函数指针调用回调函数
+ 注意：
  + 为什么要特定事件或条件发生？
  + 不应该随时都可以调用回调函数吗？
  + 可以把回调函数和调用函数封装承类再调用

### 1.2 函数指针

+ 概念：
  + 指针是一个变量，是用来指向内存地址的。
  + 一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。
  + 函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种**指向函数入口地址的指针**称为函数指针

```
  void Invoke(char* s);

  int main()
  {
      void (*fp)(char* s);    //声明一个函数指针(fp)        
      fp=Invoke;              //将Invoke函数的入口地址赋值给fp
      fp("Hello World!\n");   //函数指针fp实现函数调用
      return 0;
  }

  void Invoke(char* s)
  {
      printf(s);
  }
```
+ 由上可知：
  + 函数指针函数的声明之间唯一区别就是，用指针名`（*fp）`代替了函数名`Invoke`，这样这声明了一个函数指针，然后进行赋值`fp=Invoke`就可以进行函数指针的调用了。
  + 声明函数指针时，只要函数返回值类型、参数个数、参数类型等保持一致，就可以声明一个函数指针了。
  + 注意，函数指针必须用括号括起来 `void (*fp)(char* s)`

+ 实际中，为了方便，通常用宏定义的方式来声明函数指针，实现程序如下：
  ```
    typedef void (*FP)(char* s);
    void Invoke(char* s);

    int main(int argc,char* argv[])
    {
        FP fp;      //通常是用宏FP来声明一个函数指针fp
        fp=Invoke;
        fp("Hello World!\n");
        return 0;
    }

    void Invoke(char* s)
    {
        printf(s);
    }
  ``` 

### 1.3 回调函数 - 详解

+ 概念：
  + 回调函数，顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。
  + 函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数

+ 示例：
  + 标准Hello World程序：
    ```
      int main(int argc,char* argv[])
      {
          printf("Hello World!\n");
          return 0;
      }
    ``` 
  + 将它修改成函数回调样式：
    ```
      //定义回调函数
      void PrintfText() 
      {
          printf("Hello World!\n");
      }

      //定义实现回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)())
      {
          callfuct();
      }

      //在main函数中实现函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText);
          return 0;
      }
    ```
  + 修改成带参的回调样式：
    ```
      //定义带参回调函数
      void PrintfText(char* s) 
      {
          printf(s);
      }

      //定义实现带参回调函数的"调用函数"
      void CallPrintfText(void (*callfuct)(char*),char* s)
      {
          callfuct(s);
      }

      //在main函数中实现带参的函数回调
      int main(int argc,char* argv[])
      {
          CallPrintfText(PrintfText,"Hello World!\n");
          return 0;
      }
    ``` 

## C++11中变量初始化方法汇总

+ 参考资料：`https://blog.csdn.net/Q1302182594/article/details/47423347`

### 1.1 背景

+ 在C++语言中，初始化 和 赋值 并不是同一个概念
  + 初始化：创建变量时赋予其一个初始值
  + 赋值：把对象（已经创建）的 当前值 擦除，而用一个新值来代替

### 1.2 列表初始化

+ 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用（在此之前，只是在初始化数组的时候用到）
+ 列表初始化有两种形式:
  + `int a = {0};  //  列表初始化方式1`
  + `int a{0};     //  列表初始化方式2`
+ 上述的两种方式都可以将变量a初始化为0

+ 当对内置类型使用列表初始化时，若初始值存在丢失的风险，编译将报错，如：
  ```
    int a = 3.14;   // 正确，虽然会丢失小数部分，但是编译器不报错。
    int a = {3.14}; // 错误，因为将会丢失小数部分（其实，g++只是对此提示警告而已，并非错误）。
  ``` 

+ 由花括号括起来的初始值，不仅可以用于初始化变量，还可以用于为对象（旧变量）赋新值。
  ```
    int a = 1;   // 定义变量，并且初始化为1
    a = {3};     // 为变量a赋新值3
  ``` 

+ 用处：
  + 可以用在任何需要变量初始化的地方，例如第6章的类成员初始化，以及在for()中定义的变量：
    ```
      for (int i{0}; i < 10; i++) {
      ...
      }
    ``` 

### 1.3 拷贝初始化

+ 如果使用等号初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去
+ 示例：
  ```
    string s1;       // 默认初始化为空字符串
    string s2 = s1;  // 拷贝初始化，s2是s1的副本
  ``` 

### 1.4 直接初始化

+ 如果在新创建的变量右侧使用括号将初始值括住（不用等号），则执行的是直接初始化（direct initialization）
  ```
    string s1();        // 直接初始化为空字符串 
    string s2("hi");    // 直接初始化
    string s3(3, 'c');  // 直接初始化，s2的内容是ccc
  ``` 
+ 使用圆括号提供初值是用来构造(construct)对象，因此可以知道，所谓的直接初始化就是显式的调用相应的构造函数

+ 值初始化的三种情况
  + 在数组初始化过程中如果提供的初值数量少于数组大小时；
  + 当不使用初始值定义一个局部静态变量时；
  + 当通过T()形式的表达式显式地请求值初始化时（T是类型名）
+ explicit构造函数只能用于直接初始化

## `std::cout` 输出流和字符指针

+ 相关知识：
  + C-C++01_语言基础.md: 字符串 -- C++

### `std::cout` 输出流

+ `std::cout`语句的一般格式为：`std::cout << 表达式1 << 表达式2 << …… << 表达式n;`
+ `std::cin`语句的一般格式为：`std::cin >> 变量1 >> 变量2 >> …… >> 变量n;`

+ 在定义流对象时,系统会在内存中开辟一段缓冲区,用来暂存输入输出流的数据｡
+ 在执行`std::cout`语句时,先把插入的数据顺序存放在输出缓冲区中,直到输出缓冲区满或遇到`std::cout`语句中的`std::endl`(或`'\n'`,`ends`,`flush`)为止,此时将缓冲区中已有的数据一起输出,并清空缓冲区｡输出流中的数据在系统默认的设备(一般为显示器)输出｡

### 字符指针

+ 以字符串形式出现的，编译器都会为该字符串自动添加一个0作为结束符，如在代码中写：`"abc"`,那么编译器帮你存储的是`"abc\0"`

+ `"abc"`是常量吗？答案是有时是，有时不是。
  + 不是常量的情况：`"abc"`作为字符数组初始值的时候就不是，如`char str[] = "abc";`
    + 因为定义的是一个字符数组，所以就相当于定义了一些空间来存放`"abc"`，而又因为字符数组就是把字符一个一个地存放的，所以编译器把这个语句解析为 `char str[3] = {‘a’,’b’,’c’};`又根据上面的总结1，所以`char str[] = “abc”;`的最终结果是 `char str[4] = {‘a’,’b’,’c’,’\0’};`
    + 做一下扩展，如果`char str[] = “abc”;`是在函数内部写的话，那么这里的”abc\0”因为不是常量，所以应该被放在栈上
  + 是常量的情况： 把`"abc"`赋给一个字符指针变量时，如`char* ptr = "abc";`
    + 因为定义的是一个普通指针，并没有定义空间来存放`"abc"`，所以编译器得帮我们找地方来放`"abc"`，显然，把这里的`"abc"`当成常量并把它放到程序的常量区是编译器最合适的选择。
    + 所以尽管`ptr`的类型不是`const char*`，并且`ptr[0] = ‘x’;`也能编译通过，但是执行`ptr[0] = ‘x’;`就会发生运行时异常，因为这个语句试图去修改程序常量区中的东西。
    + 记得哪本书中曾经说过`char* ptr = “abc”;`这种写法原来在c++标准中是不允许的，但是因为这种写法在c中实在是太多了，为了兼容c，不允许也得允许。虽然允许，但是建议的写法应该是`const char* ptr = “abc”;`这样如果后面写`ptr[0] = ‘x’`的话编译器就不会让它编译通过，也就避免了上面说的运行时异常
    + 又扩展一下，如果`char* ptr = “abc”;`写在函数体内，那么虽然这里的`”abc\0”`被放在常量区中，但是ptr本身只是一个普通的指针变量，所以ptr是被放在栈上的, 只不过是它所指向的东西被放在常量区罢了。

---

+ 字符数组和字符指针最根本的区别是:
  + 在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限

### 使用`std::cout`输出字符串指针地址

+ 由于C++标准库中I/O类对<<操作符重载，因此在遇到字符型指针时会将其当作字符串名来处理，输出指针所指的字符串。
+ 既然这样，那么我们就别让它知道那是字符型指针，所以得用到强制类型转换，不过不是C的那套，我们得用static_cast来实现，把字符串指针转换成无类型指针，这样更规范，如下：
  ```
    #include <iostream>

    int main()
    {
      const char *ptr = "this is a string";

      // C
      printf("string value is : %s \n", ptr);
      printf("the pointer of string is : %p \n", ptr);

      // C++
      std::cout << "string value is :" << ptr << std::endl;
      std::cout << "the pointer of string is :" << static_cast<const char *>(ptr) << std::endl;

      return 0;
    }
  ``` 

## c++中函数参数返回值用`std::string`好还是`const char *`好

### 函数参数传递

#### 1.1

+ 有这样一个函数test需要两个字符串作为参数，那么test的原型定义成`test(string, string)`呢还是定义成`test(const char*, const char*)`还是其他呢？

+ 当这样使用时 test("hello", "world"):
  +  如果原型是第一种`test(string, string)`，就需要首先构建string对象，然后因为是值传递需要内存拷贝。
  +  如果原型是第二种`test(const char*, const char*)`，由于需求是需要两个string型变量，参数传进来之后还得转换成string型，如：`string a(A);string b(B);`

+ 这也不省事，如果用另外一种就非常好了，就是传递string引用，原型声明为`test(const string& A, const string& B)`:
  + 字符串传递进来时，并没有发生内存拷贝，效率会很高，并且AB可以直接当成string型来用，也比第二种方便。

#### 1.2

+ 如果该函数是作为接口给其他人使用(非源码级)，那么使用`const char*`，比如lib或dll
+ 如果函数内部使用的是`const char*`，不会转换为`std::string`，函数调用方也是`const char*`，那么使用`const char*`
+ 其它情况都用`const std::string&`

### 函数返回值

+ 关于函数的返回值，最好还是返回“值”吧，最好不要返回地址啊引用啊什么的，因为你不清楚使用者会不会改变这些值，如果返回的是引用，内存中只有一份，如果用户修改了值，势必会影响到其他的。
+ 所以这个函数的原型最好是 `string test(const string& A, const string& B)`

## `std::vector`的用法