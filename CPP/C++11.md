## 原始字符串的字面量

+ 在C++11中添加了原始字符串的字面量，定义方式为：`R"xxx(原始字符串)xxx"`。其中，`()`两边的字符串可以省略。
+ 原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作
+ 示例：
  ```
    #include "test_raw_string.hpp"

    int test_raw_str()
    {
        std::cout << R"path(D:\user\desktop\aaa)path" << std::endl;

        std::cout << R"multi_lines(
            This
            is
            my
            world
            !!!
        )multi_lines" << std::endl;

        return 0;
    }
  ``` 

## 指针空值类型 nullptr

+ 在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为`NULL`，避免产生野指针（没有明确指向的指针，操作野指针可能导致程序发生异常）。
+ C++98和C++03标准中，将一个指针初始化为空指针的方式有两种：
  + `char *ptr = 0;`
  + `char *ptr = NULL;`
+ nullptr 无法隐式转换为整型，但是可以隐式匹配指针类型。在C++11标准下，相比NULL和0，使用nullptr初始化空指针可以令我们编写的程序更加健壮

## constexpr

+ 在C++11之前只有`const`关键字，从功能上来说这个关键字有双重语义：变量只读，修饰常量。

+ `constexpr`，是用来修饰常量表达式或者常量函数
  + 常量函数：返回值是一个常量
  + 常量表达式：多个常量做运算，最终结果还是一个常量

+ C++程序从编写完毕到执行分为四个阶段：预处理，编译，汇编和链接四个阶段，之后得到可执行程序之后就可以运行了。
+ 需要额外强调的是，常量表达式和非常量表达式的计算时机不同
  + 非常量表达式只能在程序运行阶段计算出结果
  + 但是常量表达式的计算往往发生在程序的编译阶段
+ 这可极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间

+ 那么，编译器如何识别表达式是不是常量表达式呢？
  + 在C++11中添加了constexpr关键字之后，就可以在程序中使用它来修改常量表达式，用来提高程序的执行效率。
+ 在使用中建议，将`const`和`constexpr`的功能区分开
  + 凡是表达`只读`语义的场景都使用`const`，
  + 凡是表达`常量`语义的场景都使用`constexpr`

+ 在定义常量时，`const`和`constexpr`是等价的，都可以在程序的编译阶段计算出结果
+ 对于C++内置类型的数据，可以直接用`constexpr`修饰，但如果是自定义的数据类型（用`struct`或者`class`实现），直接用`constexpr`修饰是不行的

---

+ 为了提高C++程序的执行效率，我们可以将程序中，值不需要发生变法的变量定义为常量，也可以使用`constexpr`修饰函数的返回值，这种函数被称作`常量表达式函数`，这些函数主要包括：普通函数/类成员函数，类的构造函数，模板函数

+ 修饰函数：
+ `constexpr`，并不能修改任意函数的返回值，使这些函数称为常量表达式函数，必须要满足以下几个条件
  + 函数必须要有返回值，并且return返回的表达式必须是常量表达式
  + 函数在使用之前，必须有对应的定义语句
  + 整个函数的函数体中，不能出现非常量表达式之外的语句（using指令，typedef语句以及static_assert断言，return语句除外）
+ 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的
+ 示例：
  ```
    constexpr int test_constexpr();

    constexpr int test_constexpr()
    {
        using mytype = int;
        constexpr mytype a = 100;
        constexpr mytype b = 10;
        constexpr mytype c = a * b;

        return c - (a + b);
    }
  ``` 

---

+ 修饰模板函数
+ C++11语法中，constexpr可以修饰模板函数，但是由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。
+ 如果`constexpr`修饰的模板函数实例化结果不满足常量表达式的要求，则`constexpr`会被自动忽略，即该函数就等同于一个普通函数

## auto

+ 可以适用auto自动推导变量的类型，还能够结合decltype来表示函数的返回值

### 1.1 简介

+ 在C++11之前auto和static是对应的，表示自动变量是自动存储的，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋
+ 在C++11中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型

+ 推导规则：
  + C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 占位符，auto 并不是万能的，在任意场景下都能够推导出变量的实际类型。
  + **使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型**
  + 使用语法：
    + `auto variable_name = variable_value;`
  + auto还可以和指针，引用结合起来使用，也可以带上const， volatile限定符，在不同的场景下有对应的推导规则。
  + 推导规则内容如下：
    + 当变量不是指针或者引用类型时，推导的结果不会保留const，volatile关键字
    + 当变量是指针或者引用类型时，推导的结果会保留const，volatile关键字

### 1.2 auto的限制

+ auto关键字并不是万能的，在以下这些场景中是不能完成类型推导的：
  + 不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾
  + 不能用于类的非静态成员变量的初始化。因为非静态成员变量是属于类的对象的，而不是属于类的。
  + 不能使用auto关键字定义数组。定义一个数组，必须给定数组中元素的数据类型
  + 无法使用auto推导出模板参数

### 1.3 auto的应用

+ 下面列举几个比较常用的场景：
  + 用于STL的容器变量。
  + 用于泛型编程

## decltype

+ 在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的decltype关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型
+ 语法格式如下：
  + `decltype (表达式)`
+ decltype， 是`declare type`的缩写，意思是 声明类型。
+ decltype的推导是在编译器完成的，它只是用于表达式类型的推导，并不会计算表达式的值

## 返回类型后置

+ 在泛型编程中，可能需要通过参数的运算来得到返回值的类型
+ 在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导，其语法格式如下：
  + `// 符号 -> 后边跟随的是函数返回值的类型`
  + `auto func(参数1， 参数2，...) -> decltype (参数表达式)`
+ 通过对上述返回类型后置语法代码的分析，得到结论：`auto` 会追踪 `decltype()` 推导出的类型

## final

+ C-C++03.md, final 部分

## override

+ C-C++03.md，override