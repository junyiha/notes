## 原始字符串的字面量

+ 在C++11中添加了原始字符串的字面量，定义方式为：`R"xxx(原始字符串)xxx"`。其中，`()`两边的字符串可以省略。
+ 原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作
+ 示例：
  ```
    #include "test_raw_string.hpp"

    int test_raw_str()
    {
        std::cout << R"path(D:\user\desktop\aaa)path" << std::endl;

        std::cout << R"multi_lines(
            This
            is
            my
            world
            !!!
        )multi_lines" << std::endl;

        return 0;
    }
  ``` 

## 指针空值类型 nullptr

+ 在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为`NULL`，避免产生野指针（没有明确指向的指针，操作野指针可能导致程序发生异常）。
+ C++98和C++03标准中，将一个指针初始化为空指针的方式有两种：
  + `char *ptr = 0;`
  + `char *ptr = NULL;`
+ nullptr 无法隐式转换为整型，但是可以隐式匹配指针类型。在C++11标准下，相比NULL和0，使用nullptr初始化空指针可以令我们编写的程序更加健壮

## constexpr

+ 在C++11之前只有`const`关键字，从功能上来说这个关键字有双重语义：变量只读，修饰常量。

+ `constexpr`，是用来修饰常量表达式或者常量函数
  + 常量函数：返回值是一个常量
  + 常量表达式：多个常量做运算，最终结果还是一个常量

+ C++程序从编写完毕到执行分为四个阶段：预处理，编译，汇编和链接四个阶段，之后得到可执行程序之后就可以运行了。
+ 需要额外强调的是，常量表达式和非常量表达式的计算时机不同
  + 非常量表达式只能在程序运行阶段计算出结果
  + 但是常量表达式的计算往往发生在程序的编译阶段
+ 这可极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间

+ 那么，编译器如何识别表达式是不是常量表达式呢？
  + 在C++11中添加了constexpr关键字之后，就可以在程序中使用它来修改常量表达式，用来提高程序的执行效率。
+ 在使用中建议，将`const`和`constexpr`的功能区分开
  + 凡是表达`只读`语义的场景都使用`const`，
  + 凡是表达`常量`语义的场景都使用`constexpr`

+ 在定义常量时，`const`和`constexpr`是等价的，都可以在程序的编译阶段计算出结果
+ 对于C++内置类型的数据，可以直接用`constexpr`修饰，但如果是自定义的数据类型（用`struct`或者`class`实现），直接用`constexpr`修饰是不行的

---

+ 为了提高C++程序的执行效率，我们可以将程序中，值不需要发生变法的变量定义为常量，也可以使用`constexpr`修饰函数的返回值，这种函数被称作`常量表达式函数`，这些函数主要包括：普通函数/类成员函数，类的构造函数，模板函数

+ 修饰函数：
+ `constexpr`，并不能修改任意函数的返回值，使这些函数称为常量表达式函数，必须要满足以下几个条件
  + 函数必须要有返回值，并且return返回的表达式必须是常量表达式
  + 函数在使用之前，必须有对应的定义语句
  + 整个函数的函数体中，不能出现非常量表达式之外的语句（using指令，typedef语句以及static_assert断言，return语句除外）
+ 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的
+ 示例：
  ```
    constexpr int test_constexpr();

    constexpr int test_constexpr()
    {
        using mytype = int;
        constexpr mytype a = 100;
        constexpr mytype b = 10;
        constexpr mytype c = a * b;

        return c - (a + b);
    }
  ``` 

---

+ 修饰模板函数
+ C++11语法中，constexpr可以修饰模板函数，但是由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。
+ 如果`constexpr`修饰的模板函数实例化结果不满足常量表达式的要求，则`constexpr`会被自动忽略，即该函数就等同于一个普通函数