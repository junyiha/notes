## 错误码

+ `EPERM`	  	` 1`	 Operation not permitted 
+ `ENOENT` 		` 2`	 No such file or directory 
+ `ESRCH`		  ` 3`	 No such process 
+ `EINTR`		  ` 4`	 Interrupted system call 
+ `EIO`		    ` 5`	 I/O error 
+ `ENXIO`		  ` 6`	 No such device or address 
+ `E2BIG`		  ` 7`	 Argument list too long 
+ `ENOEXEC`		` 8`	 Exec format error 
+ `EBADF`		  ` 9`	 Bad file number 
+ `ECHILD`		`10`	 No child processes 
+ `EAGAIN`		`11`	 Try again 
+ `ENOMEM`		`12`	 Out of memory 
+ `EACCES`		`13`	 Permission denied 
+ `EFAULT`		`14`	 Bad address 
+ `ENOTBLK`		`15`	 Block device required 
+ `EBUSY`		  `16`	 Device or resource busy 
+ `EEXIST`		`17`	 File exists 
+ `EXDEV`		  `18`	 Cross-device link 
+ `ENODEV`		`19`	 No such device 
+ `ENOTDIR`		`20`	 Not a directory 
+ `EISDIR`		`21`	 Is a directory 
+ `EINVAL`		`22`	 Invalid argument 
+ `ENFILE`		`23`	 File table overflow 
+ `EMFILE`		`24`	 Too many open files 
+ `ENOTTY`		`25`	 Not a typewriter 
+ `ETXTBSY`		`26`	 Text file busy 
+ `EFBIG`		  `27`	 File too large 
+ `ENOSPC`		`28`	 No space left on device 
+ `ESPIPE`		`29`	 Illegal seek 
+ `EROFS`		  `30`	 Read-only file system 
+ `EMLINK`		`31`	 Too many links 
+ `EPIPE`		  `32`	 Broken pipe 
+ `EDOM`		  `33`	 Math argument out of domain of func 
+ `ERANGE`		`34`	 Math result not representable 

## jsoncpp

### json 概述

+ JSON(`JavaScript Object Notation`, JavaScript 对象表示法) 是一种轻量级的数据交换格式。 
+ JSON是存储和交换文本信息的语法，类似于XML。但它比XML更小，更快，更易解析，易于人阅读和编写。同时也易于机器解析和生成。 
+ 它基于`JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999`的一个子集。 
+ JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括`C, C++, C#, Java, JavaScript, Perl, Python`等）。 
+ 这些特性使JSON成为理想的数据交换语言

+ 要明白，JSON 是一种轻量级的文本数据交换格式而非编程语言，其语法只支持字符串，数值，布尔值及null以及在此基础上的对象和数组，

+ JSON建构于两种结构：
  + “名称/值”对的集合（`A collection of name/value pairs`）,不同的语言中，它被理解为对象（`object`），纪录（`record`），结构（`struct`），字典（`dictionary`），哈希表（`hash table`），有键列表（`keyed list`），或者关联数组 （`associative array`）。
  + 值的有序列表（An ordered list of values）,在大部分语言中，它被理解为数组（`array`）

+ JSON具有以下这些形式：
  + 对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔

#### JSON语法规则

+ 数据在 名称/值对 里面
+ 数据由逗号分隔
+ 大括号保存对象
+ 中括号保存数组

+ JSON名称/值对
  + JSON 数据的书写格式是：名称/值对
  + 名称/值对 包括字段名称（在双引号中），后面写一个冒号，然后是值： `"name":"hello world"`
+ JSON名称（键）必须是字符串
+ JSON值可以是：
  + 数字（整数或浮点数）
  + 字符串（在双引号中）
  + 逻辑值（true 或 false）
  + 数组（在中括号中）
  + 对象（在大括号中）
  + null

+ JSON对象
  + JSON 对象在大括号（{}）中书写
  + 对象可以包含多个名称/值对：   `{"name":"hello world", "url":"www"}`

+ JSON数组
  + JSON 数组在中括号中书写
  + 数组可包含多个对象：`"sites":[{"name":"hello", "url":"www"}, {"name":"world", "url":"www"}]`
    + 对象sites是包含两个对象的数组，每个对象代表一条关于网站(name, url)的记录

+ 访问对象值
  + 可以使用点号来访问对象的值`var myobj,x; myobj = {"name":"json", "alex":1111, "site":"www"}; x = myobj.name;`
  + 可以使用中括号来访问对象的值`var myobj,x; myobj = {"name":"json", "alex":1111, "site":"www"}; x = myobj["name"];`

#### JSON.parse()

+ JSON通常用于与服务端交换数据
+ 在接收服务器数据时，一般是字符串，可以使用JSON.parse()方法将数据交换为JavaScript对象

+ 语法：`JSON.parse(text, reviver);`
+ 参数说明：
  + `text`  -- 一个有效的JSON字符串
  + `reviver` -- 一个转换结果的函数，将为对象的每个成员调用此函数

#### JSON.stringify()

+ JSON 通常用于与服务端交换数据。
+ 在向服务器发送数据时一般是字符串。
+ 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。

+ 语法：`JSON.stringify(value[, replacer[, space]])`
+ 参数说明：
  + `value`  --  要转换的 JavaScript 值（通常为对象或数组）。
  + `replacer` -- 用于转换结果的函数或数组
  + `space`  --  文本添加缩进、空格和换行符

### jsoncpp 详解

+ 开源程序：`libjsoncpp`
+ 地址：`https://github.com/open-source-parsers/jsoncpp`

### jsoncpp 基本用法

+ jsonCpp主要包含三种类型的`class`：`value`、`reader`、`write`。
+ jsonCpp总所有对象、类名都在namespace json中

+ `Json::Value`
  + Json::Value时jsonCpp中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 `Json::ValueType` 枚举值。
  + 在把value插入值后再输出来，输出的值是按字母表的顺序排列。
    + `Json::Value root;`
    + `root["status"] = 1;			//新建一个key为status，赋予数值1`
    + `root["message"] = "OK";		//新建一个key为message，赋予字符串OK`
    + `root["array"].append("arr"); //新建一个key为array，类型为数组，对第一个元素赋值为字符串“arr”`
    + `root["array"].append(1234);  // 为数组 key_array 赋值，对第二个元素赋值为：1234。`
    + `Json::ValueType type = root.type();	//获得root的类型`

+ `Json::Writer`
  + `Json::Writer`负责将内存中的`Value`对象转换成`JSON`文档，输出到文件或者是字符串中
  + Json::Writer是一个纯虚类，不能直接使用，一般使用`Json::Writer`的子类：`Json::FasterWriter`, `Json::StyledWriter`、`Json::StyledStreamWriter`
  + 注：在新版中`Json::FasterWriter`, `Json::StyledWriter`、`Json::Reader`都被弃用，替代的是`Json::StreamWriterBuilder`、`Json::CharReaderBuilder`
    + `Json::FasterWriter`：速度最快
    + `Json::StyledWriter`：格式化后的json

+ `Json::Reader`
  + 用于读取，准确说是用于将字符串或者文件输入流转换为Json::Value对象的
  + `parse()`
  + 使用`Json::Reader`对`json`文件进行解析
    + 原型：`bool parse(const std::string& document, Value& root, bool collectComments = true);`
    + 参数：
      + `root`:（输出）Json::Value的对象
  + 使用Json::Reader对json输入流（文件）进行解析
    + 原型：`bool parse(std:stream& is, Value& root, bool collectComment = true);`
  + 使用Json::Reader对字符串进行解析
    + 原型：`bool parse(const char* beginDoc, const char* ednDoc, Value& root, bool collectComment = true);`

### JsonCpp其他操作

+ 判断key是否存在
  + 原型：`bool Json::Value::isMember ( const char * key) const；`
  + 存在返回1，否则返回0

+ 判断是否为null成员函数
+ 注：Json::Value和C++中的map有一个共同的特点，就是当你尝试访问一个不存在的 key 时，会自动生成这样一个key-value默认为null的值对。

+ 得到所有成员
  + `typedef std::vectorstd::string Json::Value::Members;`
  + `Value::Members Json::Value::getMemberNames ( ) const;`
  + 该函数的类型为一个string的vector。

+ 删除成员
  + `Value Json::Value::removeMember( const char* key)`
  + 返回删除的值，或者null

## sscanf() 正则表达式

+ C++处理字符串的工具函数
  + `strcpy, strcat, strlen, strstr`
  + `sscanf + 正则表达式`

+ 函数声明：`int sscanf(const char *buffer, const char *format, [ argument ]...);`
+ 其中最重要的参数就是`format`，它可以是一个或多个`{%[*][width][{h|I|I64|L}]type|' '|'\t'| '\n'|非%符号}`
+ 常用元字符释义
  + `*`也可以用于格式中, (即 `%*d` 和 `%*s`) 加了星号 (`*`) 表示跳过此数据不读入，也就是不把此数据读入参数中。
  + `{a|b|c}`表示a,b,c中选一，`[d]`表示可以有d也可以没有d
  + width表示读取宽度。
  + `{h | l | I64 | L}`:参数的`size`,通常`h`表示单字节size，`I`表示2字节 size，`L`表示4字节size(double例外)，`l64`表示8字节size。
  + `type`:这一项比较多，就是`%s`、`%d`之类。
  + 特别的：`%*[width] [{h | l | I64 | L}]type` 表示满足该条件的被过滤掉，不会向目标参数中写入值。
  + 未成功匹配返回0 ，否则返回格式化的参数个数。

## 宏定义，宏函数，内置宏，常用宏

+ 在C语言中，变量类型，循环控制，基础语法等与其他高级语言基本无异；
+ 而C语言(C++)特有的两把双刃剑--指针和宏定义/宏函数，使得C/C++在底层开发中披荆斩棘，无所不能

### 常用宏定义

+ 防止一个头文件被重复包含
  + `#ifndef ICE_BASE_HPP`
  + `#define ICE_BASE_HPP`
  + `#endif  //ICE_BASE_HPP`

+ 重新定义一些类型，防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。
  + `typedef  unsigned long int  uint32;      	/* Unsigned 32 bit value */`

### 内置宏

+ ANSI标准
  + `__LINE__`
  + `__FILE__`
  + `__DATE__`
  + `__TIME__`
  + `__TIME__`
  + `__STDC__`

### `__BEGIN_DECLS`

+ 许多头文件中都有：
  + 文件开头有`__BEGIN_DECLS`
  + 文件结尾有`__END_DECLS`

+ 它们是两个宏定义，原型为：
  + `#define __BEGIN_DECLS extern "C"{`
  + `#define __END_DECLS   }`

## sys/epoll.h

### epoll_create()

+ 功能：创建一个关联`size`个文件的epoll实例
+ 原型：`int epoll_create(int size);`
+ 参数：
  + `size`  --  关联文件的个数
+ 返回值：
  + 成功  --  返回一个文件描述符`fd`
  + 失败  --  

### epoll_create1()

+ 功能：创建一个标记为`flag`的epoll实例
+ 原型：`int epoll_create1(int flags);`
+ 参数：
  + `flag`  --  
+ 返回值：
  + 成功  --  返回一个文件描述符
  + 失败  --  
+ 注意：
  + 与epoll_create()一样，只不过size参数弃用了

### epoll_ctl()

+ 功能：修改一个`epfd` epoll实例
+ 原型：`int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `op`    --  要执行的行为
    + `/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */`
    + `#define EPOLL_CTL_ADD 1	/* Add a file descriptor to the interface.  */`
    + `#define EPOLL_CTL_DEL 2	/* Remove a file descriptor from the interface.  */`
    + `#define EPOLL_CTL_MOD 3	/* Change file descriptor epoll_event structure.  */`
  + `fd`    --  操作的目标
  + `event` --  用户数据和触发该调用的事件
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1，并设置errno

### epoll_wait()

+ 功能：在一个epoll实例`opfd`中等待某一事件发生
+ 原型：`int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `events` -- 指向存放触发事件的缓冲区的结构体指针
  + `maxevents`  --  返回事件的最大数量
  + `timeout`  --  超时时间
+ 返回值：
  + 成功  --  返回触发事件在缓冲区`events`中的数字
  + 失败  --  返回-1，并设置errno

### epoll_pwait()

+ 功能：和`epoll_wait()`相似，增加了信号掩码，临时且原子
+ 原型：`int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *ss);`
+ 参数：
  + `epfd`  --  要操作的epoll实例
  + `events` -- 指向存放触发事件的缓冲区的结构体指针
  + `maxevents`  --  返回事件的最大数量
  + `timeout`  --  超时时间
  + `ss`   --  信号集指针
+ 返回值：
  + 成功  --  返回触发事件在缓冲区`events`中的数字
  + 失败  --  返回-1，并设置errno

## sys/socket.h

+ 套接字常量、类型和函数的声明。

### socket()

+ 功能：创建一个`type`类型，`domain`协议簇，`protocol`通信协议的socket，并返回一个文件描述符
+ 原型：`int socket(int domain, int type, int protocol);`
+ 参数：
  + `domain`  --  选择所用的协议族
    + `AF_INET`，代表IPv4
    + `AF_INET6`，代表IPv6
  + `type`    --  
    + `SOCK_STREAM`, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现
    + `SOCK_DGRAM`,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现
  + `protocol` -- 指定特定的通信type使用的协议。
    + 在大多数实现中，每个type参数只能使用一种协议。
    + `SOCK_STREAM`,使用`IPPROTO_TCP`
    + `SOCK_DGRAM`, 使用`IPPROTO_UDP`
    + 如果参数为0，则默认设置为1
+ 返回值：
  + 成功  --  返回文件描述符
  + 失败  --  

### socketpair()

+ 功能：创建两个`type`类型，`domain`协议簇，`protocol`通信协议的，互相连接的socket，将文件描述符放在`fds[0]`和`fds[1]`
+ 原型：`int socketpair(int domain, int type, int protocol, int fds[2]);`
+ 参数：
  + `domain`  --  选择所用的协议族
    + `AF_INET`，代表IPv4
    + `AF_INET6`，代表IPv6
  + `type`    --  
    + `SOCK_STREAM`, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现
    + `SOCK_DGRAM`,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现
  + `protocol` -- 指定特定的通信type使用的协议。
    + 在大多数实现中，每个type参数只能使用一种协议。
    + `SOCK_STREAM`,使用`IPPROTO_TCP`
    + `SOCK_DGRAM`, 使用`IPPROTO_UDP`
    + 如果参数为0，则默认设置为1
  + `fds[2]`  --  存放两个文件描述符的数组  --  Input/Output
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1

### bind()

+ 功能：将套接字通信端点的句柄(`socket FD`)与一个特定的逻辑网络连接关联起来
+ 原型：`int bind(int fd, const struct sockaddr *address, socklen_t address_len);`
+ 参数：
  + `fd`       --  通信端点的文件描述符
  + `address`  --  关联的地址
  + `len`      --  地址字节长度(the local address which is LEN bytes long)
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1，并设置errno

### getsockname()

+ 功能：通过本地文件描述符的地址和长度(单位:byte)，获取socket名字
+ 原型：`int getsockname(int fd, const struct sockaddr *address, socklent *len);`
+ 参数：
  + `fd`  --  文件描述符
  + `address`  --  地址
  + `len`      --  长度
+ 返回值：
  + 成功  -- 
  + 失败  --  

### connect()

+ 功能：创建一个socket文件描述符和地址的连接
+ 原型：`int connect(int fd, const struct sockaddr *addr, socklent_t len);`
+ 参数：
  + `fd`  --  文件描述符
  + `addr` --  要连接的地址
  + `len`  --  地址的长度(单位：字节)
+ 返回值：  
  + 成功  --  返回0
  + 失败  --  返回-1

### recv()

+ 功能：从socket FD中读取N个字节，并输入到BUF中
+ 原型：`ssize_t recv(int fd, void *buf, size_t n, int flags);`
+ 参数：
  + `fd`  --  文件描述符
  + `buf` --  要存放的缓冲区
  + `n`   --  读取的数据大小
  + `flags` --  
+ 返回值：
  + 成功  --  返回读取的字节数
  + 失败  --  返回-1

### sendto()

+ 功能：在socket FD上向地址ADDR(长度为ADDR_LEN)发送N个字节的BUF
+ 原型：
  + `ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);`
+ 参数：
+ 返回值：
  + 成功  --  返回发送的字节数
  + 失败  --  返回-1

### recvfrom()

+ 功能：通过socket FD读取N个字节到BUF
+ 原型：`ssize_t recvfrom(int fd, void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);`
+ 参数：
+ 返回值：
  + 成功  --  返回读取的字节数
  + 失败  --  返回-1
+ 注意：
  + 如果ADDR不为空，将其`*ADDR_LEN`字节填充为发送方的地址，并将地址的实际大小存储在`*ADDR_LEN`中。返回读取的字节数或-1错误

### sendmsg()

+ 功能：在socket FD上发送一个由MESSAGE描述的信息
+ 原型：`ssize_t sendmsg(int fd, const struct msghdr *message, int flags);`
+ 参数：
+ 返回值：
  + 成功  --  返回发送的字节数
  + 失败  --  返回-1

### recvmsg()

+ 功能：从socket FD接收一个由MESSAGE描述的信息
+ 原型：`ssize_t recvmsg(int fd, struct msghdr *message, int flags);`
+ 参数：
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### getsockopt()

+ 功能：将套接字`FD`的选项`OPTNAME`在协议级别`level`上的当前值放入`OPTVAL` (`*OPTLEN`字节长)，并将`*OPTLEN`设置为该值的实际长度
+ 原型：`int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### setsockopt()

+ 功能：设置套接字FD的选项OPTNAME在协议级别level为*OPTVAL (OPTLEN字节长)
+ 原型：`int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### listen()

+ 功能：准备接受套接字FD上的连接。在进一步的请求被拒绝之前，将有N个连接请求排队
+ 原型：`int listen(int fd, int n);`
+ 返回值：
  + 成功  --  返回接收到的字节数
  + 失败  --  返回-1

### accept()

+ 功能：在套接字FD上等待连接.
  + 当连接到达时，打开一个新的套接字与之通信，将`*ADDR (*ADDR_LEN字节长)`设置为连接对等体的地址，将`*ADDR_LEN`设置为地址的实际长度，
  + 并返回新套接字的描述符，错误则返回-1
+ 原型：`int accept(int fd, const struct sockaddr *addr, socklen_t *addr_len);`
+ 返回值：
  + 成功  --  新套接字的描述符
  + 失败  --  返回-1

### shutdown()

+ 功能：关闭套接字FD上打开的全部或部分连接
+ 原型：`int shutdown(int fd, int how);`
+ 参数：
  + `fd`  --  套接字文件描述符
  + `how`  --
    + `SHUT_RD`  --  不再接收连接
    + `SHUT_WR`  --  不再传输数据
    + `SHUT_RDWR`  --  不再传输数据和接收连接
+ 返回值：
  + 成功  --  返回0
  + 失败  --  返回-1

## bits/socket.h

+ 特定于系统的套接字常量和类型
+ 这个特定于操作系统的头文件定义了`SOCK_*`、`PF_*`、`AF_*`、`MSG_*`、`SOL_*`和`SO_*`常量，以及`struct sockaddr `、`struct msghdr `和`struct linger `类型。

### struct sockaddr

+ 简述：描述通用套接字地址的结构
+ 声明：
  ```
    struct sockaddr
      {
        __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  地址族 */
        char sa_data[14];		/* Address data.  14字节，包含套接字中的目标地址和端口信息    */
      };
  ```
+ 注意：
  + 结构体用来处理网络通信的地址。
  + sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了，

## netinet/in.h

+ 网络协议相关数据结构的声明和定义

+ 简述：描述因特网套接字地址的结构
+ 声明：
  ```
    struct sockaddr_in
      {
        __SOCKADDR_COMMON (sin_);   /* Address Family.   地址族 */
        in_port_t sin_port;			    /* Port number.      16位TCP/UDP端口号 */
        struct in_addr sin_addr;		/* Internet address. 32位IP地址  */

        /* Pad to size of `struct sockaddr'.  不使用*/
        unsigned char sin_zero[sizeof (struct sockaddr) -
    			   __SOCKADDR_COMMON_SIZE -
    			   sizeof (in_port_t) -
    			   sizeof (struct in_addr)];
      };
  ```
+ 注意：
  + 结构体用来处理网络通信的地址。
  + 该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中
  + 该结构体中提到的另一个结构体in_addr定义如下
     ```
        /* Internet address.  */
        typedef uint32_t in_addr_t;
        struct in_addr
          {
            in_addr_t s_addr;
          };
     ```
  + `sin_port`和`sin_addr`都必须是网络字节序（`NBO`），一般可视化的数字都是主机字节序（`HBO`）

## sockaddr_in和sockaddr

+ 二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。
+ 二者是并列结构，指向`sockaddr_in`结构的指针也可以指向`sockaddr`

+ `sockaddr`常用于`bind`、`connect`、`recvfrom`、`sendto`等函数的参数，指明地址信息，是一种通用的套接字地址。
+ `sockaddr_in` 是internet环境下套接字的地址形式。所以在网络编程中我们会对`sockaddr_in`结构体进行操作，使用`sockaddr_in`来建立所需的信息，最后使用类型转化就可以了。

+ 一般先把`sockaddr_in`变量赋值后，强制类型转换后传入用`sockaddr`做参数的函数：
  + `sockaddr_in`用于socket定义和赋值；
  + `sockaddr`用于函数参数

+ 另外 -- 两个函数 htons() 和 inet_addr()
  + `htons()`作用是将端口号由主机字节序转换为网络字节序的整数值。(`host to net`)
  + `inet_addr()`作用是将一个`IP`字符串转化为一个网络字节序的整数值，用于`sockaddr_in.sin_addr.s_addr`
  + `inet_ntoa()`作用是将一个`sin_addr`结构体输出成`IP`字符串(`network to ascii`)，例如
    + `printf("%s",inet_ntoa(mysock.sin_addr));`
  + `htonl()`作用和`htons()`一样，不过它针对的是32位的（`long`），而`htons()`针对的是两个字节，16位的（`short`）
  + 与`htonl()`和`htons()`作用相反的两个函数是：`ntohl()`和`ntohs()`
  + 它们的声明都在文件`netinet/in.h`中

## bits/sockaddr.h

+ `struct sockaddr_*`通用成员和大小的定义，通用版本。

+ `#define	__SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix##family`
+ 这个宏用于声明用于套接字地址的数据类型的初始公共成员，`struct sockaddr `、`struct sockaddr_in `、`struct sockaddr_un `等。

## arpa/inet.h

### inet_addr()

+ 简述：将互联网主机地址从数字和点符号在CP转换成二进制数据在网络字节顺序
+ 声明：`in_addr_t inet_addr (const char *cp);`
+ 参数：
+ 返回值：

### inet_lnaof()

+ 简述：在`in`返回Internet地址的本地主机地址部分。
+ 声明：`in_addr_t inet_lnaof(struct in_addr in);`
+ 参数：
+ 返回值：

### inet_makeaddr()

+ 简述：将网络编号NET与本机地址主机相结合，使Internet主机地址按网络字节序排列
+ 声明：`struct in_addr inet_makeaddr (in_addr_t net, in_addr_t host);`
+ 参数：
+ 返回值：

### inet_netof()

+ 简述：返回网络号码部分的互联网地址
+ 声明：`in_addr_t inet_netof (struct in_addr in);`
+ 参数：
+ 返回值：

### inet_network()

+ 简述：从CP开始的数字加点格式的地址中提取网络字节顺序的网络号
+ 声明：`in_addr_t inet_network (const char *cp);`
+ 参数：
+ 返回值：

### inet_ntoa()

+ 简述：将`in`中的因特网数字转换为`ASCII`表示。返回值是一个指向包含该字符串的内部数组的指针
+ 声明：`char *inet_ntoa (struct in_addr in);`
+ 参数：
+ 返回值：

### inet_pton()

+ 简述：从CP开始的缓冲区中Internet数字的表示格式转换为二进制网络格式，并将接口类型AF的结果存储在从BUF开始的缓冲区中
+ 声明：`int inet_pton (int af, const char *cp, void *buf);`
+ 参数：
+ 返回值：

## strings.h

### bcmp()

+ 简述：比较S1和S2的N个字节(与memcmp相同)
+ 声明：`int bcmp (const void *s1, const void *s2, size_t n);`
+ 参数：
+ 返回值：

### bcopy()

+ 简述：复制N字节的SRC到DEST(类似于memmove，但参数是相反的)
+ 声明：`int bcopy (const void *src, void *dest, size_t n);`
+ 参数：
+ 返回值：

### bzero()

+ 简述：设置S的N个字节为0
+ 声明：`void bzero (void *s, size_t n);`
+ 参数：
+ 返回值：

### ffs()

+ 简述：返回`I`中设置的第一个比特位的位置，如果没有设置，则返回0。最低有效位是位置1，最高有效位是32
+ 声明：`int ffs (int i);`
+ 参数：
+ 返回值：

### strcasecmp()

+ 简述：比较参数s1和s2字符串，比较时会自动忽略大小写的差异
+ 声明：`extern int strcasecmp (const char *s1, const char *s2)`
+ 参数：
  + `__s1`  -- 字符指针s1
  + `__s2`  -- 字符指针s2
+ 返回值：
  + 若参数s1和s2字符串相等则返回0；
  + s1大于s2，则返回大于0的值；
  + s1小于s2则返回小于0的值
  
### strncasecmp()

+ 简述：用来比较参数s1和s2字符串前n各字符，比较时会自动忽略大小写的差异
+ 声明：` int strncasecmp (const char* s1, const char* s2, size_t n);`
+ 参数：
  + `s1`  -- 字符指针s1
  + `s2`  -- 字符指针s2
  + `n`   -- 字符数n
+ 返回值
  + 如果参数s1和s2字符串相同，则返回0
  + s1若大于s2，则返回大于0的值
  + s1若小于s2，则返回小于0的值

### strcasecmp_l()

+ 简述：使用LOC中的排序规则比较S1和S2，忽略大小写
+ 声明：`int strcasecmp_l (const char *s1, const char *s2, locale_t loc);`
+ 参数：
+ 返回值：

### strncasecmp_l()

+ 简述：使用LOC中的排序规则，不超过N个字符的S1和S2进行比较，忽略大小写
+ 声明：`int strncasecmp_l (const char *s1, const char *s2, size_t n, locale_t loc);`
+ 参数：
+ 返回值：