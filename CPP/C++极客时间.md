## 堆，栈，RAII

+ 内存管理的基本概念，大致的学习路径是：
  + 先讲堆和栈，
  + 然后讨论C++的特色功能RAII

### 1.1 基本概念

+ 堆，英文是heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手动释放，否则就会造成内存泄漏。

+ C++标准里有一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：
  + new 和 delete 操作的区域是 free store
  + malloc 和 free 操作的区域是 heap
+ 但 new 和 delete通常底层使用malloc和free来实现，所以free store也是heap。

+ 栈，英文是stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”(last-in-first-out 或 LIFO)

+ RAII, 完整的英文是 Resource Acquisition Is Initialization，是C++所特有的资源管理方式。由少量其他语言，例如D，Ada和Rust也采纳了RAII，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的
+ RAII依托栈和析构函数，来对所有的资源--包括堆内存在内--进行管理。对RAII的使用，使得C++不需要类似于Java那样的垃圾收集方法，也能有效地对内存进行管理。RAII的存在，也是垃圾收集虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。

### 1.2 深入探讨 -- 堆

+ 从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情。
+ 从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性 --  内存分配耗时需要多久？失败了怎么办？等等。至今仍有很多场合会禁用动态内存，尤其是在实时性要求比较高的场合，例如飞行控制器和电信设备。

+ 在堆上分配内存，有些语言可能使用new这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。
+ 不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作
  + 让内存管理器分配一个某个大小的内存块
  + 让内存管理器释放一个之前分配的内存款
  + 让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放
+ C++通常会做上面的操作1和2
+ Java会做上面的操作1和3
+ Python会做上面的操作1，2，3
+ 这是语言的特性和实现方式决定的。

+ 需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。
+ 幸运的是，内存分配和释放的管理，是内存管理器的任务。一般情况下我们不需要介入。我们只需要正确地使用new和delete。每个new出来的对象都应该用delete来释放。

### 1.3 深入探讨 -- 栈

+ 函数调用，本地变量使用栈。这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。

+ 栈是向上增长的。在包括x86在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。
+ 当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存功能，然后会调用栈指针，分配出本地变量所需要的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。

+ 注意到了吗：本地变量所需要的内存就在栈上，跟函数执行所需要的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。
+ 我们可以看到：
  + 栈上的分配极为简单，移动一下栈指针而已
  + 栈上的释放也极为简单，函数执行结束时移动一下栈指针即可
  + 由于后进先出的执行过程，不可能出现内存碎片。

+ 顺便说一句，（图2）每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧(stack frame)。
+ GCC 和 Clang 的命令行参数中提到 frame 的，例如`-fomit-frame-pointer`，一般就是指栈帧。

---

+ 前面例子的本地变量是简单类型，C++里称之为POD类型(Plain Old Data)。
+ 对于有构造和析构函数的非POD类型，栈上的内存分配也同样有效，只不过C++编译器会在生成代码的合适位置，插入对构造和析构函数的调用。
+ 这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。
+ 在发生异常时对析构函数的调用，还有一个专门的术语，叫做栈展开(stack unwinding)。

+ 在C++里，所有的变量缺省都是值语义 --  如果不使用 * 和 & 的话，变量不会像Java或Python一样引用一个堆上的对象。对于像智能指针这样的类型，写`ptr->call()`和`ptr.get()`，语法上都是对的，并且`->`和`.`有着不同的语法作用。而在大部分其他语言中，访问成员只有`.`，但在作用上实际等价于C++的`->`。
+ 这种值语义和引用语义的区别，是C++的特点，也是它的复杂性的一个来源。要用好C++，就需要理解它的值语义的特点。

### 1.4 深入探讨 -- RAII

+ C++支持将对象存储在栈上面。但是，在很多情况下，对象不能，或者不应该，存储在栈上。例如：
  + 对象很大
  + 对象的大小在编译时不能确定
  + 对象是函数的返回值，但由于特殊的原因，不应该使用对象的值返回。

+ 常见情况之一是：在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。
+ 举例：---。 这个create_shape方法会返回一个shape对象，对象的实际类型是某个shape的子类。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是shape，实际却返回一个circle，编译器不会报错，但结果多半是错的。这种现象叫做对象切片(object slicing)，是C++特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是C++的一个陷阱

+ 那么，我们怎样才能确保，在使用create_shape的返回值时不会发生内存泄漏呢？
+ 答案就是：在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。
+ 如果好奇delete空指针会发生什么的话，那答案是，这是一个合法的空操作。在new一个对象和delete一个指针时编译器需要干不少活的
  + 也就是说，new的时候先分配内存（失败时整个操作失败并向外抛出异常，通常使bad_alloc），然后在这个结果指针上构造对象；
  + 构造成功则new操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。
  + delete时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存

+ 在析构函数里做必要的清理工作，这就是RAII的基本用法。
+ 这种清理并不限于释放内存，也可以是：
  + 关闭文件（fstream的析构就会这么做）
  + 释放同步锁
  + 释放其他重要的系统资源

### 1.5 小结

+ 讨论了C++里内存管理的一些基本概念，强调栈是C++里最自然的内存使用方式，并且，使用基于栈和析构函数的RAII，可以有效地对包括内存在内的系统资源进行统一管理。

## C++的智能指针

+ 使用智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。
+ 智能指针本质上并不神秘，其实就是RAII资源管理功能的自然展现而已。

### 1.1 模板化和易用性

+ 要让某一个类能够包装任意类型的指针，我们需要把它变成一个类模板。
+ 在示例中，和shape_wrapper比较一下，我们就是在开头增加模板声明`template <typename T>`，然后把代码中的shape替换成模板参数T而已。

### 1.2 拷贝构造和赋值

+ 拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键它还不是实现问题，而是我们该如何定义其行为。

+ 使用智能指针的目的就是要减少对象的拷贝。
+ 一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。
+ 方法一：
  + 在拷贝时转移指针的所有权。在赋值函数中，通过拷贝构造产生一个临时对象并调用swap来交换指针的所有权。这种惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；二第一步如果发生异常的话，this对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。
  + 这个语义本质上就是C++98的auto_ptr的定义。但是auto_ptr在C++17时已经被正式从C++标准中删除了

### 1.3 移动指针

+ 把拷贝构造函数中的参数类型`smart_ptr*`改成了`smart_ptr&&`，现在它成了移动构造函数
+ 把赋值函数中的参数类型`smart_ptr&`改成了`smart_ptr`，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为时移动还是拷贝，完全依赖于构造函数时走的是移动构造还是拷贝构造。

+ 根据C++的规则，如果我们提供了移动构造函数，而没有手动提供拷贝构造函数，那么后者自动被禁用
+ 记住，C++里哪些复杂的规则也是为方便编程而设立的。

+ 这也是C++11的unique_ptr的基本行为。

### 1.4 子类指针向基类指针的转换

### 1.5 引用计数

+ unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr 所拥有，这显然不能满足所有使用场合的需求。
+ 一种常见的情况是：多个智能指针同时拥有一个对象；当他们全部都失效时，这个对象也同时会被删除。这也就是`shared_ptr`了

+ 多个不同的`shared_ptr`不仅可以共享一个对象，在共享同一对象时也需要同时共享一个计数。
+ 当最后一个指向对象（和共享计数）的shared_ptr析构时，它需要删除对象和共享计数。

### 1.6 指针类型转换

+ 对应于C++里的不同的类型强制转换：
  + `static_cast`
  + `reinterpret_cast`
  + `const_cast`
  + `dynamic_cast`

+ 只能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。

## 右值和移动 究竟解决了什么问题？

+ 移动语义是C++11里引入的一个重要概念；理解这个概念，是理解很多现代C++里的优化的基础。

### 1.1 值分左右

+ 我们常常会说，C++里有左值和右值。标准里的定义实际更加复杂，规定了下面这些值类别(value categories)
  + 一个 lvalue 是通常可以放在等号左边的表达式，左值
  + 一个 rvalue 是通常只能放在等号右边的表达式，右值
  + 一个 glvalue 是 generalized lvalue， 广义左值
  + 一个 xvalue 是 expiring value， 将亡值
  + 一个 prvalue 是 pure rvalue， 纯右值

+ 我们暂且抛开这些概念，只看其中两个：lvalue 和 prvalue

+ 左值 lvalue 是有标识符，可以取地址的表达式，最常见的情况有：
  + 变量，函数或数据成员的名字
  + 返回左值引用的表达式，例如`++x, x = 1, cout << ' '`
  + 字符串字面量，例如`"hello world"`
+ 在函数调用时，左值可以绑定到左值引用的参数，例如`T&`。一个常量只能绑定到常左值引用，例如`const T&`

+ 反之，纯右值 prvalue 是没有标识符，不可以取地址的表达式，一般也称之为 临时对象。最常见的情况有：
  + 返回非引用类型的表达式，例如`x++`, `x+1`, `make_shared<int>(42)`
  + 除字符串字面量之外的字面量，例如`42`, `true`

---

+ 在C++11之前，右值可以绑定到常左值引用(const lvalue reference)的参数，例如`const T&`，但不可以绑定到非常左值引用(non-const lvalue reference)，例如`T&`
+ 从C++11开始，C++语言里多了一种引用类型 --  右值引用。右值引用的形式是`T&&`，比左值引用多了一个`&`符号。跟左值引用一样，我们可以使用 const 和 volatile 来修饰，但最常见的情况是，我们不会用 const 和 volatile 来修饰右值。

+ 引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能。
+ 由于C++有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。

+ 对于指针，我们通常使用值传递，并不关心它是左值还是右值
+ `std::move(ptr)`，它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在这里`std::move(ptr1)`等价于`static_cast<smart_ptr<shape>&&>(ptr1)`。因此，`std::move(ptr1)`的结果是指向ptr1的一个右值引用，这样构造ptr2时就会选择上面第二个重载。

+ 我们可以把`std::move(ptr1)`看作是一个有名字的右值。为了跟无名的纯右值prvalue相区别，C++里目前就把这种表达式叫做xvalue。跟左值lvalue不同，xvalue仍然是不能取地址的--这点上，xvalue和prvalue相同。所以，xvalue和prvalue都被归为右值rvalue。

---

+ 另外，需要注意的是：值类别(value category) 和 值类型(value type)， 是两个看似相似，却毫不相干的术语。
  + 前者指的是上面这些左值，右值相关的概念
  + 后者则是与引用类型(reference type)相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。
+ 在C++里，所有的原生类型，枚举，结构，联合，类都代表值类型，只有引用`&`和指针`*`才是引用类型。（在Java里，数字等原生类型是值类型，类则属于引用类型。在Python里，一切类型都是引用类型。）

### 1.2 生命周期和表达式类型

+ 一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。
+ 那么临时对象(prvalue)呢？
+ 在这儿，C++的规则是：
  + 一个临时对象会在包含这个临时对象的完整表达式估值完成后，按生成顺序的逆序被销毁，除非有生命周期延长发生。

+ 临时对象最后生成，最先析构
+ 为了方便对临时对象的使用，C++对临时对象有特殊的生命周期延长规则，这条规则是：
  + 如果一个prvalue被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长

### 1.3 移动的意义

+ 上面谈了一些语法知识。就跟学外语的语法一样，这些内容是比较枯燥的。虽然这些知识有时有用，但往往要回过头来看的时候才觉得。初学之时，更重要的是理解为什么，和熟练掌握基本的用法。

+ 对于smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销：在引用计数指针的场景下，这个开销并不大。
+ 移动构造和拷贝构造的差异仅在于：
  + 少了一次`other.shared_count_->add_count()`的调用
  + 被移动的指针被清空，因而析构时也少了一次`shared_count_->reduce_count()`的调用

+ 在使用容器类的情况下，移动更有意义。
+ `string result = string("Hello, ") + name + ".";`
  + 在C++11之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外的开销
  + 既然C++是一门追求性能的语言，一个合格的C++程序员会写：
    ```
      string result = "Hello, ";
      result += name;
      result += ".";
    ``` 
  + 这样的话，只会调用构造函数一次和`string::operator+=`两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。
  + 但是，从C++11开始，这就不再是必须的。同样上面那个单行的语句，性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。

---

+ 此外，很关键的额一点是，C++里的对象缺省都是值语义。在下面这样的代码里：
  ```
    class A {
      B b_;
      C c_;
    };
  ``` 
+ 从实际内存布局的角度，很多语言：例如Java和Python，会在A对象里放B和C的指针（虽然这些语言里本身没有指针的概念）。而C++则会直接把B和C对象放在A的内存空间里。
+ 这种行为既是优点也是缺点：
  + 优点：是因为它保证了内存访问的局域性，而局域型在现在处理器架构上是聚堆具有性能优势的
  + 缺点：是因为复制对象的开销大大增加，在Java类语言里复制的是指针，在C++里是完整的对象。这就是为什么C++需要移动语义这一优化，而Java类语言里则根本不需要这个概念。

+ 一句话总结：
  + 移动语义使得在C++里返回大对象（如容器）的函数和运算符称为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。
  + 所有的现代C++的标准容器都针对移动进行了优化。

### 1.4 如何实现移动

+ 要让你设计的对象支持移动的话，通常需要下面几步：
  + 你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝，例如unique_ptr）
  + 你的对象应该有swap成员函数，支持和另外一个对象快速交换成员
  + 在你的对象的名空间下，应当有一个全局的swap函数，调用成员函数swap来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的swap函数
  + 实现通用的`operator=`
  + 上面各个函数如果不抛异常的化，应当标为`noexcept`。这对移动构造函数尤为重要。

### 1.5 不要返回本地变量的引用

+ 有一种常见的C++编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出现任何奇怪的行为都是正常的。

+ 在C++11之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化(named return value optimization, 或NRVO)能把对象直接构造到调用者的栈上。
+ 从C++11开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用`std::move`进行干预：使用`std::move`对于移动行为没有帮助，反而会影响返回值优化

### 1.6 引用坍缩和完美转发

+ 引用坍缩（又称 引用折叠）。这个概念在泛型编程中是一定会碰到的
+ 对于一个实际的类型T，它的左值引用是`T&`，右值引用是`T&&`，那么
  + 是不是看到`T&`，就一定是一个左值引用？
  + 是不是看到`T&&`，就一定是一个右值引用？
+ 对于前者的回答为：是；对于后者的回答为：否

+ 关键在于，在有模板的代码里，对于类型参数的推到结果可能是引用。我们可以略过一些繁复的语法规则，要点是：
  + 对于`template <typename T> foo(T&&)`这样的代码，如果传递过去的参数是左值，T的推到结果是左值引用；如果传递过去的参数是右值，T的推到结果是参数的类型本身
  + 如果T是左值引用，那T&&的结果仍然是左值引用：即`type& &&`坍缩成了`type&`
  + 如果T是一个实际类型，那`T&&`的结果自然就是一个右值引用
+ 我们之前提到过，右值引用变量仍然会匹配到左值引用上去

+ 事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值的仍然是左值，右值的仍然是右值。
+ 这个功能在C++标准库中已经提供了，叫`std::forward`。它和`std::move`一样都是利用引用坍缩机制来实现。
+ 此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个bar函数简化成：
  ```
    template <typename T>
    void var(T&& s)
    {
      foo(std::forward<T>(s));
    }
  ``` 
+ 对于下面这样的代码：
  ```
    circle temp;
    bar(temp);
    bar(circle());
  ```
+ 现在的输出是：
  + `foo(const shape&)`
  + `foo(shape&&)`
+ 因为在T是模板参数时，`T&&`的作用主要是保持值类别进行转换，它有个名字就叫做 转发引用(forwarding reference)。因为既可以是左值引用，也可以是右值引用，它也曾经被称为 万能引用(universal reference)

### 1.7 小结

+ 介绍了C++里的值类别，重点介绍了临时变量，右值引用，移动语义和实际的编程用法
+ 由于这是C++11里的重点功能，对于其基本用法需要牢牢掌握
