## 堆，栈，RAII

+ 内存管理的基本概念，大致的学习路径是：
  + 先讲堆和栈，
  + 然后讨论C++的特色功能RAII

### 1.1 基本概念

+ 堆，英文是heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手动释放，否则就会造成内存泄漏。

+ C++标准里有一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：
  + new 和 delete 操作的区域是 free store
  + malloc 和 free 操作的区域是 heap
+ 但 new 和 delete通常底层使用malloc和free来实现，所以free store也是heap。

+ 栈，英文是stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”(last-in-first-out 或 LIFO)

+ RAII, 完整的英文是 Resource Acquisition Is Initialization，是C++所特有的资源管理方式。由少量其他语言，例如D，Ada和Rust也采纳了RAII，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的
+ RAII依托栈和析构函数，来对所有的资源--包括堆内存在内--进行管理。对RAII的使用，使得C++不需要类似于Java那样的垃圾收集方法，也能有效地对内存进行管理。RAII的存在，也是垃圾收集虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。

### 1.2 深入探讨 -- 堆

+ 从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情。
+ 从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性 --  内存分配耗时需要多久？失败了怎么办？等等。至今仍有很多场合会禁用动态内存，尤其是在实时性要求比较高的场合，例如飞行控制器和电信设备。

+ 在堆上分配内存，有些语言可能使用new这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。
+ 不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作
  + 让内存管理器分配一个某个大小的内存块
  + 让内存管理器释放一个之前分配的内存款
  + 让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放
+ C++通常会做上面的操作1和2
+ Java会做上面的操作1和3
+ Python会做上面的操作1，2，3
+ 这是语言的特性和实现方式决定的。

+ 需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。
+ 幸运的是，内存分配和释放的管理，是内存管理器的任务。一般情况下我们不需要介入。我们只需要正确地使用new和delete。每个new出来的对象都应该用delete来释放。

### 1.3 深入探讨 -- 栈

+ 函数调用，本地变量使用栈。这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。

+ 栈是向上增长的。在包括x86在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。
+ 当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存功能，然后会调用栈指针，分配出本地变量所需要的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。

+ 注意到了吗：本地变量所需要的内存就在栈上，跟函数执行所需要的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。
+ 我们可以看到：
  + 栈上的分配极为简单，移动一下栈指针而已
  + 栈上的释放也极为简单，函数执行结束时移动一下栈指针即可
  + 由于后进先出的执行过程，不可能出现内存碎片。

+ 顺便说一句，（图2）每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧(stack frame)。
+ GCC 和 Clang 的命令行参数中提到 frame 的，例如`-fomit-frame-pointer`，一般就是指栈帧。

---

+ 前面例子的本地变量是简单类型，C++里称之为POD类型(Plain Old Data)。
+ 对于有构造和析构函数的非POD类型，栈上的内存分配也同样有效，只不过C++编译器会在生成代码的合适位置，插入对构造和析构函数的调用。
+ 这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。
+ 在发生异常时对析构函数的调用，还有一个专门的术语，叫做栈展开(stack unwinding)。

+ 在C++里，所有的变量缺省都是值语义 --  如果不使用 * 和 & 的话，变量不会像Java或Python一样引用一个堆上的对象。对于像智能指针这样的类型，写`ptr->call()`和`ptr.get()`，语法上都是对的，并且`->`和`.`有着不同的语法作用。而在大部分其他语言中，访问成员只有`.`，但在作用上实际等价于C++的`->`。
+ 这种值语义和引用语义的区别，是C++的特点，也是它的复杂性的一个来源。要用好C++，就需要理解它的值语义的特点。

### 1.4 深入探讨 -- RAII

+ C++支持将对象存储在栈上面。但是，在很多情况下，对象不能，或者不应该，存储在栈上。例如：
  + 对象很大
  + 对象的大小在编译时不能确定
  + 对象是函数的返回值，但由于特殊的原因，不应该使用对象的值返回。

+ 常见情况之一是：在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。
+ 举例：---。 这个create_shape方法会返回一个shape对象，对象的实际类型是某个shape的子类。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是shape，实际却返回一个circle，编译器不会报错，但结果多半是错的。这种现象叫做对象切片(object slicing)，是C++特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是C++的一个陷阱

+ 那么，我们怎样才能确保，在使用create_shape的返回值时不会发生内存泄漏呢？
+ 答案就是：在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。
+ 如果好奇delete空指针会发生什么的话，那答案是，这是一个合法的空操作。在new一个对象和delete一个指针时编译器需要干不少活的
  + 也就是说，new的时候先分配内存（失败时整个操作失败并向外抛出异常，通常使bad_alloc），然后在这个结果指针上构造对象；
  + 构造成功则new操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。
  + delete时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存