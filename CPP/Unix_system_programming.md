## 概述

### 异步操作(asynchronous operation)

- 是由于很多计算机系统事件会在不可预测的事件，以不可预测的顺序发生而产生的

### 并发(concurrency)

- 是指在相同的时间帧内对资源的共享
- 并发实体，可以是单个程序内部的执行线程或者其他抽象的对象
- 并发可能发生在单CPU系统，共享相同内存的多CPU系统，或者运行在网络上的独立系统中

### 通信(communication)

- 将一个实体的信息传送给另一个实体
- 程序在李处磁盘这样的本地设备的I/O的同时，还必须要处理网络I/O（网络通信）

### 上下文切换时间(context-switch time)

+ 是指从执行一个进程转换到执行另一个进程所花费的时间

### 时间片(quantum)

+ 大致上就是在一个进程不得不让出处理器让其他进程运行之前，分配给这个进程的CPU时间总量

### 多道程序设计(multiprogramming)

+ 指由于处理时间上的悬殊差异，采取有多个进程准备好要执行，操作系统挑选一个已经准备好的进程来执行，当哪个进程需要等待资源时，操作系统保存从停止处回复此进程所需的所有信息，并选择另一个准备好的进程执行

+ 一次资源请求会引起一次对操作系统的请求（即一次系统调用）
  
### 系统调用(system call)

+ 是对操作系统服务的一次请求，它会使正常的CPU周期中断，并将控制权交给操作系统，然后，操作系统就可以切换到另一个进程了

### 分时(timesharing)

+ 但物理CPU，并发

### 多处理器系统(multiprocessor systems)

+ 几个处理器都访问一个共享的内存

### 硬件层并发

+ 由于有多台设备要同时操作
+ 处理器中有内部的并行机制，可以同时处理几条指令，系统中有多个处理器，而且系统通过网络通信进行交互

### 应用层并发

+ 在信号处理中，I/O与其他处理的重叠中，在通信过程中，在进程间或同一进程的不同线程间的资源共享中，都存在应用层的并发

### 中断(interrupt)

+ 在常规机器层(conventional machine level)程序中，单指令的执行是处理器指令周期(processor instruction cycle)的结果
+ 在处理器指令周期的正常执行过程中，处理器从程序计数器中检索出一个地址，并执行这个地址上的指令。
+ **在常规机器层出现并发**，是因为外围设备会产生一种被称为中断的电信号，在处理器内部设置一个硬件标志符。
+ 检测中断是指令周期自身的一部分。在每个指令周期中，处理器都检查硬件标识。
+ 如果处理器察觉有中断发生，它就保存程序计数器的当前值，并装载一个新的值，这个新的值是一个被称为中断服务例程(interrupt service routine)或中断处理程序(interupt handler)的特殊函数的地址

### 异步(asynchronous)

+ 如果一个事件发生的时间不是由某个实体确定的，那么这个事件就是异步于这个实体的。
  + （外部硬件设备产生的中断通常都异步于系统中执行的程序）

### 同步(synchronous)

+ 如果向指令提供相同的数据，那么，像被零除这样的错误事件，就总是在执行某个特殊指令的时候发生，从这种意义上来说，错误事件是同步的

### 设备驱动程序(device driver)

+ 被称为设备驱动程序的操作系统例程，通常用来处理外围设备产生的中断。
+ 然后这些驱动程序会通过信号这样的软件机制，来通知相关的进程事件已经发生了

### 定时器(timer)

+ 操作系统也用中断来实现分时。
+ 大多数计算机都有一个被称为定时器的设备，它可以在一段指定的时间间隔后产生中断。
+ 为了执行用户程序，操作系统在设备程序计数器之前启动定时器。定时器到时的时候，它就产生一个中断，使CPU转而执行定时器中断服务例程。中断服务例程将操作系统代码的地址写入程序计数器，这样，操作系统又获得了控制权

### 信号(signal)

+ 是事件的软件通知
+ 通常，信号是操作系统对中断（硬件事件）的响应
+ 例如，按下`Ctrl-C`键会使处理键盘的设备驱动程序产生一个中断。驱动程序将这些字符当做中断字符，并发送信号来通知与这个中断相关的进程
+ 当引发信号的那个事件发生时，信号就产生了(generate)了  --  信号可以同步产生，也可以异步产生
  + 如果信号由接收它的进程或线程产生，这个信号就是同步产生的。执行非法指令都会产生同步信号
  + 在键盘上输入`Ctrl-C`会产生一个异步信号

### 捕捉(catch)

+ 进程执行信号的处理程序时，它就捕捉到了信号
+ 捕捉信号的程序至少有两个并发的部分，主程序和信号处理程序

### 进程，线程和资源共享

+ 在UNIX中实现并发执行的一种传统方法是：用户通过调用`fork()`函数创建多个进程。
+ 有相同祖先的进程可以通过管道(pipe)进行通信
+ 没有共同祖先的进程可以通过信号，FIFO，信号量，共享的地址空间或消息进行通信
+ 在进程内部可以通过多个执行线程提供并发。
+ 程序执行时，CPU用程序计数器来确定下一步要执行哪条指令。得到的指令流被称为程序的执行线程(thread of execution)。它是进程的控制流

### 分布式计算

+ 并发和通信共同形成新的应用程序
+ 在分布式计算中使用最广泛的模型是客户端-服务器模型(client-server model)。这个模型中的基本实体
  + 有管理资源的服务器进程，
  + 和需要对共享资源进行访问的客户机进程
+ 基于对象的模型(object-based model)是分布式计算的另一种模型
  + 系统中的每种资源都被看作一个带有消息处理接口的对象，这样就可以用统一的方式来访问所有的资源
  + 基于对象的模型允许进行受控的增量开发和代码重用

### 缓冲区溢出(buffer overflow)

+ 当程序将数据拷贝到一个没有为其分配足够空间的变量中去的时候，就会发生缓冲区溢出

+ 缓冲区溢出的后果
  + 要理解缓冲区溢出时会发生什么情况，就要理解程序在内存中是如何布局的
    + 大多数程序代码都在带有自动局部变量的函数中执行
    + 虽然在不同的机器上实现的细节有所不同，程序通常都在程序栈上分配自动变量
  + 在典型系统中，栈都是从高端内存向低端内存扩展的
  + 调用一个函数时
    + 栈的低端部分包括传递的参数和返回地址
    + 栈中较高的部分（内存地址比较小的部分）用来存放局部自动变量
  + 栈可以用来存储其他值，也可能包含根本不为程序所用的间隙
  + 一个很重要的事实是：
    + 每次函数调用的返回地址通常都存储在自动变量后面的内存中（存储在地址比较大的内存中）
  + 当程序向栈中变量的范围之外写入时，回复阿生缓冲区溢出。额外的字节可能会重写未使用的空间，其他变量，返回地址或该程序不能合法访问的其他内存。
  + 结果可能是没什么影响，也可能会造成程序崩溃，信息转储以及不可预测的行为

## 程序，进程和线程

### 程序(program)

+ 指的是为了完成特定的任务而准备好的一个指令序列

+ C编译器将每个源文件翻译成一个目标文件，然后编译器将这些单个的目标文件同必须的一些库链接，形成一个可执行模块(executable module)。程序运行或执行(execute)时，操作系统将可执行模块拷贝到主存储器的程序映像(program image)中去

### 进程(process)

+ 是一个正在执行的程序实例
+ 每个实例都有自己的地址空间和执行状态
+ 操作系统记录进程ID和相应的进程状态，并用这些信息来分配和管理系统资源。操作系统还要对进程占用的内存和可分配的内存进行管理
+ 当操作系统向内核数据结构中添加了适当的信息，并为运行程序代码分配了必要的资源之后，程序就变成了进程。
+ 程序拥有地址空间（它可以访问的内存）和至少一个被称为线程的控制流
+ 进程，以执行一个指令序列的控制流开始。处理器程序计数器记录处理器（CPU）要执行的下一条指令。CPU读取一条指令后，对程序计数器的值进行增量运算，并且在指令的执行过程中，比如，在出现分支的时候，还会对其做进一步的修改。
+ 可能有多个进程驻存在内存中并发地执行，他们基本上都互相独立。如果进程要进行通信或互相合作，它们就必须显式地通过文件系统，管道，共享内存或网络这样的操作系统结构来交互

### 线程和执行线程(thread of execution)

+ 程序执行时，由进程程序计数器的值来决定下面该执行哪一条进程指令。得到的指令流被称为执行线程
+ 它可以用程序代码执行期间为程序计数器指定的指令地址序列来表示
+ 执行线程中的指令序列对进程来说，就像是一条不间断的地址流。但从处理器的观点来看，来自不同进程的执行线程是混在一起的。
+ 执行从一个进程切换到另一个进程的点被称作上下文切换(context switch)
+ 线程，是代表了进程内执行线程的一种抽象数据类型。线程有自己的执行栈，程序计数器值，寄存器组和状态
+ 通常在一个进程范围内声明多个进程，程序员可以编写出以很低的开销获得并行性的程序。
+ 尽管这些线程提供了低开销的并行性，但由于它们驻留在相同的进程地址空间并共享进程资源，因此，可能还需要对它们进行额外的同步。
  + 由于启动进程所需要的工作量大，有些人将进程称作是重量级(heavyweight)
    + 与之相反，线程有时被称作轻量级进程(lightweight processes)

### 程序映像的布局

+ 加载之后，可执行程序看起来占据了一个连续的内存块，这个连续的内存块被称为程序映像(program image)
+ 程序映像有几个不同的分区。程序文本或代码显示在内存低端地址中。在映像中已经初始化和未初始化的静态变量也有自己的分区。其他的分区包括堆，栈和环境
+ 活动记录(activation record)
  + 指的是在进程栈顶端分配的一个内存块，用来装载调用过程中函数的执行上下文。
  + 每次函数调用都在栈上创建一个新的活动记录
+ 除了静态变量和自动变量之外，程序映像中还包括了`argc`和`argv`占用的空间以及`malloc`分配的空间。
+ `malloc`函数族在一个被称为堆(`heap`)的空闲内存池中分配存储空间
  + 在堆上分配的存储空间一直存在，直到它被释放或程序退出为止
  + 如果一个函数调用了`malloc`，那么在这个函数返回值后，存储空间仍保持已分配状态。
  + 除非程序有一个在函数返回值后仍然可以访问的，指向该存储空间的指针，否则，返回后的程序就不能访问它
+ 在声明时，没有显式初始化的静态变量在运行时被初始化为0
+ 在程序映像中，已初始化的静态变量和未初始化的静态变量占据不同的分区
  + 通常，已初始化的静态变量是磁盘上可执行模块的一部分，而未初始化的静态变量则不是
  + 自动变量不是可执行模块的一部分，因为只有当定义它们的程序块被调用时，它们才会被分配。除非程序显式地对自动变量进行初始化，否则，它们的初始值是不确定的
+ 对线程化的执行来说，静态变量会使程序变得不安全。
+ 连续调用一个引用了静态变量的函数会出现意料不到的情况，因此，外部静态变量也使得代码的调试更加困难。
+ 出于这些原因，除非是在受控的情况下，否则应该避免使用静态变量
+ 尽管程序映像看起来占据了一个连续的内存块，但实际上，操作系统将程序映像映射到不一定连续的物理内存块中。
+ 通常的映射将程序映像划分成相同大小的片，这些片被称为页(`page`)
  + 操作系统将这些页加载到内存中，当处理器引用某页上的内存时，操作系统会从一个表中查找这一页的物理位置。
  + 这种映射方式允许栈和堆有很大的逻辑地址空间。
  + 操作系统隐藏了这种底层映射的存在，这样即使有些页实际上并没有驻留字内存中，程序员也可以认为程序映像在逻辑上是连续的

### 函数返回值和错误

+ 错误处理是编写可靠系统程序中的一个关键问题
+ 处理UNIX程序中错误的标准方法有如下几种
  + 打印出错误消息并退出程序（仅在main函数中）
  + 返回`-1`或`NULL`，并设置`errno`这样的错误提示符
  + 返回错误码
+ 总的来说，函数永远也不能自己退出，而是应该向调用它的程序报告错误
+ 函数内部的错误消息在调试阶段可能会很有用，但通常不应该出现在最终版本中。
+ 处理调试信息有一种很好的方法：
  + 将调试打印语句包含在一个条件编译块中，这样在需要的时候可以将其重新激活

### 参数数组(argument array)

+ 是一个指向字符串的指针数组
+ 数组的结尾由一个包含`NULL`指针的条目来标识。

### 静态变量的使用

+ 静态变量可以用来存储函数调用之间的内部状态信息

### 进程环境

+ 环境列表(environment list)由一个指针数组组成，其中的指针指向 名字=值(name=value) 形式的字符串。数组的最后一个条目为`NULL`
  + 名字，指定一个环境变量(environment variable)
  + 值，指定与环境变量相关的字符串的值
+ 如果进程由`execl, execlp, execv, execvp`初始化，那么进程就继承了执行`exec`之前的那个进程的环境列表
+ 环境变量提供了一种用系统特定信息或用户特定信息在程序内部设置默认值的机制。例如，程序可能需要在用户的主目录中写入状态信息，或者需要在特定的地方查找一个可执行文件。用户可以在一个变量中设置信息，用以说明在哪里可以找到可执行文件。应用程序用其特有的方式来解释环境变量的值
+ 用`getenv()`来确定在进程环境中，一个指定的变量是否有值。将环境变量的名字作为字符串来传递
+ 不要将环境变量与预定义的常量混淆
  + 预定义的常量是用`#define`在头文件中定义的，它们的值是常数，在编译时是已知的，要想查看这样一个常量的定义是否存在，可以使用编译器指令`#ifndef`
  + 与之相反，环境变量是动态的，直到运行时才能直到它们的值

### POSIX环境变量及其含义

+ `COLUMNS`   --  终端上列的优选宽度
+ `HOME`
+ `LINES`     --  页或垂直屏幕上的优选行数
+ `LOGNAME`   --  与进程相关的登录名
+ `PATH`      --  用于寻找可执行文件的路径前缀
+ `PWD`       --  当前工作目录的绝对路径名 
+ `SHELL`     --  用户优选的命令解释程序的路径名
+ `TERM`      --  输出的终端类型
+ `TMPDIR`    --  临时文件目录的路径名
+ `TZ`        --  时区信息

### 进程终止

+ 进程终止时，操作系统释放进程资源，更新适当的统计信息并向其他进程通知进程的死亡
+ 终止可以是正常的，也可以是不正常的。进程终止期间执行的动作包括
  + 取消挂起的定时器和信号
  + 释放虚拟内存资源
  + 释放其他进程持有的系统资源（例如锁）
  + 关闭打开的文件
+ 操作系统记录进程状态和资源的使用情况，同时通知父进程对`wait`函数进行响应

+ 在UNIX中，进程终止后不会完全释放它的资源，直到父进程等待它为止。
+ 如果进程终止的时候，它的父进程没有等待它，那么这个进程就成为一个僵进程(zombie)。
+ 僵进程是一个不活动的进程，它的资源会在稍后父进程等待它的时候被删除。一个进程终止时，它的孤儿子进程(orphaned child)和僵进程会被一个特殊的系统进程收养。
+ 在传统的UNIX系统中，这个特殊的进程被称为init进程，它的进程ID值为1，并周期性地等待子进程

+ 进程正常终止：
  + 从main中return
  + 从main中隐式地返回（main函数执行到末尾）
  + 调用exit, _Exit或_exit
+ C的exit函数调用了用户定义的退出处理程序，这些处理程序是由`atexit()`按照与登记时相反的顺序记录的
+ 调用了用户定义的处理程序之后，exit对任何一个包含未写入的缓冲数据的打开的流(open stream)进行刷新，然后关系所有打开的流。最后，exit删除所有tmpfile()创建的临时文件，并终止控制进程。

## Unix系统中的进程

### 进程标识

+ UNIX用唯一的被称为进程ID(process ID)的整数值来标识进程
+ 每个进程还有一个父进程ID(parent process ID)，这个父进程ID最初是创建它的那个进程的进程ID
+ 返回进程和父进程函数：`getpid()`, `getppid()`

+ 系统管理员创建用户账户时，为每个用户分配唯一的整型用户ID(user ID)和整型组ID(group ID)
+ 系统通过用户ID和组ID从系统数据库中检索出允许这个用户使用的权限。
+ 返回用户ID和组ID的函数：`getegid()`, `geteuid()`

### 进程状态

+ 进程的状态(state)说明了它在某个特定时刻的状况

+ 进程执行I/O时是通过一个库函数去请求服务的，这个库函数有时被称为系统调用(system call)
+ 在系统调用的执行过程中，操作系统重新获得对处理器的控制权，并且可以将进程转入阻塞状态，直到操作结束为止

+ 上下文切换(context switch)，是指将一个进程从运行状态移出，并用另一个进程来替代它的行为
+ 进程上下文(process context)，是操作系统在上下文切换之后重启进程**所需的，有关此进程及其环境的信息**
  + 很明显，就像用于静态和动态变量的内存的当前状态一样，可执行代码，栈，寄存器和程序计数器都是上下文的一部分
  + 为了能够透明地重启进程，操作系统还要记录进程状态，程序I/O的状况，用户和进程的标识，权限，调度参数，账号信息以及内存管理信息
  + 如果进程在等待事件或者已经捕捉到了一个信号，那么这个信息也是上下文的一部分
  + 上下文还包括与其他资源相关的信息，例如进程持有的锁等

### Unix进程的创建与fork调用

+ 进程可以通过调用fork来创建新的进程
+ 调用进程就称为父进程(parent)，被创建的进程就被称为子进程(child)

+ fork函数拷贝了父进程的内存映像，这样新进程就会收到父进程地址空间的一份拷贝。两个进程在fork语句之后，都继续执行后面的指令（分别在它们自己的内存映像中执行）
+ 子进程继承(inherit)了诸如环境和权限这样的父进程属性，还继承了某些父进程资源，例如打开的文件和设备

### wait函数

+ 一个进程创建子进程时，父进程和子进程都从fork后的那个点开始继续执行
+ 父进程可以通过执行wait和waitpid一直阻塞到子进程结束

+ wait函数会使调用者的执行挂起，直到子进程的状态成为可用，或者调用者收到一个信号为止

### exec函数

+ fork函数创建了调用进程的一份拷贝，但很多应用程序都需要子进程执行与其父进程不同的代码
+ exec函数族提供了用新的映像来覆盖调用进程的进程映像的功能
+ fork-exec配合应用的传统方式是：子进程（用exec函数）执行新程序，而父进程继续执行原来的代码

+ 六种不同形式的exec函数的区别在于命令行参数和环境变量的传递方式。它们的不同还在于是否要给出可执行文件的完整的路径名
  + `execl(execl, execlp, execle)`函数用一个显式的序列来传递命令行参数，如果在编译时就知道命令行参数的数目，这些函数是很有用的
  + `execv(execv, execvp, execve)`函数将命令行参数放在一个参数数组中传递

+ exec函数将一个新的可执行文件拷贝到进程映像中去。程序的文本，变量，栈和堆都被重写了
+ 除非原始进程调用了`execle, execve`，否则新进程就继承环境（也就是说，继承了环境变量列表及其相关的值）

### 后台进程与守护进程

+ 命令解释程序是一个用来提示命令，从标准输入中读取命令，创建子进程来执行命令并等待子进程执行完毕的一个命令解释程序。
+ 当标准输入和标准输出来自于一个终端类型的设备时，用户可以通过输入中断字符来终止一个正在执行的命令
  + 中断字符是可以设置的，但很多系统都假定中断字符的默认值为`Ctrl-C`

+ 大多数命令解释程序将一个以`&`结束的行解释为应该由后台进程执行的命令
+ 命令解释程序创建了一个后台进程时，它在发出提示符并接受其他的命令之前不用等待进程的结束。而且，从键盘键入的`Ctrl-C`也不能终止后台进程

+ 守护进程(daemon)，是一个通常能够无限期运行的后台进程
+ UNIX操作系统依靠很多守护进程来执行例行的任务

### 临界区

+ 每个进程中对，应该一次只被一个进程使用的资源，进行访问的那部分代码都被称为临界区(critical section)
+ 带有临界区的程序必须要注意不能违反互斥(mutual execlusion)的原则

+ 提供互斥的一种办法是使用锁机制

+ 为了减少内部交互的复杂性，有些操作系统使用了面向对象(object-oriented)的设计。
+ 共享的表和其他资源都被封装成对象，这些对象都带有规定的很明确的访问函数。访问这样一个表的唯一的方法就是使用这些函数，这些函数都内建了恰当的互斥
+ 在分布式系统中，对象接口都使用消息

+ 从表面上看，面向对象的方法与守护进程类似，但从结构上看，这些方式可能会有很大的不同。
  + 守护进程并不一定要封装资源。它们可以以一种不受控的方式来争夺共享的数据结构
  + 好的面向对象设计保证了数据结构是被封装的，并且只能通过精心控制的接口对其进行访问。
  + 守护进程可以用面向对象的设计来实现，但并不一定非要这样实现。

## UNIX I/O

+ UNIX通过文件描述符来实现统一的设备接口，这种统一的接口允许为终端，磁盘，磁带，音频甚至网络通信使用相同的I/O调用

### 设备术语

+ 外围设备(peripheral device)是指计算机系统访问的硬件。
  + 常见的外围设备包括磁盘，磁带，CD-ROM，显示器，键盘，打印机，鼠标和网络接口

+ 用户程序对这些设备的控制和I/O操作是通过对被称为**设备驱动程序**(device driver)的操作系统模块所进行的系统调用来实现的。
  + 设备驱动程序将设备操作的细节隐藏起来，并保护设备以免其受到未授权的使用

+ 有些操作系统为它所支持的每种类型的设备都提供了特定的系统调用，这就要求系统程序员掌握一组复杂的设备控制调用
+ UNIX为大多数设备提供了标准的访问接口，这就极大地简化了提供给程序员的设备接口

+ UNIX对设备的标准访问接口是通过5个函数来实现的：`open, close, read, write, ioctl`
+ 所有的设备都用文件来表示，这些文件被称为特殊文件(special file)，存放在目录`/dev`中
+ 因此，磁盘文件和其他设备都用统一的方式来命名和访问
  + 正常文件(regular file)只是磁盘上一个普通的数据文件
  + 块特殊文件(block special file)表示特性和磁盘类似的设备。磁盘驱动程序以块或组块的形式从块特殊设备中传送信息，而且这些设备通常都具有从设备的任何地方检索块的能力
  + 字符特殊文件(character special file)表示特性与终端类似的设备。这些设备看起来表示的是一串必须按顺序访问的字节流

### 读和写

+ UNIX通过read和write函数提供了对文件和其他设备的顺序访问
  + read函数试图从用`fildes`表示的文件或设备中取出`nbyte`字节，并将其放入用户变量`buf`中去。

+ **文件描述符**，表示了打开的文件或设备，可以将文件描述符想象成进程文件描述符表的索引
+ **文件描述符表**，在进程的用户区中，提供了对相关文件或设备的系统信息的访问

+ 从命令解释程序中执行一个程序时，程序的启动伴随着三个与文件描述符`STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO`相关的打开的流
  + `STDIN_FILENO, STDOUT_FILENO`分别为标准输入和标准输出。默认情况下，这两个流通常对应于键盘输入和显示器输出
  + 程序应该为错误消息使用标准错误设备`STDERR_FILENO`,且永远也不应该将其关闭

+ `readblock(), r_write()`

### 打开和关闭文件

+ open函数将一个文件描述符（程序中使用的句柄）与一个文件或物理设备关联起来

+ 每个文件都有三个与之相关的类：用户（或所有者），组和所有其他人（其他的人）
+ 可能的权限或者特权有读(r)，写(w)和执行(x)
+ 分别独立地为用户，组和其他人指定这些特权

### select函数

+ 对来自不同源端的I/O的处理是一个很重要的问题，它可能以多种不同的形式出现

+ 保持阻塞状态，直到一组条件中至少有一个条件为真为止，这种方法被称为或同步(OR synchronization)
+ 描述的情况中的条件是：描述符上的“输入可用(input available”

+ 监视多个文件描述符的一种方法是为每个描述符分别使用一个独立的进程
+ 用独立的进程来监视两个文件描述符可能很有用，但是这两个进程都有独立的地址空间，因此它们之间的交互很困难

+ `select()`调用提供了一种在单个进程中监视多个文件描述符的办法
+ 它可以对三种可能的状况进行监视：
  + 可以无阻塞地进行的读操作
  + 可以无阻塞地进行的写操作
  + 有挂起的错误情况的文件描述符

### poll函数

+ poll函数与select类似，但它是用文件描述符而不是条件的类型来组织信息的
+ 也就是说，一个文件描述符的可能事件都存储在struct pollfd中
+ 与之相反，select用事件的类型来组织信息，而读，写和错误情况都有独立的描述符掩码

+ poll函数有三个参数：`fds, nfds, timeout`
  + fds, 是一个struct polldf数组，用来表示文件描述符的监视信息
  + nfds，给出了要监视的描述符的数目
  + timeout，是一个用毫秒表示的事件，是poll在返回前没有接收事件时应该等待的时间
    + 如果timeout的值为-1， poll就永远都不会超时
    + 如果整数值为32个比特，那么最大的超时周期大约为30分钟
+ 返回值：
  + 如果超时，poll函数返回0
  + 如果成功，poll返回拥有事件的描述符的数目
  + 如果不成功，poll返回-1并设置errno

### 文件表示

+ 在C程序中，文件由文件指针或文件描述符来指定
+ ISO C的标准I/O库函数(`fopen, fscanf, fprintf, fread, fwrite, fclose` and so on)使用文件指针
+ UNIX的I/O函数(`open, read, write, close, ioctl`)使用文件描述符

+ 文件指针和文件描述符提供了用来执行独立于设备的输入和输出的逻辑标识，这些逻辑标识被称为句柄(handle)
+ 代表标准输入，标准输出和标准错误的文件指针的符号名分别为`stdin, stdout, stderr`，这些符号名定义在`stdio.h`中。
+ 代表标准输入，标准输出和标准错误的文件描述符的符号名分别为`STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO`，这些符号名定义在`unistd.h`中

### 库函数和系统调用之间的区别

+ POSIX标准不区分库函数和系统调用。
+ 传统上，库函数是一个普通的函数，通常因为它有用，得到广泛的应用或者是C这样的规范的一部分，而被放在一个被称为库的函数集合中。
+ 系统调用是对操作系统发出的服务请求。它包含了对操作系统的自陷(trap)，通常还包含上下文切换

+ 系统调用与特定的操作系统相关。
+ 很多的库函数，例如read和write，实际上都是系统调用的外套(jacket)。
+ 也就是说，它们以恰当的，与系统相关的形式重新设置参数的格式，然后调用底层的系统调用来执行实际的操作

### 文件描述符

+ open函数将文件或物理设备与程序中使用的逻辑句柄相关联。用字符串（例如`/home/user/my.data`）来指定文件或物理设备。
+ 句柄是一个整数，可以将其理解为进程特定的文件描述符表(file descriptor table)的索引
+ 对进程中每个打开的文件，文件描述符表都包含一个相应条目，文件描述符表是进程用户区的一部分，但是除非通过使用文件描述符的函数，否则程序无法对其进行访问


### 文件指针和缓冲

+ ISO C标准的I/O库用文件指针而不是文件描述符作为I/O的句柄
+ 文件指针(file pointer)指向进程用户区中的一个被称为FILE结构的数据结构

+ FILE结构包括一个缓冲区和一个文件描述符值
+ 文件描述符值是文件描述符表中条目的索引，实际上就是通过这个文件描述符表将文件输出到磁盘的
+ 从某种意义上说，文件指针就是句柄的句柄

+ 磁盘文件通常都是完全缓冲(fully buffered)的，这就意味着，`fprint`实际上没有将消息写入磁盘，而是将这些字节写入了FILE结构的一个缓冲区里。
+ 缓冲区填满时，I/O子系统就会用文件描述符来调用write。
+ 文件执行`fprintf`的时刻和实际进行写操作的时刻之间的时延可能会造成意外的结果，尤其是在程序崩溃的时候。
+ 系统崩溃时，有时会丢失缓冲的数据，因此，甚至会出现：程序看起来是正常结束了，但它的磁盘输出确实不完整的

+ 程序怎样才能避免缓冲对它的影响？
+ fflush调用会强制写出FILE结构中缓冲的任何内容
+ 程序也可以调用`setvbuf`来禁止缓冲

+ 终端I/O的工作方式不同，与终端相关的文件是行缓冲(line buffered)的，而不是完全缓冲的（标准错误除外，它在默认情况下是不缓冲的）
+ 对输出来说，行缓冲意味着**在缓冲区被填满或遇到一个新行符号之前，行不会被写出**

### 过滤器和重定向

+ UNIX提供了大量作为过滤器而编写的工具
+ 过滤器(filter)从标准输入中读入，执行一个转换，然后将结果输出到标准输出中去
+ 过滤器将它们的错误消息写入标准错误
+ 过滤器所有的参数都作为命令行参数传送
+ 输入数据不应该有首部或尾部，而且过滤器也不应该要求与用户进行任何交互

+ 实用的UNIX过滤器的例子包括：`head, tail, more, sort, grep, awk`

+ cat命令将一个文件名列表作为命令参数，一个接一个地读其中的每个文件，并将每个文件的内容会送到标准输出中去
+ 但是，如果没有指定输入文件，cat就会从标准输入获取它的输入，并将结果写入标准输出。在这种情况下，cat表现得像过滤器一样

+ 文件描述符是那个进程的文件描述符表的一个索引。文件描述符表中的每个条目都指向系统文件表中的一个条目，该条目是在文件被打开时创建的。
+ 程序可以对文件描述符表的条目进行修改，使其指向系统文件表中的另一个条目。这种动作叫做重定向(redirection)
+ 大多数命令解释程序豆浆命令行中的大于字符(>)解释成对标准输出的重定向，而小于字符(<)解释成对标准输入的重定向

+ dup2函数有两个参数：fildes, fildes2

### 文件控制

+ `fcntl()`函数是一个通用函数，可用来检索和修改与打开的文件描述符相关联的标志符
+ `fcntl()`参数`fildes`指定了描述符，参数`cmd`指定了操作

## 文件和目录

+ 操作系统将原始存储设备以文件系统的形式组织起来，这样应用程序就可以用高级操作，而不是低级的设备调用来访问信息

+ UNIX文件系统是树形的，节点表示文件，弧线表示包含关系

+ UNIX目录项将文件名与文件所在位置关联起来。
+ 这些目录项可以直接指向一个包含文件位置信息的结构（硬链接）
+ 也可以通过符号链接间接地指向文件所在位置
  + 符号链接是将一个文件名关联到另一个文件名的文件

### UNIX文件系统导航

+ 文件系统(file system)，是文件和属性的集合，其中的属性包括位置和名字等
+ 应用程序不用指定文件在磁盘上的物理位置，而只需指定文件名和偏移量。操作系统通过它的文件系统将其翻译为物理文件的位置

+ 目录，是一个包含了目录项(directory entry)的文件，目录项将文件名与文件在磁盘上的物理位置关联起来

+ 绝对路径名(absolute pathname)或全称路径名(fully qualified pathname)，指定了文件系统树中从根到文件自身的路径上所有的节点

+ 程序不一定总要用全称路径名来制定文件。
+ 任何时候，每个进程都有一个用来作路径名解析的相关目录，这个目录被称作当前工作目录(current working directory)

+ `pathconf`函数，是允许程序以一种与平台无关的方式来确定系统和运行期极限的函数族中的一个

### 目录访问

+ 目录不能用普通的`open, close, read`函数来访问。
+ 相反，访问目录需要使用特定的函数，相应的函数名以`dir`结束：`opendir, closedir, readdir`

+ `opendir()`函数，为一个目录流提供了`DIR*`类型的句柄，该流的当前位置就在目录的第一项上
+ 定义在dirent.h中的DIR类型，表示的是一个**目录流**(directory stream)
+ 目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的

+ `readdir()`函数，是通过返回dirp所指向的目录流中的连续条目来读取目录的
+ `readdir()`在每次调用之后都将流转移到下一个位置上去

+ `closedir()`函数，关闭一个目录流，而`rewinddir()`函数把目录流重新定位在起始处
+ 每个函数都有一个参数`dirp`，这个参数对应于打开的目录流

### 访问文件状态信息

+ `fstat()`函数，用打开的文件描述符来访问文件
  
+ `stat()`和`lstat()`函数通过名字来访问文件
  + 它们都有两个参数，参数`path`指定了需要返回状态的文件或符号链接的名字
  + 如果path不对应于符号连接，也就是文件，它们就返回相同的结果
  + 当path是一个符号链接时
    + `lstat()`函数返回与链接有关的信息，
    + `stat()`函数返回与链接所指向的文件有关的信息
  + 参数`buff`指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中

### 确定文件的类型

+ 文件模式成员`st_mode`指定了文件的访问权限和文件的类型
+ POSIX规定用不同宏来测试不同文件类型的`st_mode`成员
  + 