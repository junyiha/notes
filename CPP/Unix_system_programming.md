## 概述

### 异步操作(asynchronous operation)

- 是由于很多计算机系统事件会在不可预测的事件，以不可预测的顺序发生而产生的

### 并发(concurrency)

- 是指在相同的时间帧内对资源的共享
- 并发实体，可以是单个程序内部的执行线程或者其他抽象的对象
- 并发可能发生在单CPU系统，共享相同内存的多CPU系统，或者运行在网络上的独立系统中

### 通信(communication)

- 将一个实体的信息传送给另一个实体
- 程序在李处磁盘这样的本地设备的I/O的同时，还必须要处理网络I/O（网络通信）

### 上下文切换时间(context-switch time)

+ 是指从执行一个进程转换到执行另一个进程所花费的时间

### 时间片(quantum)

+ 大致上就是在一个进程不得不让出处理器让其他进程运行之前，分配给这个进程的CPU时间总量

### 多道程序设计(multiprogramming)

+ 指由于处理时间上的悬殊差异，采取有多个进程准备好要执行，操作系统挑选一个已经准备好的进程来执行，当哪个进程需要等待资源时，操作系统保存从停止处回复此进程所需的所有信息，并选择另一个准备好的进程执行

+ 一次资源请求会引起一次对操作系统的请求（即一次系统调用）
  
### 系统调用(system call)

+ 是对操作系统服务的一次请求，它会使正常的CPU周期中断，并将控制权交给操作系统，然后，操作系统就可以切换到另一个进程了

### 分时(timesharing)

+ 但物理CPU，并发

### 多处理器系统(multiprocessor systems)

+ 几个处理器都访问一个共享的内存

### 硬件层并发

+ 由于有多台设备要同时操作
+ 处理器中有内部的并行机制，可以同时处理几条指令，系统中有多个处理器，而且系统通过网络通信进行交互

### 应用层并发

+ 在信号处理中，I/O与其他处理的重叠中，在通信过程中，在进程间或同一进程的不同线程间的资源共享中，都存在应用层的并发

### 中断(interrupt)

+ 在常规机器层(conventional machine level)程序中，单指令的执行是处理器指令周期(processor instruction cycle)的结果
+ 在处理器指令周期的正常执行过程中，处理器从程序计数器中检索出一个地址，并执行这个地址上的指令。
+ **在常规机器层出现并发**，是因为外围设备会产生一种被称为中断的电信号，在处理器内部设置一个硬件标志符。
+ 检测中断是指令周期自身的一部分。在每个指令周期中，处理器都检查硬件标识。
+ 如果处理器察觉有中断发生，它就保存程序计数器的当前值，并装载一个新的值，这个新的值是一个被称为中断服务例程(interrupt service routine)或中断处理程序(interupt handler)的特殊函数的地址

### 异步(asynchronous)

+ 如果一个事件发生的时间不是由某个实体确定的，那么这个事件就是异步于这个实体的。
  + （外部硬件设备产生的中断通常都异步于系统中执行的程序）

### 同步(synchronous)

+ 如果向指令提供相同的数据，那么，像被零除这样的错误事件，就总是在执行某个特殊指令的时候发生，从这种意义上来说，错误事件是同步的

### 设备驱动程序(device driver)

+ 被称为设备驱动程序的操作系统例程，通常用来处理外围设备产生的中断。
+ 然后这些驱动程序会通过信号这样的软件机制，来通知相关的进程事件已经发生了

### 定时器(timer)

+ 操作系统也用中断来实现分时。
+ 大多数计算机都有一个被称为定时器的设备，它可以在一段指定的时间间隔后产生中断。
+ 为了执行用户程序，操作系统在设备程序计数器之前启动定时器。定时器到时的时候，它就产生一个中断，使CPU转而执行定时器中断服务例程。中断服务例程将操作系统代码的地址写入程序计数器，这样，操作系统又获得了控制权

### 信号(signal)

+ 是事件的软件通知
+ 通常，信号是操作系统对中断（硬件事件）的响应
+ 例如，按下`Ctrl-C`键会使处理键盘的设备驱动程序产生一个中断。驱动程序将这些字符当做中断字符，并发送信号来通知与这个中断相关的进程
+ 当引发信号的那个事件发生时，信号就产生了(generate)了  --  信号可以同步产生，也可以异步产生
  + 如果信号由接收它的进程或线程产生，这个信号就是同步产生的。执行非法指令都会产生同步信号
  + 在键盘上输入`Ctrl-C`会产生一个异步信号

### 捕捉(catch)

+ 进程执行信号的处理程序时，它就捕捉到了信号
+ 捕捉信号的程序至少有两个并发的部分，主程序和信号处理程序

### 进程，线程和资源共享

+ 在UNIX中实现并发执行的一种传统方法是：用户通过调用`fork()`函数创建多个进程。
+ 有相同祖先的进程可以通过管道(pipe)进行通信
+ 没有共同祖先的进程可以通过信号，FIFO，信号量，共享的地址空间或消息进行通信
+ 在进程内部可以通过多个执行线程提供并发。
+ 程序执行时，CPU用程序计数器来确定下一步要执行哪条指令。得到的指令流被称为程序的执行线程(thread of execution)。它是进程的控制流

### 分布式计算

+ 并发和通信共同形成新的应用程序
+ 在分布式计算中使用最广泛的模型是客户端-服务器模型(client-server model)。这个模型中的基本实体
  + 有管理资源的服务器进程，
  + 和需要对共享资源进行访问的客户机进程
+ 基于对象的模型(object-based model)是分布式计算的另一种模型
  + 系统中的每种资源都被看作一个带有消息处理接口的对象，这样就可以用统一的方式来访问所有的资源
  + 基于对象的模型允许进行受控的增量开发和代码重用

### 缓冲区溢出(buffer overflow)

+ 当程序将数据拷贝到一个没有为其分配足够空间的变量中去的时候，就会发生缓冲区溢出

+ 缓冲区溢出的后果
  + 要理解缓冲区溢出时会发生什么情况，就要理解程序在内存中是如何布局的
    + 大多数程序代码都在带有自动局部变量的函数中执行
    + 虽然在不同的机器上实现的细节有所不同，程序通常都在程序栈上分配自动变量
  + 在典型系统中，栈都是从高端内存向低端内存扩展的
  + 调用一个函数时
    + 栈的低端部分包括传递的参数和返回地址
    + 栈中较高的部分（内存地址比较小的部分）用来存放局部自动变量
  + 栈可以用来存储其他值，也可能包含根本不为程序所用的间隙
  + 一个很重要的事实是：
    + 每次函数调用的返回地址通常都存储在自动变量后面的内存中（存储在地址比较大的内存中）
  + 当程序向栈中变量的范围之外写入时，回复阿生缓冲区溢出。额外的字节可能会重写未使用的空间，其他变量，返回地址或该程序不能合法访问的其他内存。
  + 结果可能是没什么影响，也可能会造成程序崩溃，信息转储以及不可预测的行为

## 程序，进程和线程

### 程序(program)

+ 指的是为了完成特定的任务而准备好的一个指令序列

+ C编译器将每个源文件翻译成一个目标文件，然后编译器将这些单个的目标文件同必须的一些库链接，形成一个可执行模块(executable module)。程序运行或执行(execute)时，操作系统将可执行模块拷贝到主存储器的程序映像(program image)中去

### 进程(process)

+ 是一个正在执行的程序实例
+ 每个实例都有自己的地址空间和执行状态
+ 操作系统记录进程ID和相应的进程状态，并用这些信息来分配和管理系统资源。操作系统还要对进程占用的内存和可分配的内存进行管理
+ 当操作系统向内核数据结构中添加了适当的信息，并为运行程序代码分配了必要的资源之后，程序就变成了进程。
+ 程序拥有地址空间（它可以访问的内存）和至少一个被称为线程的控制流
+ 进程，以执行一个指令序列的控制流开始。处理器程序计数器记录处理器（CPU）要执行的下一条指令。CPU读取一条指令后，对程序计数器的值进行增量运算，并且在指令的执行过程中，比如，在出现分支的时候，还会对其做进一步的修改。
+ 可能有多个进程驻存在内存中并发地执行，他们基本上都互相独立。如果进程要进行通信或互相合作，它们就必须显式地通过文件系统，管道，共享内存或网络这样的操作系统结构来交互

### 线程和执行线程(thread of execution)

+ 程序执行时，由进程程序计数器的值来决定下面该执行哪一条进程指令。得到的指令流被称为执行线程
+ 它可以用程序代码执行期间为程序计数器指定的指令地址序列来表示
+ 执行线程中的指令序列对进程来说，就像是一条不间断的地址流。但从处理器的观点来看，来自不同进程的执行线程是混在一起的。
+ 执行从一个进程切换到另一个进程的点被称作上下文切换(context switch)
+ 线程，是代表了进程内执行线程的一种抽象数据类型。线程有自己的执行栈，程序计数器值，寄存器组和状态
+ 通常在一个进程范围内声明多个进程，程序员可以编写出以很低的开销获得并行性的程序。
+ 尽管这些线程提供了低开销的并行性，但由于它们驻留在相同的进程地址空间并共享进程资源，因此，可能还需要对它们进行额外的同步。
  + 由于启动进程所需要的工作量大，有些人将进程称作是重量级(heavyweight)
    + 与之相反，线程有时被称作轻量级进程(lightweight processes)

### 程序映像的布局

+ 加载之后，可执行程序看起来占据了一个连续的内存块，这个连续的内存块被称为程序映像(program image)
+ 程序映像有几个不同的分区。程序文本或代码显示在内存低端地址中。在映像中已经初始化和未初始化的静态变量也有自己的分区。其他的分区包括堆，栈和环境
+ 活动记录(activation record)
  + 指的是在进程栈顶端分配的一个内存块，用来装载调用过程中函数的执行上下文。
  + 每次函数调用都在栈上创建一个新的活动记录
+ 除了静态变量和自动变量之外，程序映像中还包括了`argc`和`argv`占用的空间以及`malloc`分配的空间。
+ `malloc`函数族在一个被称为堆(`heap`)的空闲内存池中分配存储空间
  + 在堆上分配的存储空间一直存在，直到它被释放或程序退出为止
  + 如果一个函数调用了`malloc`，那么在这个函数返回值后，存储空间仍保持已分配状态。
  + 除非程序有一个在函数返回值后仍然可以访问的，指向该存储空间的指针，否则，返回后的程序就不能访问它
+ 在声明时，没有显式初始化的静态变量在运行时被初始化为0
+ 在程序映像中，已初始化的静态变量和未初始化的静态变量占据不同的分区
  + 通常，已初始化的静态变量是磁盘上可执行模块的一部分，而未初始化的静态变量则不是
  + 自动变量不是可执行模块的一部分，因为只有当定义它们的程序块被调用时，它们才会被分配。除非程序显式地对自动变量进行初始化，否则，它们的初始值是不确定的
+ 对线程化的执行来说，静态变量会使程序变得不安全。
+ 连续调用一个引用了静态变量的函数会出现意料不到的情况，因此，外部静态变量也使得代码的调试更加困难。
+ 出于这些原因，除非是在受控的情况下，否则应该避免使用静态变量
+ 尽管程序映像看起来占据了一个连续的内存块，但实际上，操作系统将程序映像映射到不一定连续的物理内存块中。
+ 通常的映射将程序映像划分成相同大小的片，这些片被称为页(`page`)
  + 操作系统将这些页加载到内存中，当处理器引用某页上的内存时，操作系统会从一个表中查找这一页的物理位置。
  + 这种映射方式允许栈和堆有很大的逻辑地址空间。
  + 操作系统隐藏了这种底层映射的存在，这样即使有些页实际上并没有驻留字内存中，程序员也可以认为程序映像在逻辑上是连续的

### 函数返回值和错误

+ 错误处理是编写可靠系统程序中的一个关键问题
+ 处理UNIX程序中错误的标准方法有如下几种
  + 打印出错误消息并退出程序（仅在main函数中）
  + 返回`-1`或`NULL`，并设置`errno`这样的错误提示符
  + 返回错误码
+ 总的来说，函数永远也不能自己退出，而是应该向调用它的程序报告错误
+ 函数内部的错误消息在调试阶段可能会很有用，但通常不应该出现在最终版本中。
+ 处理调试信息有一种很好的方法：
  + 将调试打印语句包含在一个条件编译块中，这样在需要的时候可以将其重新激活

### 参数数组(argument array)

+ 是一个指向字符串的指针数组
+ 数组的结尾由一个包含`NULL`指针的条目来标识。

### 静态变量的使用

+ 静态变量可以用来存储函数调用之间的内部状态信息

### 进程环境

+ 环境列表(environment list)由一个指针数组组成，其中的指针指向 名字=值(name=value) 形式的字符串。数组的最后一个条目为`NULL`
  + 名字，指定一个环境变量(environment variable)
  + 值，指定与环境变量相关的字符串的值
+ 如果进程由`execl, execlp, execv, execvp`初始化，那么进程就继承了执行`exec`之前的那个进程的环境列表
+ 环境变量提供了一种用系统特定信息或用户特定信息在程序内部设置默认值的机制。例如，程序可能需要在用户的主目录中写入状态信息，或者需要在特定的地方查找一个可执行文件。用户可以在一个变量中设置信息，用以说明在哪里可以找到可执行文件。应用程序用其特有的方式来解释环境变量的值
+ 用`getenv()`来确定在进程环境中，一个指定的变量是否有值。将环境变量的名字作为字符串来传递
+ 不要将环境变量与预定义的常量混淆
  + 预定义的常量是用`#define`在头文件中定义的，它们的值是常数，在编译时是已知的，要想查看这样一个常量的定义是否存在，可以使用编译器指令`#ifndef`
  + 与之相反，环境变量是动态的，直到运行时才能直到它们的值

### POSIX环境变量及其含义

+ `COLUMNS`   --  终端上列的优选宽度
+ `HOME`
+ `LINES`     --  页或垂直屏幕上的优选行数
+ `LOGNAME`   --  与进程相关的登录名
+ `PATH`      --  用于寻找可执行文件的路径前缀
+ `PWD`       --  当前工作目录的绝对路径名 
+ `SHELL`     --  用户优选的命令解释程序的路径名
+ `TERM`      --  输出的终端类型
+ `TMPDIR`    --  临时文件目录的路径名
+ `TZ`        --  时区信息

### 进程终止

+ 进程终止时，操作系统释放进程资源，更新适当的统计信息并向其他进程通知进程的死亡
+ 终止可以是正常的，也可以是不正常的。进程终止期间执行的动作包括
  + 取消挂起的定时器和信号
  + 释放虚拟内存资源
  + 释放其他进程持有的系统资源（例如锁）
  + 关闭打开的文件
+ 操作系统记录进程状态和资源的使用情况，同时通知父进程对`wait`函数进行响应

+ 在UNIX中，进程终止后不会完全释放它的资源，直到父进程等待它为止。
+ 如果进程终止的时候，它的父进程没有等待它，那么这个进程就成为一个僵进程(zombie)。
+ 僵进程是一个不活动的进程，它的资源会在稍后父进程等待它的时候被删除。一个进程终止时，它的孤儿子进程(orphaned child)和僵进程会被一个特殊的系统进程收养。
+ 在传统的UNIX系统中，这个特殊的进程被称为init进程，它的进程ID值为1，并周期性地等待子进程

+ 进程正常终止：
  + 从main中return
  + 从main中隐式地返回（main函数执行到末尾）
  + 调用exit, _Exit或_exit
+ C的exit函数调用了用户定义的退出处理程序，这些处理程序是由`atexit()`按照与登记时相反的顺序记录的
+ 调用了用户定义的处理程序之后，exit对任何一个包含未写入的缓冲数据的打开的流(open stream)进行刷新，然后关系所有打开的流。最后，exit删除所有tmpfile()创建的临时文件，并终止控制进程。

## Unix系统中的进程

### 进程标识

+ UNIX用唯一的被称为进程ID(process ID)的整数值来标识进程
+ 每个进程还有一个父进程ID(parent process ID)，这个父进程ID最初是创建它的那个进程的进程ID
+ 返回进程和父进程函数：`getpid()`, `getppid()`

+ 系统管理员创建用户账户时，为每个用户分配唯一的整型用户ID(user ID)和整型组ID(group ID)
+ 系统通过用户ID和组ID从系统数据库中检索出允许这个用户使用的权限。
+ 返回用户ID和组ID的函数：`getegid()`, `geteuid()`

### 进程状态

+ 进程的状态(state)说明了它在某个特定时刻的状况

+ 进程执行I/O时是通过一个库函数去请求服务的，这个库函数有时被称为系统调用(system call)
+ 在系统调用的执行过程中，操作系统重新获得对处理器的控制权，并且可以将进程转入阻塞状态，直到操作结束为止

+ 上下文切换(context switch)，是指将一个进程从运行状态移出，并用另一个进程来替代它的行为
+ 进程上下文(process context)，是操作系统在上下文切换之后重启进程**所需的，有关此进程及其环境的信息**
  + 很明显，就像用于静态和动态变量的内存的当前状态一样，可执行代码，栈，寄存器和程序计数器都是上下文的一部分
  + 为了能够透明地重启进程，操作系统还要记录进程状态，程序I/O的状况，用户和进程的标识，权限，调度参数，账号信息以及内存管理信息
  + 如果进程在等待事件或者已经捕捉到了一个信号，那么这个信息也是上下文的一部分
  + 上下文还包括与其他资源相关的信息，例如进程持有的锁等

### Unix进程的创建与fork调用

+ 进程可以通过调用fork来创建新的进程
+ 调用进程就称为父进程(parent)，被创建的进程就被称为子进程(child)

+ fork函数拷贝了父进程的内存映像，这样新进程就会收到父进程地址空间的一份拷贝。两个进程在fork语句之后，都继续执行后面的指令（分别在它们自己的内存映像中执行）
+ 子进程继承(inherit)了诸如环境和权限这样的父进程属性，还继承了某些父进程资源，例如打开的文件和设备

### wait函数

+ 一个进程创建子进程时，父进程和子进程都从fork后的那个点开始继续执行
+ 父进程可以通过执行wait和waitpid一直阻塞到子进程结束

+ wait函数会使调用者的执行挂起，直到子进程的状态成为可用，或者调用者收到一个信号为止

### exec函数

+ fork函数创建了调用进程的一份拷贝，但很多应用程序都需要子进程执行与其父进程不同的代码
+ exec函数族提供了用新的映像来覆盖调用进程的进程映像的功能
+ fork-exec配合应用的传统方式是：子进程（用exec函数）执行新程序，而父进程继续执行原来的代码

+ 六种不同形式的exec函数的区别在于命令行参数和环境变量的传递方式。它们的不同还在于是否要给出可执行文件的完整的路径名
  + `execl(execl, execlp, execle)`函数用一个显式的序列来传递命令行参数，如果在编译时就知道命令行参数的数目，这些函数是很有用的
  + `execv(execv, execvp, execve)`函数将命令行参数放在一个参数数组中传递

+ exec函数将一个新的可执行文件拷贝到进程映像中去。程序的文本，变量，栈和堆都被重写了
+ 除非原始进程调用了`execle, execve`，否则新进程就继承环境（也就是说，继承了环境变量列表及其相关的值）

### 后台进程与守护进程

+ 命令解释程序是一个用来提示命令，从标准输入中读取命令，创建子进程来执行命令并等待子进程执行完毕的一个命令解释程序。
+ 当标准输入和标准输出来自于一个终端类型的设备时，用户可以通过输入中断字符来终止一个正在执行的命令
  + 中断字符是可以设置的，但很多系统都假定中断字符的默认值为`Ctrl-C`

+ 大多数命令解释程序将一个以`&`结束的行解释为应该由后台进程执行的命令
+ 命令解释程序创建了一个后台进程时，它在发出提示符并接受其他的命令之前不用等待进程的结束。而且，从键盘键入的`Ctrl-C`也不能终止后台进程

+ 守护进程(daemon)，是一个通常能够无限期运行的后台进程
+ UNIX操作系统依靠很多守护进程来执行例行的任务

### 临界区

+ 每个进程中对，应该一次只被一个进程使用的资源，进行访问的那部分代码都被称为临界区(critical section)
+ 带有临界区的程序必须要注意不能违反互斥(mutual execlusion)的原则

+ 提供互斥的一种办法是使用锁机制

+ 为了减少内部交互的复杂性，有些操作系统使用了面向对象(object-oriented)的设计。
+ 共享的表和其他资源都被封装成对象，这些对象都带有规定的很明确的访问函数。访问这样一个表的唯一的方法就是使用这些函数，这些函数都内建了恰当的互斥
+ 在分布式系统中，对象接口都使用消息

+ 从表面上看，面向对象的方法与守护进程类似，但从结构上看，这些方式可能会有很大的不同。
  + 守护进程并不一定要封装资源。它们可以以一种不受控的方式来争夺共享的数据结构
  + 好的面向对象设计保证了数据结构是被封装的，并且只能通过精心控制的接口对其进行访问。
  + 守护进程可以用面向对象的设计来实现，但并不一定非要这样实现。

## UNIX I/O

+ UNIX通过文件描述符来实现统一的设备接口，这种统一的接口允许为终端，磁盘，磁带，音频甚至网络通信使用相同的I/O调用

### 设备术语

+ 外围设备(peripheral device)是指计算机系统访问的硬件。
  + 常见的外围设备包括磁盘，磁带，CD-ROM，显示器，键盘，打印机，鼠标和网络接口

+ 用户程序对这些设备的控制和I/O操作是通过对被称为**设备驱动程序**(device driver)的操作系统模块所进行的系统调用来实现的。
  + 设备驱动程序将设备操作的细节隐藏起来，并保护设备以免其受到未授权的使用

+ 有些操作系统为它所支持的每种类型的设备都提供了特定的系统调用，这就要求系统程序员掌握一组复杂的设备控制调用
+ UNIX为大多数设备提供了标准的访问接口，这就极大地简化了提供给程序员的设备接口

+ UNIX对设备的标准访问接口是通过5个函数来实现的：`open, close, read, write, ioctl`
+ 所有的设备都用文件来表示，这些文件被称为特殊文件(special file)，存放在目录`/dev`中
+ 因此，磁盘文件和其他设备都用统一的方式来命名和访问
  + 正常文件(regular file)只是磁盘上一个普通的数据文件
  + 块特殊文件(block special file)表示特性和磁盘类似的设备。磁盘驱动程序以块或组块的形式从块特殊设备中传送信息，而且这些设备通常都具有从设备的任何地方检索块的能力
  + 字符特殊文件(character special file)表示特性与终端类似的设备。这些设备看起来表示的是一串必须按顺序访问的字节流

### 读和写

+ UNIX通过read和write函数提供了对文件和其他设备的顺序访问
  + read函数试图从用`fildes`表示的文件或设备中取出`nbyte`字节，并将其放入用户变量`buf`中去。

+ **文件描述符**，表示了打开的文件或设备，可以将文件描述符想象成进程文件描述符表的索引
+ **文件描述符表**，在进程的用户区中，提供了对相关文件或设备的系统信息的访问

+ 从命令解释程序中执行一个程序时，程序的启动伴随着三个与文件描述符`STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO`相关的打开的流
  + `STDIN_FILENO, STDOUT_FILENO`分别为标准输入和标准输出。默认情况下，这两个流通常对应于键盘输入和显示器输出
  + 程序应该为错误消息使用标准错误设备`STDERR_FILENO`,且永远也不应该将其关闭

+ `readblock(), r_write()`

### 打开和关闭文件

+ open函数将一个文件描述符（程序中使用的句柄）与一个文件或物理设备关联起来
+ 