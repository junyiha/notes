## strchr()

+ 功能：在参数 `str` 所指向的字符串中搜索最后一次出现字符 `c`（一个无符号字符）的位置
+ 原型：`char* strrchr(const char *str, int c);`
+ 参数：
  + `str`  --  C字符串
  + `c`    --  要搜索的字符。以 `int` 形式传递，但是最终会转换回 `char` 形式
+ 返回值：
  + 成功  --  返回`str`中最后一次出现字符`c`的位置
  + 失败  --  没有找到该值，返回一个空指针
+ 需求：
  + 头文件：`#include <string.h>`

## pipe()

+ 功能：创建单项通信通道(管道)
+ 原型：`int pipe(int *__pipedes);`
  + 如果成功，两个文件描述符存储在`pipedes`中
  + `pipedes[1]`上写入的字节可以从`pipedes[0]`中读取
+ 参数：
  + `__pipedes`  --  数组
+ 返回值：
  + 成功  --  0
  + 失败  --  -1
+ 需求：
  + 头文件：`#include <unistd.h>`

## fork()

+ 功能：克隆调用进程，创建一个精确的副本。
+ 原型：`pid_t fork();`
+ 参数：无
+ 返回值：
  + 成功  --  新进程返回 0，或者新进程对旧进程的进程ID
  + 失败  --  -1

## getpid()

+ 功能：返回进程ID
+ 原型：`pid_t getpid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getpid`函数不能返回错误

## getppid()

+ 功能：返回父进程ID
+ 原型：`pid_t getppid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  父进程ID
  + 失败  --  
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `pid_t`是用来表示进程ID的一个无符号整数类型
  + `getppid`函数不能返回错误

## geteuid()

+ 功能：返回用户ID
+ 原型：`uid_t geteuid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  用户ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `uid_t`是代表用户ID的整数类型
  + `geteuid()`不返回错误

## getegid()

+ 功能：返回组ID
+ 原型：`gid_t getegid(void);`
+ 参数：无
+ 返回值：
  + 成功  --  组ID
  + 失败  -- 
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + `gid_t`是代表组ID的整数类型
  + `getegid()`不返回错误

## fork()

+ 功能：创建新的进程
+ 原型：`pid_t fork(void);`
+ 参数：无
+ 返回值：
  + 成功  --  向子进程返回0，并将子进程ID返回父进程
  + 失败  --  -1，并设置errno，没有创建子进程
+ 需求：
  + 头文件：`#include <unistd.h>`
+ 注意：
  + fork函数的返回值是允许父进程和子进程区别自己并执行不同代码的关键特征

## execl()

+ 功能：使用参数`arg`以及之后的参数 执行`path`
+ 原型：`int execl(const char* path, const char* arg,...);`
+ 参数：
  + `path`  --  要执行的文件
  + `arg`   --  执行的参数
+ 返回值：
  + 成功  --
  + 失败  --

## _exit()

+ 功能：使用`__status`的`low-order 8 bits`终止程序执行
+ 原型：`void _exit(int __status);`
+ 参数：
  + `__status`  --  
+ 返回值：

## waitpid()

+ 功能：等待进程为`pid`的子进程死亡， 
+ 原型：`pid_t waitpid(pid_t  pid, int* stat_loc, int options);`
+ 参数：
  + `pid`  --  等待的进程,指向返回状态所在单元的指针和一个用来指定可选项的标志符
    + pid有四种情况：
      + pid <  -1 等待组ID等于pid绝对值的任意子进程
      + pid == -1 等待任意子进程
      + pid == 0  等待组ID等于调用进程组ID的任意子进程
      + pid >  0  等待进程ID与pid相等的子进程
  + `stat_loc`  --  指向终止进程的终止状态，如果不关心终止状态可指定为空指针
  + `options`   --  控制waitpid的操作
    + WCONTINUED
    + WUNTRACED
    + WNOHANG  waitpid不阻塞
+ 返回值：
  + 成功  --  返回pid，并将子进程的状态存储到`stat_loc`中
  + 失败  --  -1

## mkstemp()

+ 功能：根据`__tmplate`生成唯一的临时文件名
+ 原型：`int mkstemp(char *__template);`
+ 参数：
  + `__tmplate`  --  需要操作的文件
+ 返回值：
  + 成功  --  返回在文件上打开的用于读取和写入的文件描述符
  + 失败  --  -1 （如果它不能创建一个唯一的文件名）

## openlog()

+ 功能：此函数用来打开一个到系统日志记录程序的连接，打开之后就可以用`syslog`或`vsyslog`函数向系统日志里添加信息了。而`closelog`函数就是用来关闭此连接的
+ 原型：`void openlog(const char *ident, int option, int facility);`
+ 参数：
  + `ident`  --  一个标记，`ident`所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记
  + `option` --  参数option是下列值取与运算的结果：
    + `LOG_CONS，LOG_NDELAY， LOG_NOWAIT， LOG_ODELAY， LOG_PERROR，LOG_PID`
    + 各值意义请参考`man openlog`手册
  + `facility`  --  指明记录日志的程序的类型
+ 返回值：空

## setlogmask()

+ 功能：设置日志掩码级别
+ 原型：`int setlogmask(int mask);`
+ 参数：
  + `mask`  --  
+ 返回值：
  + 成功  --  
  + 失败  -- 

## C 标准库 `<stdarg.h>`

+ `stdarg.h` 头文件定义了一个变量类型 `va_list` 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。
+ 可变参数的函数通在参数列表的末尾是使用省略号`(,...)`定义的

### 库变量 -- va_list

+ 功能：这是一个适用于 `va_start()`、`va_arg()` 和 `va_end()` 这三个宏存储信息的类型
+ 声明：`typedef _G_va_list va_list;`

### va_start()

+ 功能：
  + C 库宏 `void va_start(va_list ap, last_arg)` 初始化 `ap` 变量，它与 `va_arg` 和 `va_end` 宏是一起使用的
  + `last_arg` 是最后一个传递给函数的已知的固定参数，即**省略号之前的参数**
  + 这个宏必须在使用 `va_arg` 和 `va_end` 之前被调用
+ 原型：`void va_start(va_list ap, last_arg);`
+ 参数：
  + `ap` -- 这是一个 `va_list` 类型的对象，它用来存储通过 `va_arg` 获取额外参数时所必需的信息
  + `last_arg` -- 最后一个传递给函数的已知的固定参数
+ 返回值：空

### va_arg()

+ 功能：
  + C 库宏 `type va_arg(va_list ap, type)` 检索函数参数列表中类型为 `type` 的下一个参数。
  + 它无法判断检索到的参数是否是传给函数的最后一个参数
+ 原型：`type va_arg(va_list ap, type);`
+ 参数：
  + `ap`   -- 这是一个 `va_list` 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 `va_arg` 之前通过调用 `va_start` 进行初始化
  + `type` -- 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。
+ 返回值：
  + 该宏返回下一个额外的参数，是一个类型为 `type` 的表达式

### va_end()

+ 功能：
  + C 库宏 `void va_end(va_list ap)` 允许使用了 `va_start` 宏的带有可变参数的函数返回。
  + 如果在从函数返回之前没有调用 `va_end`，则结果为未定义
+ 原型：`void va_end(va_list ap);`
+ 参数：
  + `ap` -- 这是之前由同一函数中的 `va_start` 初始化的 `va_list` 对象
+ 返回值：空

## vsnprintf()

+ 功能：将可变参数列表的格式化数据写入到大小为`n`的缓冲区
+ 原型：`int vsnprintf(char *s, size_t n, const char *format, va_list arg);`
+ 参数：
  + `s`  --  指向存储C字符串的缓冲区指针
  + `n`  --  缓冲区最大可用的字节数
  + `format`  --  包含格式化字符串的C字符串，和printf()相同
  + `arg`--  识别使用`va_start`初始化的可变参数列表的值
+ 返回值：
  + 成功  --  被写入的字符数`n`
  + 失败  --  -1

## sort()

+ 功能：对在范围`[first, last]`内的元素进行排序，不能保证保留同等元素的顺序  
+ 原型：
  + `template <class RandomIt>, class <Compare>`
  + `void sort(RandomIt first, RandomIt last, Compare comp);`
+ 参数：
  + `first`  --  排序元素范围的开始
  + `last`   --  排序元素范围的结束
  + `comp`   --  比较函数对象（即满足比较要求的对象）
+ 返回值：空
+ 需求：
  + 头文件：`#include <algorithm>`

## sqrt()

+ 功能：返回x的平方根
+ 原型：`double sqrt(double x);`
+ 参数：
  + `x`  --  需要处理的浮点数
+ 返回值：
  + 成功  --  x的平方根
+ 需求：
  + 头文件：`#include <math.h>`

## opendir()

+ 功能：打开一个目录文件
+ 原型：`DIR *opendir(const char *dirname);`
+ 参数：
  + `dirname`  --  目录
+ 返回值：
  + 成功  --  返回一个指向目录对象的指针
  + 失败  --  返回一个空指针，并设置errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + 定义在dirent.h中的DIR类型，表示的是一个**目录流**(directory stream)
  + 目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的

## readdir()

+ 功能：读取一个目录文件中的数据
+ 原型：`struct dirent *readdir(DIR *dirp);`
+ 参数：
  + `dirp`  --  目录对象的指针
+ 返回值：
  + 成功  --  返回一个指向`struct dirent`结构的指针，结构中包含了与下一个目录项有关的信息
  + 失败  --  返回一个NULL指针，并设置errno
    + `readdir()`的实现必须检测的错误只有一种，就是要返回的结构中的值无法正确表达，其错误码是`EOVERFLOW`
    + `readdir()`函数也返回NULL来指示目录的末尾，但在这种情况下它并不改变errno
+ 需求：
  + 头文件：`#include <dirent.h>`
+ 注意：
  + `readdir`在每次调用之后都将流转移到下一个位置上去

## stat()

+ 功能：通过名字来访问文件
+ 原型：`int stat(const char *restrict path, struct stat *restrict buf);`
+ 参数：
  + `path`  --  指定了需要返回状态的文件或符号链接的名字
  + `buf`   --  指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中
+ 返回值：
  + 成功  --  0
  + 失败  --  -1，并设置errno

## C++类的构造函数后加冒号

+ 例如：`Mat::Mat(const Mat &src):Mat();`

+ 单冒号的作用是：表示后面是初始化列表
+ 这样的写法一般有三种使用场景
  + 对父类进行初始化。
    + 目的：在创建子类对象时,能够把参数传给父类,从而先完成对父类的初始化.子类构造函数必须要调用父类的构造函数（无论显式还是隐式）
    + 调用格式：**`子类构造函数 : 父类构造函数`**
  + 对类成员进行初始化
    + 调用格式:`构造函数 : A(初始值),B(初始值),C(初始值)……`
  + 对类的const成员变量进行初始化
    + 由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或使用初始化列表赋值
+ 对于2、3中的应用场景，有以下两点说明
  + 构造函数列表初始化执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关
  + 相对于在构造函数中赋值，初始化列表执行效率更高。

## 强制转换运算符（强制类型转换）

+ 强制转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。
+ 强制转换运算符是一元运算符，它的优先级与其他一元运算符相同

+ 大多数的 C++ 编译器都支持大部分通用的强制转换运算符：
  + `(type) expression`
  + type 是转换后的数据类型

+ C++ 支持的其他几种强制转换运算符:
  + `const_cast<type> (expr)`: 
    + `const_cast` 运算符用于修改类型的 `const` / `volatile` 属性。
    + 除了 `const` 或 `volatile` 属性之外，目标类型必须与源类型相同。
    + 这种类型的转换主要是用来操作所传对象的 `const` 属性，可以加上 `const` 属性，也可以去掉 `const` 属性。
  + `dynamic_cast<type> (expr)`:
    + `dynamic_cast` 在运行时执行转换，验证转换的有效性。
    + 如果转换未执行，则转换失败，表达式 `expr` 被判定为 `null`
    + `dynamic_cast` 执行动态转换时，`type` 必须是类的指针、类的引用或者 `void*`
    + 如果 `type` 是类指针类型，那么 `expr` 也必须是一个指针，如果 `type` 是一个引用，那么 `expr` 也必须是一个引用
  + `reinterpret_cast<type> (expr)`:
    + `reinterpret_cast` 运算符把某种指针改为其他类型的指针。
    + 它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。
  + `static_cast<type> (expr)`:
    + `static_cast` 运算符执行非动态转换，没有运行时类检查来保证转换的安全性。
    + 例如，它可以用来把一个基类指针转换为派生类指针。

## limits.h头文件

## 接口和动态库

### 模块

模块的概念:
+ 在C++中可以认为每个二进制文件为一个模块.

接口/跨模块接口:
+ 模块自己内部调用比较简单,因为编译环境和平台都一致,不存在不兼容的问题
+ 如果想把我们的功能提供给其他人使用,就需要导出接口和动态库文件了
+ 每种语言有自己的接口定义形式,**接口在C或C++里就是一些头文件(.h)**,头文件里定义了结构体,函数等,供其他模块调用
+ 可以认为:模块由接口和二进制文件组成
    + windows编译出来的dll肯定不能在linux上调用,32位编译出的dll又不能被64位程序调用,Debug模式和Release模式也存在很多差异
    + C++不像Java,Java是编译一次在任意操作系统和平台都能跑起来;C++则是,不同操作系统,不同CPU,不同系统位数,甚至不同优化参数,编译出来的二进制文件都不能通用

动态库:
+ 一个"程序函数库"简单的说:就是一个文件包含了一些编译好的代码和数据,这些编译好的代码和数据可以在事后供其他的程序使用
+ 动态库就是编译好的,可供其他模块调用的二进制文件.在windows是dll形式,在类Unix是so形式
+ 动态库相比源码和静态库有以下优势:
      1. 若以源码或静态库方式提供给别人使用,如果后期有一个bug需要修改,那么所有调用者都需要重新编译,测试,打包发布,成本很高.
      2. 以动态库方式提供,使用者只需要替换dll或so即可,简单高效
+ 动态库的劣势:
      + 动态库版本维护比较麻烦,需要思考如何避免"dll地狱"

### 链接

+ 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程,这个文件可被**加载(复制)**到内存并执行.
+ 链接可以执行于编译时(compile time),也就是在源代码被翻译成机器代码时;也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时;甚至执行于运行时(run time),也就是由应用程序来执行

为了构造可执行文件,链接器必须完成两个主要任务:
1. 符号解析(symbol resolution). 目标文件定义和引用符号,每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是讲每个符号**引用**正好和一个符号**定义**关联起来
2. 重定位(relocation). 编译器和汇编器生成从地址0开始的代码和数据节. 链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位

关于链接器的一些基本事实:
+ 目标文件纯粹是字节块的集合
+ 这些块中,有些包含程序代码,有些包含程序数据,而其他的则包含引导链接器和加载器的数据结构
+ 链接器将这些块连接起来,确定被连接块的运行时位置,并且修改代码和数据块中的各种位置
+ 链接器对目标机器了解甚少,产生目标文件的编译器和汇编器已经完成了大部分工作

目标文件有三种形式:
1. 可重定位目标文件.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件
2. 可执行目标文件. 包含二进制代码和数据,其形式可以被直接复制到内存并执行
3. 共享目标文件,一种特殊类型的可重定位目标文件,可以再加载或者运行时被动态地加载进内存并链接.

+ 编译器和汇编器生成可重定位目标文件(包含共享目标文件),链接器生成可执行目标文件.
+ 从技术上来说,一个目标模块(object module)就是一个字节序列,而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块.(不过,一般会互换地使用这些术语)
+ 目标文件是按照特定的目标文件格式来组织的,各个系统的目标文件格式都不相同.现代x86-64Linux和Unix系统使用**可执行可链接格式(Executable and Linkable Format, ELF)**

静态库:
+ "迄今为止,我们都是假设链接器读取一组可重定位目标文件,并把它们链接起来,形成一个输出的可执行文件"
+ 实际上,所有的编译系统都提供一种机制,**将所有相关的目标模块打包成为一个单独的文件,称为静态库(static library)**
+ 静态库可以用做链接器的输入,当链接器构造一个输出的可执行文件时,它只复制静态库里被应用程序引用的目标模块.
+ 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
+ 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
+ 创建静态库需要用到一个工具:`AR`

链接器如何使用静态库来解析引用?
+ 在符号解析阶段,链接器**从左到右**按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(驱动程序自动将命令行中所有的.c文件翻译为.o文件).
  + 在这次扫描中,链接器维护一个**可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)**
  + 一个**未解析的符号集合U**(即引用了但是尚未定义的符号)
  + 一个在前面输入文件中**已定义的符号集合D**.(初始时,E,U和D均为空)
+ 解析的工作原理:
  1. 对于命令行上的每个输入文件`f`,链接器会判断`f`是一个目标文件还是一个存档文件.如果`f`是一个目标文件,那么链接器把`f`添加到`E`,修改`U`和`D`来反应`f`中的符号定义和引用,并继续下一个输入文件
  2. 如果`f`是一个存档文件,那么链接器就尝试匹配`U`中未解析的符号和由存档文件成员定义的符号.如果某个存档文件成员`m`,定义了一个符号来解析`U`中的一个引用,那么就将`m`加到`E`中,并且链接器修改`U`和`D`来反应`m`中的符号定义和引用.对存档文件中所有的成员目标文件都依次进行这个过程,直到`U`和`D`都不再发生变化.此时,任何不包含在`E`中的成员目标文件都简单地被丢弃,而链接器将继续处理下一个输入文件.
  3. 如果当链接器完成对命令行上输入文件的扫描后,`U`是非空的,那么链接器就会输入一个错误并终止.否则,它会合并和重定位`E`中的目标文件,构建输出的可执行文件.
+ 关于库的一般准则是将它们放在命令行的结尾

加载可执行目标文件:`linux> ./program`
+ 因为`program`不是一个内置的shell命令,所以shell会认为`program`是一个可执行目标文件,通过调用某个驻留在存储器中称为**加载器(loader)**的操作系统代码来运行它.任何Linux程序都可以通过调用`execve函数`来调用加载器
+ 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或入口点来运行该程序,这个将程序复制到内存并运行的过程叫做**加载**

共享库(shared library)
+ 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
+ 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**
+ 调用编译器驱动程序,给编译器和链接器相关指令:`linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c`
  + `-shared`选项:指示链接器创建一个共享的目标文件
  + `-fpic`  选项:指示编译器生成与位置无关的代码
+ 在程序中调用共享库:`linux> gcc -o prog21 main2.c ./libvector.so`. 
+ 基本的思路是当创建可执行文件时,静态执行一些链接,然后在程序加载时,动态完成链接过程.**认识到这一点是很重要的**:此时,没有任何`libvector.so`的代码和数据节真的被复制到可执行文件`prog21`中.反之,链接器复制了一些重定位和符号表信息,它们使得运行时可以解析对`libvector.so`中代码和数据的引用.

位置无关代码
+ 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码,因而节约宝贵的内存资源.
+ 可以接在而无需重定位的代码称为**位置无关代码(Position-Independent Code, PIC)**,用户对GCC使用`-fpic`选项指示GNU编译系统生成PIC代码,共享库的编译必须总是使用该选项.

+ **处理目标文件的工具(GNU binutils包)**
  1. AR: 创建静态库,插入,删除,列出和提取成员
  2. STRINGS: 列出一个目标文件中所有可打印的字符串
  3. STRIP: 从目标文件中删除符号表信息
  4. NM:列出一个目标文件的符号表中定义的符号
  5. SIZE: 列出目标文件中节的名字和大小
  6. READELF:显示一个目标文件的完整结构,包括ELF头中编码的所有信息,包含SIZE和NM的功能
  7. OBJDUMP:所有二进制工具之母,能够显示一个目标文件中所有的信息,它最大的作用是反汇编`.text`节中的二进制指令
  8. LDD:列出了一个可执行文件在运行时所需要的共享库.

### 小结
+ 链接可以在编译时由静态编译期来完成,也可以在加载时和运行时由动态链接器来完成.
+ 链接器处理称为目标文件的二进制文件,它有三种不同的形式:可重定位的,可执行的和共享的.
  1. 可重定位的目标文件由静态链接器合并成一个可执行的目标文件,它可以加载到内存中并执行
  2. 共享目标文件(共享库)是在运行时由动态链接器链接和加载的,或者隐含地在调用程序被加载和开始执行时,或者根据需要在程序调用`dlopen库`的函数时
+ 链接器的两个主要任务是符号解析和重定位.
  1. 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义,
  2. 重定位确定每个符号的最终内存地址,并修改对那些目标的引用
+ 静态链接器是由像GCC这样的编译驱动程序调用的,它们将多个可重定位目标文件合并成一个单独的可执行目标文件.多个目标文件可以定义相同的符号,而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误
+ 多个目标文件可以被连接到一个单独的静态库中,链接器用库来解析其他目标模块中的符号引用,许多链接器通过从左到右的顺序扫描来解析符号引用,这是另一个引起令人迷惑的链接时错误的来源
+ 加载器将可执行文件的内容映射到内存,并运行这个程序.链接器还可能生成部分链接的可执行目标文件,这样的文件中有对定义在共享库中的例程和数据的未解析的引用.在加载时,加载器将部分链接的可执行文件映射到内存,然后调用动态链接器,它通过加载共享库和重定位程序中的引用来完成链接任务

## 交叉编译(cross compiler) 本地编译(native compiler)

### Linaro

+ Linaro从2010年开始推动Arm上的开源软件开发，提供工具，Linux内核质量和安全性。
+ Linaro与成员公司和开源社区合作，维护Arm软件生态系统，在Arm架构上开拓新市场。


+ GCC的命令规则为：`arch[-vendor][-os][-(gnu)eabi]-gcc`
  + 带`[]`是可选部分
  + `arch` : 芯片架构，例如32位的Arm架构对应的arch为arm，64位的Arm架构对应的arch为aarch64
  + `vendor` ： 工具链提供商，大部分工具链名字里面都没有包含这部分
  + `os` : 编译出来的可执行文件（目标文件）针对的操作系统

+ 例如`arm-linux-gnueabi-gcc`, `arm-none-eabi-gcc`, `aarch64-linux-gnu-gcc`

### vscode的launch.json文件:

+ `name`:调试的项目名
+ `program`:应用程序路径,这个最好放在**共享目录**,和板子使用同一个文件
+ `cwd`:程序源代码路径(**重要**)
+ `miDebuggerPath`:交叉编译工具中的gdb
+ `miDebuggerServerAddress`:远程gdbserver服务,根据设备对应修改

### `gdbserver`使用方法，与PC机xxx-gdb搭配使用

+ 开发板：`gdbserver <ip address> <listening port> <program>`
  + 例如：`gdbserver 192.167.66.112:9999 demo_02.exe`
  + 需要注意的一点是：需要调试的程序在编译时记得加上`-g`参数

+ PC机:在终端中输入`aarch64-linux-gnu-gdb`之后进入gdb调试模式，然后输入`target remote ip-address:port`即可连接远程目标

+ 交叉编译，程序的参数是从gdbserver 传进来的，其原理就是将调试信息通过端口发送到远程

## 多核编程

+ 编译指导语句的含义是在编译器编译程序的时候，会识别特定的注释
+ 编译指导语句的形式为
  + `#pragam omp <directive> [clause[[,] clause]. . .]`
  + 其中`directive`部分就包含了具体的编译指导语句，包括`parallel`, `for`, `parallel for`, `section`, `sections`, `single`, `master`, `critical`, `flush`, `ordered`和`atomic`
  + 这些编译指导语句或者用来分配任务，或者用来同步
  + 子句可以影响到编译指导语句的具体行为，每一个编译指导语句都有一系列适合它的子句。
  + **其中`parallel`、`for`、`sections`、`section`等主要用来创建线程**

+ 在C/C++程序中，用`#pragma omp parallel`来标志一段并行程序块

## 工程化代码和编程

+ 什么是编程和工程项目？
  + 编程（是编定程序的中文简称），就是让计算机代为解决某个问题，对某个计算体系规定一定的运算方式，使计算体系按照该计算方式运行，并最终得到相应结果的过程
  + 软件工程，（即咱们程序员经常口头说的**项目**），从软件开发的观点看，它就是使用适当的资源（包括人员，软硬件资源，时间等），为开发软件进行的一组开发活动，在活动结束时输入（即用户的需求）转化为输出（最终符合用户需求的软件产品）

+ 重要的三个阶段
  + 定义阶段：可行性研究初步项目计划、需求分析
  + 开发阶段：概要设计、详细设计、实现、测试
  + 运行和维护阶段：运行、维护、废弃

+ 编程和工程的区别？
  + 编程只是对某种问题的计算机解决方法，而工程却涉及到客户需求、人员、软硬件资源、时间、产品产出
  + 只有更好地了解整个工程流程，才能知道每个阶段需要干什么，客户需求什么，输出的产品是什么，才能轻松在给定时间内写出代码

+ 编写工程化代码需要注意：版本控制，接手项目，代码规范性和安全性，开发新项目

### 版本控制

+ 版本控制分三个部分——硬件资源环境、开发工具版本控制、程序版本控制
  
+ 硬件资源环境，
  + 不能只考虑自己电脑性能和程序能否在自己电脑运行。
  + 首先要确定运行工程代码的硬件环境是windows、还是linux、某个手机平台、或者arm开发板，其次确定是32位还是64位

+ 开发工具版本控制，
  + 只要和整个开发团队保持一致即可，
  + 如果只是你一个人使用的开发工具，不要追求最新、不稳定版本

+ 程序版本控制，这个最为重要。
  + 一般，公司都会有自己的版本控制服务器svn、github等，但我要说的是自己的程序版本控制，
  + 一般上传到服务器上的都是几经考验的稳定版本，但不排除有时候有些新修改漏斗没有觉察到或者自己需要恢复到某个阶段重新开发，这个时候有备份就至关重要了，
  + 所以每一个版本无论好坏都要给自己备份一下，有时候在关键时刻会助你一臂之力

### 接手项目

+ 接手项目，首先备份当前版本（版本控制的重要性）
+ 接着确认大环境，查看平台，动静态链接库是否齐全，配置文件是否还在，尝试编译运行一下能否通过，确认无误后再阅读代码，有问题了尽快请教。
+ **阅读代码时**，先不要急于看每个功能如何实现，先把整个逻辑流程过一遍，找到自己业务的模块，再将该模块实现功能仔细阅读，并单独实现，最后再加以改进

+ **构思代码**。为什么是构思代码，而不是写代码，因为直接写代码是没有灵魂的（大神除外）
+ 构思代码的好处是
  + 先把架构定下来，输入什么，输出什么，用什么数据结构和方法实现，
  + 这样不仅有助于接下来的编码，而且不容易反复推翻修改，三思而后动就是这个道理，这也有助于锻炼架构师思维

### 代码规范性和安全性

+ 很多大公司都有自己的一套编码规范。不论公司有没有规范，自己必须有一套符合大众的编码规范
+ 不仅代码看起来赏心悦目，方便问题查找，而且也便于以后阅读和维护，最重要的是代码可以烂，气势不能输

+ 代码的安全性分两个方面：代码自身的安全性和程序代码的安全性

+ 代码自身的安全性主要是指不要使用不安全的库函数、指针等
  + 编程语言也是代码，也会有bug，只是我们水平太菜，没发现而已。
  + 但是已经有很多前辈帮我们踏过这些雷区，我们需要的就是偶尔关注一下版本更替的说明和多看大神们的经验，避免使用那些具有安全隐患的库函数，
  + 尤其是在使用指针时，须慎重，如无必要，，不要耍酷（大神除外），血的教训告诉我指针引发的问题是最隐蔽的

+ 代码的安全性防范是写工程代码必须考虑的。
  + 程序代码的安全性就比较简单了，把自己的程序尽量封装成接口，这样既可以防止别人随意改动你的代码，也便于管理维护

### 开发新项目

+ 首先，分析需求，谨记一句话：**如无必要，不要自作多情**
  + 严格控制需求，仔细分析，清楚需求要做到什么程度，不要为了彰显自己半瓶水的功力，提升难度，补充需求
  + 本来让你做个人脸识别，你非要加个活体检测，结果GG了。学习研究可以挑战下自我，做工程就不必装×了

+ 其次，构思框架，三思而后行
  + 架构很重要，人有骨架，楼房也有钢筋，一个好的框架，可抗八级地震，减少二次开发的次数，提高运行效率，这些都不需要我们管，那是大佬构思的事情。
  + 我们要构思的是，如何采集数据，采集完数据，如何保存数据，分析数据，产出结果，结果如何展示给客户

+ 然后，确定环境

+ 接着，大环境确认了，就是详细设计
  + 输入什么，输出什么，数据格式，中间流经几个模块，实现方法，故障处理，实时性要求等等
  + 流程走下来，剩下就是填充代码和反复测试。最后，演示检验

### 谨记

+ 编程是练基本功的，工程是练思路和管理的，思路不行，永远只是个码农，基本功不扎实，思路再好也出不来干货，切勿眼高手低

## C++11 lambda匿名函数

### 概述

+ lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则是被用来表示一种匿名函数
+ 所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式

### 详解

+ lambda匿名函数的定义
  + `[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型 { 函数体; };`
+ 其中各部分的含义分别为：
  + 1) `[外部变量方位方式说明符]`
    + `[ ]` 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。
    + 所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。
  + 2) `(参数)`
    + 和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；
  + 3) `mutable`
    + 此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。
    + 默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）
    + 而如果想修改它们，就必须使用 mutable 关键字。
    + 对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；
  + 4) `noexcept/throw()`
    + 可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。
    + 默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。
    + 而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；
    + 使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。
    + 如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败
  + 5) `-> 返回值类型`
    + 指明 lambda 匿名函数的返回值类型
    + 如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略-> 返回值类型。
  + 6) 函数体
    + 和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。
    + 该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量
    + 外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。
    + 换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。
+ 定义了一个最简单的 lambda 匿名函数
  + `[]{}`
  + 显然，此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。
  + 所以，这是一个没有任何功能的 lambda 匿名函数。

+ lambda匿名函数中的`[外部变量]`
  + `[]`  --  空方括号表示当前 lambda 匿名函数中不导入任何外部变量。
  + `[=]` --  只有一个 = 等号，表示以值传递的方式导入所有外部变量；
  + `[&]` --  只有一个 & 符号，表示以引用传递的方式导入所有外部变量；
  + `[val1, val2, ...]`   --  表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；
  + `[&val1, &val2, ...]` --  表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；
  + `[val, &val2, ...]`   --  以上 2 种方式还可以混合使用，变量之间没有前后次序。
  + `[=, &val1, ...]`     --  表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。
  + `[this]`  --  **表示以值传递的方式导入当前的 this 指针**
+ **注意**:
  + 单个外部变量不允许以相同的传递方式导入多次。例如 `[=，val1]` 中，val1 先后被以值传递的方式导入了 2 次，这是非法的