## strrchr()

+ 功能：在参数 `str` 所指向的字符串中搜索最后一次出现字符 `c`（一个无符号字符）的位置
+ 原型：`char* strrchr(const char *str, int c);`
+ 参数：
  + `str`  --  C字符串
  + `c`    --  要搜索的字符。以 `int` 形式传递，但是最终会转换回 `char` 形式
+ 返回值：
  + 成功  --  返回`str`中最后一次出现字符`c`的位置
  + 失败  --  没有找到该值，返回一个空指针
+ 需求：
  + 头文件：`#include <string.h>`

## pipe()

+ 功能：创建单项通信通道(管道)
+ 原型：`int pipe(int *__pipedes);`
  + 如果成功，两个文件描述符存储在`pipedes`中
  + `pipedes[1]`上写入的字节可以从`pipedes[0]`中读取
+ 参数：
  + `__pipedes`  --  数组
+ 返回值：
  + 成功  --  0
  + 失败  --  -1
+ 需求：
  + 头文件：`#include <unistd.h>`

## fork()

+ 功能：克隆调用进程，创建一个精确的副本。
+ 原型：`pid_t fork();`
+ 参数：无
+ 返回值：
  + 成功  --  新进程返回 0，或者新进程对旧进程的进程ID
  + 失败  --  -1

## execl()

+ 功能：使用参数`arg`以及之后的参数 执行`path`
+ 原型：`int execl(const char* path, const char* arg,...);`
+ 参数：
  + `path`  --  要执行的文件
  + `arg`   --  执行的参数
+ 返回值：
  + 成功  --
  + 失败  --

## _exit()

+ 功能：使用`__status`的`low-order 8 bits`终止程序执行
+ 原型：`void _exit(int __status);`
+ 参数：
  + `__status`  --  
+ 返回值：

## waitpid()

+ 功能：等待进程为`pid`的子进程死亡， 
+ 原型：`pid_t waitpid(pid_t  pid, int* stat_loc, int options);`
+ 参数：
  + `pid`  --  等待的进程
    + pid有四种情况：
      + pid <  -1 等待组ID等于pid绝对值的任意子进程
      + pid == -1 等待任意子进程
      + pid == 0  等待组ID等于调用进程组ID的任意子进程
      + pid >  0  等待进程ID与pid相等的子进程
  + `stat_loc`  --  指向终止进程的终止状态，如果不关心终止状态可指定为空指针
  + `options`   --  控制waitpid的操作
    + WCONTINUED
    + WUNTRACED
    + WNOHANG  waitpid不阻塞
+ 返回值：
  + 成功  --  返回pid，并将子进程的状态存储到`stat_loc`中
  + 失败  --  -1

## mkstemp()

+ 功能：根据`__tmplate`生成唯一的临时文件名
+ 原型：`int mkstemp(char *__template);`
+ 参数：
  + `__tmplate`  --  需要操作的文件
+ 返回值：
  + 成功  --  返回在文件上打开的用于读取和写入的文件描述符
  + 失败  --  -1 （如果它不能创建一个唯一的文件名）

## openlog()

+ 功能：此函数用来打开一个到系统日志记录程序的连接，打开之后就可以用`syslog`或`vsyslog`函数向系统日志里添加信息了。而`closelog`函数就是用来关闭此连接的
+ 原型：`void openlog(const char *ident, int option, int facility);`
+ 参数：
  + `ident`  --  一个标记，`ident`所表示的字符串将固定地加在每行日志的前面以标识这个日志，通常就写成当前程序的名称以作标记
  + `option` --  参数option是下列值取与运算的结果：
    + `LOG_CONS，LOG_NDELAY， LOG_NOWAIT， LOG_ODELAY， LOG_PERROR，LOG_PID`
    + 各值意义请参考`man openlog`手册
  + `facility`  --  指明记录日志的程序的类型
+ 返回值：空

## setlogmask()

+ 功能：设置日志掩码级别
+ 原型：`int setlogmask(int mask);`
+ 参数：
  + `mask`  --  
+ 返回值：
  + 成功  --  
  + 失败  -- 

## C 标准库 `<stdarg.h>`

+ `stdarg.h` 头文件定义了一个变量类型 `va_list` 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。
+ 可变参数的函数通在参数列表的末尾是使用省略号`(,...)`定义的

### 库变量 -- va_list

+ 功能：这是一个适用于 `va_start()`、`va_arg()` 和 `va_end()` 这三个宏存储信息的类型
+ 声明：`typedef _G_va_list va_list;`

### va_start()

+ 功能：
  + C 库宏 `void va_start(va_list ap, last_arg)` 初始化 `ap` 变量，它与 `va_arg` 和 `va_end` 宏是一起使用的
  + `last_arg` 是最后一个传递给函数的已知的固定参数，即**省略号之前的参数**
  + 这个宏必须在使用 `va_arg` 和 `va_end` 之前被调用
+ 原型：`void va_start(va_list ap, last_arg);`
+ 参数：
  + `ap` -- 这是一个 `va_list` 类型的对象，它用来存储通过 `va_arg` 获取额外参数时所必需的信息
  + `last_arg` -- 最后一个传递给函数的已知的固定参数
+ 返回值：空

### va_arg()

+ 功能：
  + C 库宏 `type va_arg(va_list ap, type)` 检索函数参数列表中类型为 `type` 的下一个参数。
  + 它无法判断检索到的参数是否是传给函数的最后一个参数
+ 原型：`type va_arg(va_list ap, type);`
+ 参数：
  + `ap`   -- 这是一个 `va_list` 类型的对象，存储了有关额外参数和检索状态的信息。该对象应在第一次调用 `va_arg` 之前通过调用 `va_start` 进行初始化
  + `type` -- 这是一个类型名称。该类型名称是作为扩展自该宏的表达式的类型来使用的。
+ 返回值：
  + 该宏返回下一个额外的参数，是一个类型为 `type` 的表达式

### va_end()

+ 功能：
  + C 库宏 `void va_end(va_list ap)` 允许使用了 `va_start` 宏的带有可变参数的函数返回。
  + 如果在从函数返回之前没有调用 `va_end`，则结果为未定义
+ 原型：`void va_end(va_list ap);`
+ 参数：
  + `ap` -- 这是之前由同一函数中的 `va_start` 初始化的 `va_list` 对象
+ 返回值：空

## vsnprintf()

+ 功能：将可变参数列表的格式化数据写入到大小为`n`的缓冲区
+ 原型：`int vsnprintf(char *s, size_t n, const char *format, va_list arg);`
+ 参数：
  + `s`  --  指向存储C字符串的缓冲区指针
  + `n`  --  缓冲区最大可用的字节数
  + `format`  --  包含格式化字符串的C字符串，和printf()相同
  + `arg`--  识别使用`va_start`初始化的可变参数列表的值
+ 返回值：
  + 成功  --  被写入的字符数`n`
  + 失败  --  -1

## sort()

+ 功能：对在范围`[first, last]`内的元素进行排序，不能保证保留同等元素的顺序  
+ 原型：
  + `template <class RandomIt>, class <Compare>`
  + `void sort(RandomIt first, RandomIt last, Compare comp);`
+ 参数：
  + `first`  --  排序元素范围的开始
  + `last`   --  排序元素范围的结束
  + `comp`   --  比较函数对象（即满足比较要求的对象）
+ 返回值：空
+ 需求：
  + 头文件：`#include <algorithm>`

## sqrt()

+ 功能：返回x的平方根
+ 原型：`double sqrt(double x);`
+ 参数：
  + `x`  --  需要处理的浮点数
+ 返回值：
  + 成功  --  x的平方根
+ 需求：
  + 头文件：`#include <math.h>`

## 接口和动态库

### 模块

模块的概念:
+ 在C++中可以认为每个二进制文件为一个模块.

接口/跨模块接口:
+ 模块自己内部调用比较简单,因为编译环境和平台都一致,不存在不兼容的问题
+ 如果想把我们的功能提供给其他人使用,就需要导出接口和动态库文件了
+ 每种语言有自己的接口定义形式,**接口在C或C++里就是一些头文件(.h)**,头文件里定义了结构体,函数等,供其他模块调用
+ 可以认为:模块由接口和二进制文件组成
    + windows编译出来的dll肯定不能在linux上调用,32位编译出的dll又不能被64位程序调用,Debug模式和Release模式也存在很多差异
    + C++不像Java,Java是编译一次在任意操作系统和平台都能跑起来;C++则是,不同操作系统,不同CPU,不同系统位数,甚至不同优化参数,编译出来的二进制文件都不能通用

动态库:
+ 一个"程序函数库"简单的说:就是一个文件包含了一些编译好的代码和数据,这些编译好的代码和数据可以在事后供其他的程序使用
+ 动态库就是编译好的,可供其他模块调用的二进制文件.在windows是dll形式,在类Unix是so形式
+ 动态库相比源码和静态库有以下优势:
      1. 若以源码或静态库方式提供给别人使用,如果后期有一个bug需要修改,那么所有调用者都需要重新编译,测试,打包发布,成本很高.
      2. 以动态库方式提供,使用者只需要替换dll或so即可,简单高效
+ 动态库的劣势:
      + 动态库版本维护比较麻烦,需要思考如何避免"dll地狱"

### 链接

+ 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程,这个文件可被**加载(复制)**到内存并执行.
+ 链接可以执行于编译时(compile time),也就是在源代码被翻译成机器代码时;也可以执行于加载时(load time),也就是在程序被加载器(loader)加载到内存并执行时;甚至执行于运行时(run time),也就是由应用程序来执行

为了构造可执行文件,链接器必须完成两个主要任务:
1. 符号解析(symbol resolution). 目标文件定义和引用符号,每个符号对应于一个函数,一个全局变量或一个静态变量.符号解析的目的是讲每个符号**引用**正好和一个符号**定义**关联起来
2. 重定位(relocation). 编译器和汇编器生成从地址0开始的代码和数据节. 链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得它们指向这个内存位置.链接器使用汇编器产生的重定位条目(relocation entry)的详细指令,不加甄别地执行这样的重定位

关于链接器的一些基本事实:
+ 目标文件纯粹是字节块的集合
+ 这些块中,有些包含程序代码,有些包含程序数据,而其他的则包含引导链接器和加载器的数据结构
+ 链接器将这些块连接起来,确定被连接块的运行时位置,并且修改代码和数据块中的各种位置
+ 链接器对目标机器了解甚少,产生目标文件的编译器和汇编器已经完成了大部分工作

目标文件有三种形式:
1. 可重定位目标文件.包含二进制代码和数据,其形式可以在编译时与其他可重定位目标文件合并起来,创建一个可执行目标文件
2. 可执行目标文件. 包含二进制代码和数据,其形式可以被直接复制到内存并执行
3. 共享目标文件,一种特殊类型的可重定位目标文件,可以再加载或者运行时被动态地加载进内存并链接.

+ 编译器和汇编器生成可重定位目标文件(包含共享目标文件),链接器生成可执行目标文件.
+ 从技术上来说,一个目标模块(object module)就是一个字节序列,而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块.(不过,一般会互换地使用这些术语)
+ 目标文件是按照特定的目标文件格式来组织的,各个系统的目标文件格式都不相同.现代x86-64Linux和Unix系统使用**可执行可链接格式(Executable and Linkable Format, ELF)**

静态库:
+ "迄今为止,我们都是假设链接器读取一组可重定位目标文件,并把它们链接起来,形成一个输出的可执行文件"
+ 实际上,所有的编译系统都提供一种机制,**将所有相关的目标模块打包成为一个单独的文件,称为静态库(static library)**
+ 静态库可以用做链接器的输入,当链接器构造一个输出的可执行文件时,它只复制静态库里被应用程序引用的目标模块.
+ 在Linux系统中,静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中.
+ 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置.存档文件名由后缀`.a`标识.
+ 创建静态库需要用到一个工具:`AR`

链接器如何使用静态库来解析引用?
+ 在符号解析阶段,链接器**从左到右**按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(驱动程序自动将命令行中所有的.c文件翻译为.o文件).
  + 在这次扫描中,链接器维护一个**可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)**
  + 一个**未解析的符号集合U**(即引用了但是尚未定义的符号)
  + 一个在前面输入文件中**已定义的符号集合D**.(初始时,E,U和D均为空)
+ 解析的工作原理:
  1. 对于命令行上的每个输入文件`f`,链接器会判断`f`是一个目标文件还是一个存档文件.如果`f`是一个目标文件,那么链接器把`f`添加到`E`,修改`U`和`D`来反应`f`中的符号定义和引用,并继续下一个输入文件
  2. 如果`f`是一个存档文件,那么链接器就尝试匹配`U`中未解析的符号和由存档文件成员定义的符号.如果某个存档文件成员`m`,定义了一个符号来解析`U`中的一个引用,那么就将`m`加到`E`中,并且链接器修改`U`和`D`来反应`m`中的符号定义和引用.对存档文件中所有的成员目标文件都依次进行这个过程,直到`U`和`D`都不再发生变化.此时,任何不包含在`E`中的成员目标文件都简单地被丢弃,而链接器将继续处理下一个输入文件.
  3. 如果当链接器完成对命令行上输入文件的扫描后,`U`是非空的,那么链接器就会输入一个错误并终止.否则,它会合并和重定位`E`中的目标文件,构建输出的可执行文件.
+ 关于库的一般准则是将它们放在命令行的结尾

加载可执行目标文件:`linux> ./program`
+ 因为`program`不是一个内置的shell命令,所以shell会认为`program`是一个可执行目标文件,通过调用某个驻留在存储器中称为**加载器(loader)**的操作系统代码来运行它.任何Linux程序都可以通过调用`execve函数`来调用加载器
+ 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中,然后通过跳转到程序的第一条指令或入口点来运行该程序,这个将程序复制到内存并运行的过程叫做**加载**

共享库(shared library)
+ 共享库是一个目标模块,在运行或加载时,可以加载到任意的内存地址,并和一个在内存中的程序链接起来,这个过程称为**动态链接(dynamic linking)**,是由一个叫做**动态链接器(dynamic linker)**的程序来执行的
+ 共享库也称为共享目标(share object),在Linux系统中通常用`.so`后缀来表示;微软的操作系统大量地使用了共享库,它们称为**DLL(动态链接库)**
+ 调用编译器驱动程序,给编译器和链接器相关指令:`linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c`
  + `-shared`选项:指示链接器创建一个共享的目标文件
  + `-fpic`  选项:指示编译器生成与位置无关的代码
+ 在程序中调用共享库:`linux> gcc -o prog21 main2.c ./libvector.so`. 
+ 基本的思路是当创建可执行文件时,静态执行一些链接,然后在程序加载时,动态完成链接过程.**认识到这一点是很重要的**:此时,没有任何`libvector.so`的代码和数据节真的被复制到可执行文件`prog21`中.反之,链接器复制了一些重定位和符号表信息,它们使得运行时可以解析对`libvector.so`中代码和数据的引用.

位置无关代码
+ 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码,因而节约宝贵的内存资源.
+ 可以接在而无需重定位的代码称为**位置无关代码(Position-Independent Code, PIC)**,用户对GCC使用`-fpic`选项指示GNU编译系统生成PIC代码,共享库的编译必须总是使用该选项.

+ **处理目标文件的工具(GNU binutils包)**
  1. AR: 创建静态库,插入,删除,列出和提取成员
  2. STRINGS: 列出一个目标文件中所有可打印的字符串
  3. STRIP: 从目标文件中删除符号表信息
  4. NM:列出一个目标文件的符号表中定义的符号
  5. SIZE: 列出目标文件中节的名字和大小
  6. READELF:显示一个目标文件的完整结构,包括ELF头中编码的所有信息,包含SIZE和NM的功能
  7. OBJDUMP:所有二进制工具之母,能够显示一个目标文件中所有的信息,它最大的作用是反汇编`.text`节中的二进制指令
  8. LDD:列出了一个可执行文件在运行时所需要的共享库.

### 小结
+ 链接可以在编译时由静态编译期来完成,也可以在加载时和运行时由动态链接器来完成.
+ 链接器处理称为目标文件的二进制文件,它有三种不同的形式:可重定位的,可执行的和共享的.
  1. 可重定位的目标文件由静态链接器合并成一个可执行的目标文件,它可以加载到内存中并执行
  2. 共享目标文件(共享库)是在运行时由动态链接器链接和加载的,或者隐含地在调用程序被加载和开始执行时,或者根据需要在程序调用`dlopen库`的函数时
+ 链接器的两个主要任务是符号解析和重定位.
  1. 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义,
  2. 重定位确定每个符号的最终内存地址,并修改对那些目标的引用
+ 静态链接器是由像GCC这样的编译驱动程序调用的,它们将多个可重定位目标文件合并成一个单独的可执行目标文件.多个目标文件可以定义相同的符号,而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误
+ 多个目标文件可以被连接到一个单独的静态库中,链接器用库来解析其他目标模块中的符号引用,许多链接器通过从左到右的顺序扫描来解析符号引用,这是另一个引起令人迷惑的链接时错误的来源
+ 加载器将可执行文件的内容映射到内存,并运行这个程序.链接器还可能生成部分链接的可执行目标文件,这样的文件中有对定义在共享库中的例程和数据的未解析的引用.在加载时,加载器将部分链接的可执行文件映射到内存,然后调用动态链接器,它通过加载共享库和重定位程序中的引用来完成链接任务

## 交叉编译(cross compiler) 本地编译(native compiler)

### Linaro

+ Linaro从2010年开始推动Arm上的开源软件开发，提供工具，Linux内核质量和安全性。
+ Linaro与成员公司和开源社区合作，维护Arm软件生态系统，在Arm架构上开拓新市场。


+ GCC的命令规则为：`arch[-vendor][-os][-(gnu)eabi]-gcc`
  + 带`[]`是可选部分
  + `arch` : 芯片架构，例如32位的Arm架构对应的arch为arm，64位的Arm架构对应的arch为aarch64
  + `vendor` ： 工具链提供商，大部分工具链名字里面都没有包含这部分
  + `os` : 编译出来的可执行文件（目标文件）针对的操作系统

+ 例如`arm-linux-gnueabi-gcc`, `arm-none-eabi-gcc`, `aarch64-linux-gnu-gcc`

### vscode的launch.json文件:

+ `name`:调试的项目名
+ `program`:应用程序路径,这个最好放在**共享目录**,和板子使用同一个文件
+ `cwd`:程序源代码路径(**重要**)
+ `miDebuggerPath`:交叉编译工具中的gdb
+ `miDebuggerServerAddress`:远程gdbserver服务,根据设备对应修改

### `gdbserver`使用方法，与PC机xxx-gdb搭配使用

+ 开发板：`gdbserver <ip address> <listening port> <program>`
  + 例如：`gdbserver 192.167.66.112:9999 demo_02.exe`
  + 需要注意的一点是：需要调试的程序在编译时记得加上`-g`参数

+ PC机:在终端中输入`aarch64-linux-gnu-gdb`之后进入gdb调试模式，然后输入`target remote ip-address:port`即可连接远程目标

+ 交叉编译，程序的参数是从gdbserver 传进来的，其原理就是将调试信息通过端口发送到远程

## 多核编程

+ 编译指导语句的含义是在编译器编译程序的时候，会识别特定的注释
+ 编译指导语句的形式为
  + `#pragam omp <directive> [clause[[,] clause]. . .]`
  + 其中`directive`部分就包含了具体的编译指导语句，包括`parallel`, `for`, `parallel for`, `section`, `sections`, `single`, `master`, `critical`, `flush`, `ordered`和`atomic`
  + 这些编译指导语句或者用来分配任务，或者用来同步
  + 子句可以影响到编译指导语句的具体行为，每一个编译指导语句都有一系列适合它的子句。
  + **其中`parallel`、`for`、`sections`、`section`等主要用来创建线程**

+ 在C/C++程序中，用`#pragma omp parallel`来标志一段并行程序块