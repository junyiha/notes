## 概述

### 1.1

+ 要编写通过计算机网络通信的程序，首先要确定这些程序相互通信所用的协议(protocol)
+ 在深入设计一个协议的细节之前，应该从高层次决断通信由哪个程序发起以及响应在何时产生

+ 举例来说，一般认为Web服务器程序是一个长时间运行的程序(即所谓的守护程序，daemon)

+ 同一网络应用的客户和服务器无需处于同一个局域网(local area network, LAN)
+ 两个局域网是使用路由器(router)连接到广域网(wide area network, WAN)
+ 路由器是广域网的架构设备。当今最大的广域网是因特网(Internet)
+ 许多公司也构建自己的广域网，而这些私有的广域网既可以连接到因特网，也可以不连接到因特网

### 1.2

+ socket函数创建一个网际(AF_INET)字节流(SOCK_STREAM)套接字，它是TCP套接字的花哨名字。
+ 该函数返回一个小整数描述符，以后的所有函数调用(例如connect和read)就用该描述符来标识这个套接字

+ 后面，将遇到术语套接字(socket)的许多不同用法。
+ 首先，正在使用的API称为套接字API(sockets API),socket函数就是套接字API的一部分
+ TCP套接字，它是TCP端点(TCP endpoint)的同义词
+ 如果socket函数调用失败，我们就调用自己的err_sys函数，放弃程序的运行
+ err_sys函数输出我们作为参数提供的出错消息以及所发生的系统错误的描述

### 1.3

+ connect函数应用于一个TCP套接字时，将与由它的第二个参数只想的套接字地址结构指定的服务器建立一个TCP连接。
+ 该套接字地址结构的长度也必须作为该函数的第三个参数指定，对于网际套接字地址结构，我们总是使用C语言的sizeof操作符由编译器来计算这个长度

### 1.4

+ 使用read函数读取服务器的应用，并用标准的I/O函数fputs输出结果。
+ 使用TCP时必须小心，因为TCP是一个没有记录边界的字节流协议。

+ 计算机网络各层对等实体间交换的单位信息，称为协议数据单元(protocol data unit, PDU)
+ 分节(segment)就是对应于TCP传输层的PDU
+ 按照协议与服务之间的关系，除了最底层(物理层)外，每层的PDU通过由紧邻下层提供给本层的服务接口，作为下层的服务数据单元(service data unit, SDU)传递给下层，并由下层间接完成本层的PDU交换
+ 应用层实体(例如客户和服务器进程)间交换的PDU称为应用数据(application data)，
+ 其中在TCP应用进程之间交换的是没有长度限制的单个双向字节流
+ 在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的单个记录(record)
+ 在SCTP应用进程之间交换的是没有总长度限制的单个或多个记录流

+ 传输层实体(例如对应某个端口的传输层协议代码的一次运行)间交换的PDU称为消息(message),其中TCP的PDU特称为分节(segment)。
+ 消息或分节的长度是有限的。
+ 在TCP传输层中，发送端TCP把来自应用进程的字节流数据(即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据)按顺序分割后封装在各个分节中传送给接收端TCP。
+ 其中，每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的最大分节大小(maximum segment size, MMS)以及外出接口的最大传输单元(maximum transmission unit, MTU)或外出路径的路径MTU(如果网络层具有路径MTU发现功能，例如IPv6)

+ 通常服务器返回包含所有26个字节的单个分节，但是如果数据量很大，我们就不能确保一次read调用能返回服务器的整个应答。
+ 因此从TCP套接字读取数据时，我们总是需要把read编写在某个循环中，当read返回0(表明对端关闭连接)或负值(表明发生错误)时终止循环

### 1.5

+ 网络层实体间交换的PDU，称为IP数据报(IP datagram)，其长度有限：IPv4数据报最大65535字节，IPv6数据包最大65575字节。
+ 发送端IP把来自传输层的消息(或TCP分节)整个封装在IP数据报中传送

+ 链路层实体间交换的PDU，称为帧(frame)，其长度取决于具体的接口。
+ IP数据报由IP首部和所承载的传输层数据(即网络层的SDU)构成
+ 过长的IP数据报无法封装在单个帧中，需要先对其SDU进行分片(fragmentation)，再把分成各个片段(fragment)冠以新的IP首部封装到多个帧中

+ 在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作，即重组(reassembly)一般只发生在目的端
+ SCTP为了传送过长的记录采取了类似的分片和重组措施
+ TCP/IP协议族为了提高效率会尽可能避免IP的分片/重组操作；TCP根据MSS和MTU限定每个分节的大小以及SCTP根据MTU分片/重组过长的记录都是这个目的
+ 不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中的数据称为，分组(packet, 俗称包)
+ 可见，一个分组既可能是一个完整的IP数据报，也可能是某个IP数据报的SDU的一个片段被冠以新的IP首部后的结果

+ 另外，
  + 本书讨论的MSS是应用层(TCP)与传输层之间的接口属性，
  + MTU则是网络层和链路层之间的接口属性

### 1.6

+ 任何现实世界的程序，都必须检查每个函数调用是否返回错误。

+ 既然发生错误时终止程序的运行是普遍的情况，我们可以通过定义包裹函数(wrapper function)来缩短程序。
+ 每个包括函数完成实际的函数调用，检查返回值，并在发生错误时终止进程
+ 我们约定的包裹函数是实际函数名的首字母大写形式，例如
  + `sockfd = Socket(AF_INET, SOCK_STREAM, 0);`
+ 其中，函数Socket是函数socket的包裹函数
  ```
    int Socket (int family, int type, int protocol) {
        int n;
        if ((n = socket(family, type, protocol)) < 0) {
            err_sys("socket error");
        }
        return n;
    }
  ```
+ 这些包裹函数不见得多节省代码量，但是当我们讨论线程时，将会发现线程函数遇到错误时，并不设置标准Unix的errno变量，而是把errno的值作为函数返回值返回调用者。
+ 这意味着每次调用以pthread_开头的某个函数时，我们必须分配一个变量来存放函数的返回值，以便在调用err_sys前把errno变量设置成该值。

### 1.7

+ 通过填写一个网际套接字地址结构并调用bind函数，服务器的众所周知端口被捆绑到所创建的套接字
+ 指定IP地址为INADDR_ANY，这样要是服务器主机有多个网络接口，服务器就可以在任意网络接口上接收客户端连接

+ 调用listen函数把该套接字转换成一个监听套接字，这样来自客户的外来连接就可在该套接字上由内核接受
+ socket, bind和listen这3个调用步骤是任何TCP服务器准备所谓的监听描述符(listening descriptor)的正常步骤
+ 常值LISTENQ在`unp.h`头文件中定义。它指定系统内核允许在这个监听描述符上排队的最大客户连接数

### 1.8

+ 通常情况下，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受
+ TCP连接使用所谓的三路握手(three-way handshake)来建立连接。
  + 三次握手在socket API中内部实现，调用该接口时，不需要关心(Unix system programming,line:1807)
+ 握手完毕时accept返回，其返回值是一个称为已连接描述符(connected descriptor)的新描述符
+ 该描述符用于与新近连接的那个客户端通信。
+ accept为每个连接到本服务器的客户端返回一个新描述符

### 1.9

+ 服务器通过调用close关闭与客户的连接。
+ 该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认

+ 总结
  + 如果服务器需要用较多时间服务每个客户，那么必须以某种方式重叠对各个客户的服务，这种服务器被称为迭代服务器(iterative server)。因为对于每个客户它都迭代执行一次
  + 同时能处理多个客户的并发服务器(concurrent server)有多种编写技术
    + 最简单的技术是调用Unix的fork函数，为每个客户创建一个子进程
    + 其他技术包括使用线程代替fork，或在服务器启动时预先fork一定数量的子进程

### 2.0

+ 描述一个网络中各个协议层的常用方法是使用国际标准化组织(International Organization for Standardization, ISO)的计算机通信开发系统互连(open systems interconnection, OSI)模型。
+ 这是一个七层模型：
  + 应用程
  + 表示层
  + 会话层
  + 传输层
  + 网络层
  + 数据链路层
  + 物理层

+ 我们认为OSI模型的底下两层是随系统提供的设备驱动程序和网络硬件。
+ 通常情况下，除需要知道数据链路的某些特性外，不必太关心这两层的具体情况

+ 网络层，由IPv4和IPv6这两个协议处理

+ 可以选择的传输层有TCP或UDP
+ TCP与UDP，之间留有缝隙，表明网络应用绕过传输层直接使用IPv4和IPv6是有可能的，这就是所谓的原始套接字(raw socket)

+ OSI模型的顶上三层被合并成一层，称为应用层。
+ 这就是Web客户(浏览器)，Telnet客户，Web服务器，FTP服务器和其他我们在使用的网络应用所在的层
+ 对于网际协议，OSI模型的顶上三层协议几乎没有区别

+ 本书讲述的套接字编程接口是从顶上三层(网际协议的应用程)进入传输层的接口
+ 本书的焦点是：如何使用套接字编写使用TCP或UDP的网络应用程序。

+ 为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口？
+ 这样设计有两个理由
  + 一，顶上三层处理具体网络应用的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和，等等
  + 二，顶上三层通常构成所谓的用户进程(user process)，底下四层却通常作为操作系统内核的一部分提供。Unix与其他现代操作系统都提供分隔用户进程和内核的机制。
  + 由此可见，第四层和第五层之间的接口是构建API的自然位置

### 2.1

+ POSIX(可移植操作系统接口)，是Portable Operating System Inteface的首字母缩写。
+ 它并不是单个标准，而是由电气与电子工程学会(the Institute for Electrical and Electronics Engineers Inc)即IEEE开发的一系列标准  
+ 具体可查看`http://www.pasc.org/standing/sdll.html`
    
