---
category: Books
date: 2024-10-17 09:00:00 +0800
last_modified_date: 2024-10-17 10:00:00 +0800
layout: post
title: C++程序设计语言 第1-3部分
tag: book
---
# 第一章 致读者

## 1.1 本书结构

+ 纯粹的入门教材通常会这样组织其内容--所有概念都先回介绍再应用，因此必须从第一页开始顺序阅读。与之相反，纯粹的参考手册则可以从任何地方开始查阅，因为每个主题的描述都简明扼要，辅以指向相关主题的引用。
+ 本书包含以下四个部分
  + 第一部分：第一章是本书的导引，会介绍一点C++的背景知识。第2-5章对C++语言及其标准库进行简要介绍
  + 第二部分：第6-15章介绍C++的内置类型和基本特性以及如何用他们构造程序
  + 第三部分：第16-29章介绍C++的抽象机制及如何用这些机制编写面向对象和泛型编程
  + 第四部分：第30-44章概述标准库并讨论一些兼容性问题。

### 1.1.1 引言

+ 接下来几章将要简要介绍C++程序设计语言及其标准库的主要概念和特性
  + 第二章：基础知识。介绍C++的内存模型，计算模型和错误处理模型
  + 第三章：抽象机制。介绍用来支持数据抽象，面向对象编程以及泛型编程的语言特性
  + 第四章：容器与算法。介绍标准库提供的字符串，简单I/O，容器和算法等特性
  + 第五章：并发和实用功能。概述与资源管理，并发，数字计算，正则表达式及其他一些方面相关的标准库工具

### 1.1.2 基本特性

+ C++支持传统的C语言编程风格，第二部分重点介绍支持C编程风格的C++子集，包括类型，对象，作用域和存储的基本概念。
  + 第六章：类型与声明。基础类型，命令，作用域，初始化，简单类型推断，对象生命周期和类型别名
  + 第七章：指针，数组与引用
  + 第八章：结构，联合与枚举
  + 第九章：语句。声明语句，选择语句，迭代语句，goto语句和注释语句
  + 第十一章：选择适当的操作。逻辑运算符，条件表达式，递增和递减，自由空间，{}列表，lambda表达式和显式类型转换
  + 第十二章：函数。函数声明和定义，inline函数，constexpr函数，实参传递，重载函数，前置和后置条件，函数的指针和宏
  + 第十三章：异常处理。错误处理风格，异常保证，资源管理，强制不变量，throw和catch，一个vector的实现
  + 第十四章：名字空间。namespace，模块化和接口，使用名字空间组织代码。
  + 第十五章：源文件与程序。分离编译，链接，使用头文件及程序启动和结束

### 1.1.3 抽象机制

+ 第三部分介绍的C++特性用来支持不同形式的抽象，包括面向对象编程和泛型编程。所有章节可以粗略分为三组：类，类继承和模板
  + 第十六章：类。用户自定义类型，也就是类的概念，是所有C++抽象机制的基础
  + 第十七章：构造，清理，拷贝和移动。展示了程序员如何定义类对象创建和初始化操作的含义。此外，拷贝，移动和析构的含义同样可由程序员来定义
  + 第十八章：运算符重载。介绍了为用户自定义类型指定运算符含义的规则，重点介绍常用的算术和逻辑运算符
  + 第十九章：特殊运算符。讨论用户自定义的非算术运算符的使用
  + 第二十章：派生类。介绍构建类层次的基本语言特性及其基本使用方法。我们可以实现接口(抽象类)与其实现(派生类)的完全分离，两者间的联系通过虚函数提供
  + 第二十一章：类层次。讨论有效的使用类层次的方法。
  + 第二十二章：运行时类型信息。介绍如何使用存储在对象中的数据实现在类层次中导航。我们可以使用dynamic_cast查询一个基类对象是否是作为派生类对象定义的
  + 第二十三章：模板。介绍隐藏在模板及其使用方法之下的基本原理
  + 第二十四章：泛型程序设计。介绍设计泛型程序所需的基本技术
  + 第二十五章：特例化。介绍特例化技术，即如何利用给定的一组模板参数，从模板生成类和函数
  + 第二十六章：实例化。主要介绍名字绑定规则
  + 第二十七章：模板和类层次。介绍模板层次和类层次如何结合使用
  + 第二十八章：元编程。介绍如何用模板生成程序
  + 第二十九章：一个矩阵设计。

### 1.1.4 标准库

+ 实际上这一部分可以当作标准库组件的用户手册来使用
  + 第三十章：标准库概览。给出标准库的概览，列出标准库头文件，并介绍语言支持和程序诊断方面的支持
  + 第三十一章：STL容器。介绍迭代器，容器和算法框架中的容器
  + 第三十二章：STL算法。介绍STL中的算法
  + 第三十三章：STL迭代器。介绍STL中的迭代器和其他工具
  + 第三十四章：内存和资源。介绍内存和资源管理相关的工具组件
  + 第三十五章：工具。介绍一些重要性稍低的工具组件
  + 第三十六章：字符串。介绍标准库string
  + 第三十七章：正则表达式
  + 第三十八章：I/O流。介绍标准库I/O流，包括格式化和非格式化输入输出，错误处理以及缓冲
  + 第三十九章：区域设置。
  + 第四十章：数值计算。
  + 第四十一章：并发。介绍C++基本内存模型和C++所提供的支持无锁并发编程的工具
  + 第四十二章：线程和任务。介绍支持线程和锁风格并发编程的类和支持基于任务并发编程模式的类
  + 第四十三章：C标准库。介绍纳入C++标准库的C标准库特性
  + 第四十四章：兼容性。

## 1.2 C++的设计

+ 程序设计语言的目的就是帮助我们用代码来表达思想。因此，一种程序设计语言要完成两个相关的任务：为程序员提供一个工具，用来指明需要由计算机执行什么动作；为程序员提供一组概念，用于思考能做些什么。
+ C++的设计理念是同时提供：
  + 将内置操作和内置类型直接映射到硬件，从而提供高效的内存利用和高效的底层操作。
  + 灵活且低开小的抽象机制，使得用户自定义类型无论是符号表达，使用范围还是性能都能与内置类型相当。

+ 系统程序设计(system programming)的含义是编写直接使用硬件资源的，严重受限于资源的代码，或是编写的代码与这类代码联系紧密。特别是软件基础设施的实现(例如设备驱动程序，通信协议栈，虚拟机，操作系统，业务支持系统，编程环境以及基础库)大部分都属于系统程序设计。

### 1.2.1 程序设计风格

+ 我们可以简单描述软件设计和编程的基本理念：
  + 用代码直接表达想法
  + 无关的想法应独立表达
  + 用代码直接描述想法之间的关联
  + 可以自用的组合用代码表达想法，但仅在这种组合有意义时
  + 简单的想法应简单表达
+ C++语言特性直接支持四种程序设计风格
  + 过程式程序设计
  + 数据抽象
  + 面向对象程序设计
  + 泛型程序设计
+ 但是，**重点不在于对单个程序设计风格的支持，而在于有效的组合它们。**
+ 我理想中的语言特性应该能优雅的组合使用，来支持连续统一的程序设计风格和各种各样的程序设计技术
  + 过程式程序设计：这种风格专注于处理和设计恰当的数据结构。支持这种风格也是C语言的设计目标。C++对这种风格的支持体现为内置类型，运算符，语句，函数，struct和union等特性。
  + 数据抽象：这种风格专注于接口的设计以及一般实现细节的隐藏和特殊的表示方式。C++支持具体类和抽象类。一些语言特性可直接用来定义具有私有实现细节，构造函数和析构函数以及相关操作的类。而抽象类则为完全的数据隐藏提供了直接支持。
  + 面向对象程序设计：这种风格专注于类层次的设计，实现和使用。除了允许定义类框架之外，C++还提供了各种各样的特性来支持类框架中的导航以及简化由已有的类来定义新的类。类层次提供了运行时多态和封装机制。
  + 泛型程序设计：这种风格专注于通用算法的设计，实现和使用。在这里，通用的含义是，一个算法可以设计成能处理多种类型，只要这些类型满足算法对其实参的要求即可。C++支持泛型编程的主要特性是模板，模板提供了运行时参数多态。

+ 上述这些设计和编程风格的强大在于它们的综合，每种风格都对综合启动了重要作用，而这种综合实际上就是C++。因此，**只关注一种风格是错误的，除非你只编写一些玩具程序，否则只关注一种风格会导致开发工作的浪费，产生非最优的程序**

### 1.2.2 类型检查

+ 静态类型和编译时类型检查的概念对高效使用C++是极为重要的。静态类型的使用是可表达性，可维护性和新能的关键。

### 1.2.3 C兼容性

+ C++从C语言发展而来，它保留了C的特性作为子集。

### 1.2.4 语言，库和系统

+ C++的基本内置类型，运算符和语句都是计算机硬件能直接处理的：数字，字符和地址。C++没有内置的高级数据类型，也没有高级操作原语。

## 1.3 学习C++

+ 语言特性的存在是为了支持各种程序设计风格和技术。因此，语言的学习应该更关注掌握其固有的，内在的风格，而不是试图了解每个语言特性的所有细节。
+ 请记住学习C++细节知识的真正目的是：在良好设计所提供的语境中，有能力组合使用语言特性和库特性来支持好的程序设计风格。
+ 学习C++最重要的是重视基本概念(例如类型安全，资源管理和不变式)和程序设计技术(例如使用限定作用域的对象进行资源管理以及在算法中使用迭代器)，还要注意不要迷失在语言技术性细节中。
+ 学习一门程序设计语言的目的是成为一个更好的程序员，即，能更高效的设计和实现新系统，维护旧系统。为此，领悟编程和设计技术比了解所有细节重要得多。

### 1.3.1 用C++编程

+ C++程序设计的主要理念与大多数高级语言编程一样：用代码直接表达从设计而来的概念。

## 1.4 C++的历史

### 1.4.5 C++的用途

+ C++有大量的支持库和工具集，例如
  + Boost 可移植基础库
  + POCO 网站开发库
  + QT 跨平台应用开发库
  + wxWidgets 跨平台图形用户界面库
  + WebKit 网页浏览器布局引擎库
  + CGAL 计算几何库
  + QuickFix 金融信息交换库
  + OpenCV 实时图像处理库
  + Root 高能物理库

## 1.5 建议

+ 每一章都有建议，给出该章节内容相关的一些具体建议。这些建议都是一些经验法则，而非不变的定律。
+ 对于初学者，下面列出了一些来自C++的设计，学习和历史这几节的建议
  + 用代码直接表达想法(概念)，例如，表达为一个函数，一个类或是一个枚举
  + 编写代码应以优雅且高效为目标
  + 不要过度抽象
  + 设计应关注提供优雅且高效的抽象，可能的情况下以库的形式呈现
  + 用代码直接表达想法之间的关联，例如，通过参数化或类层次
  + 无关的想法应用独立的代码表达，例如，壁面类之间的相互依赖
  + 令资源是显式的(将它们表示为类对象)
  + 简单的想法应该简单表达
  + 使用库，特别是标准库，不要试图从头开始构建所有东西
  + 使用类型丰富的程序设计风格
  + 如果数据具有不变量，封装它
+ 总之：**编写好程序需要智慧，风格和耐心。你不可能第一次就成功，要不断尝试。**

# 第二章 C++概览：基础知识

## 2.1 引言
## 2.2 基础概念

+ C++是一种编译型语言。顾名思义，想要运行一段C++程序，需要首先用编译器把源代码转换为对象文件，然后再用链接器把这些对象组合生成可执行程序。一个C++程序通常包含许多源代码文件，通常称为源文件。
+ 一个可执行程序适用于一种特定的硬件/系统组合，是不可移植的。当我们谈论C++程序的可移植性时，通常是指源代码的可移植性。也就是说，同一份源代码可以在不同系统上成功编译并运行。
+ ISO的C++标准定义了两种实体
  + 核心语言功能，例如内置类型和循环
  + 标准库组件，例如容器和I/O操作
+ C++是一种静态类型语言，这意味着编译器在处理任何实体(例如对象，值，名称和表达式)时，都必须清楚它的类型。对象的类型决定了能在该对象上执行哪些操作。

### 2.2.1 Hello world

+ 在每个C++程序中有且只有一个名为main()的全局函数，在执行一个程序时首先执行该函数。如果main()返回一个int值，则这个值将作为程序给系统的返回值。如果main()没有返回任何值，则系统也将收到一个表示程序完成的值。这个值：基于Linux/Unix的环境通常会用到，而基于windows的环境一般不会用到
+ 基本上所有可执行代码都要放在函数中，并且被main()直接或间接的调用

### 2.2.2 类型，变量和算术运算

+ 每个名字和每个表达式都有一个类型，类型决定所能执行的操作。
+ 声明(declaration)是一条语句，负责为程序引入一个新的名字，并指定该命名实体的类型
  + 类型(type) 定义一组可能的值以及一组(对象上的)操作
  + 对象(object) 是存放某类型值的内存空间
  + 值(value) 是一组二进制位，具体的含义由类型决定
  + 变量(variable) 是一个命名的对象

+ C++提供了好几种表示初始化的符号
  + 符号 = 是一种比较传统的形式，最早被C语言使用
  + 花括号内的一组初始化器列表。最好在C++中使用更通用的{}列表形式。抛开其他因素不谈，使用初始化器列表的形式至少可以确保不会发生某些可能导致信息丢失的类型转换。

+ 我们可以使用 = 的初始化形式与auto配合，因为在此过程中不存在可能引发错误的类型转换。
+ 当我们没有明显的理由需要显式指定数据类型时，一般使用auto。在这里，明显的理由包括
  + 该定义位于一个较大的作用域中，我们希望代码的读者清楚的直到其类型
  + 我们希望明确规定某个变量的范围和精度(例如希望使用double而非float)

### 2.2.3 常量

+ C++支持如下两种不变性概念
  + const：大致意思是，我承诺不改变这个值。主要用于说明接口，这样在把变量传入函数时就不必担心变量会在函数内被改变了。编译器负责确认并执行const的承诺
  + constexpr：大致意思是，在编译时求值。主要用于说明常量，作用是允许将数据内置于只读内存中以及提升性能。

## 2.3 用户自定义类型

+ 我们把可以通过基本类型，const修饰符和声明运算符构造出来的类型称为内置类型(built-in type)
+ 我们把利用C++的抽象机制构建的新类型称为用户自定义类型(user-defined types)

# 第三章 C++概览：抽象机制

## 3.2 类

+ C++最核心的语言特性就是类。类是一种用户自定义的数据类型，用于在程序代码中表示某种概念。
+ 我们只考虑对三种重要的类的基本支持
  + 具体类
  + 抽象类
  + 类层次中的类

### 3.2.1 具体类型

+ 具体类的基本思想是他们的行为 就像内置类型一样。

+ 析构函数的命名规则是一个求补运算符后接类的名字，从含义上来说它是构造函数的补充。

## 3.5 建议

+ 直接用代码表达你的想法
+ 在代码中直接定义类来表示应用中的概念
+ 用具体类表示那些简单的概念或性能关键的组件
+ 避免裸的new和delete操作
+ 用资源句柄和RAII管理资源
+ 当接口和实现需要完全分离时使用抽象类作为接口
+ 用类层次表示具有固有的层次关系的概念
+ 在设计类层次时，注意区分实现继承和接口继承
+ 控制好对象的构造，拷贝，移动和析构操作
+ 以值的方式返回容器(依赖于移动操作以提高效率)
+ 注意强资源安全，也就是说，不要泄露任何你认为是资源的东西
+ 使用函数模板表示通用的算法

# 第四章 C++概览：容器与算法

## 4.1 标准库

+ 本书介绍的标准库设施，在任何一个完整的C++实现中都是必备的部分。

### 4.1.1 标准库概述

+ 标准库提供的设施可以分为以下几类
  + 运行时语言支持，例如对资源分配和运行时类型信息的支持
  + C标准库
  + 字符串和I/O流
  + 一个包含容器和算法的框架，人们习惯上称这个框架为标准模板库(STL)
  + 对数值计算的支持
  + 对正则表达式匹配的支持
  + 对并发程序设计的支持，包括thread和lock机制
  + 一系列工具，它们用于支持模板元编程，STL-风格的泛型程序设计和通用程序设计
  + 用于资源管理的智能指针和垃圾收集器接口
  + 特殊容器
+ 本质上来说，C++标准库提供了最常用的基本数据结构以及运行在之上的基础算法。

## 4.6 建议

+ 没必要推倒重来，直接使用标准库是最好的选择
+ 除非万不得已，大多数时候先考虑使用标准库，在考虑别的库
+ 标准库绝非万能
+ 一定要了解各种标准库容器的设计思想和优缺点
+ 优先选用vector作为你的容器类型
+ 如果你拿不准会不会越界，记得使用带边界检查的容器
+ 用push_back()或者back_inserter()给容器添加元素

# 第五章 C++概览：并发与实用功能

## 5.2 资源管理

+ 所有程序都包含一项关键人物：管理资源。所谓资源是指程序中符合先获取后释放规律的东西，比如内存，锁，套接字，线程句柄和文件句柄等。

### 5.2.1 unique_ptr与shared_ptr

+ 标准库提供了两种智能指针来管理自由存储上的对象
  + unique_ptr对应所有权唯一的情况
  + shared_ptr对应所有权共享的情况
+ 这些智能指针最基本的作用是防止由于编程疏忽而造成的内存泄漏。

## 5.3 并发

+ 并发，也就是多个任务同时执行，被广泛用于提高吞吐率(用多个处理器共同完成单个运算)和提高响应速度(允许程序的一部分在等待响应时，另一部分继续执行)
+ 标准库并发设施重点提供系统级并发机制，而不是直接提供复杂的高层并发模型。基于标准库并发设施可以构建出这类高层并发模型，并以库的形式提供。
+ 标准库直接支持在单一地址空间内并发执行多个线程。为了实现这一目的，C++提供了一个适合的内存模型和一套原子操作。

### 5.3.1 任务和thread

+ 我们称那些可以与其他计算并行执行的计算为任务(task)。线程是任务在程序中的系统级表示。
+ 若要启动一个与其他任务并发执行的任务，我们可以构造一个std::thread并将任务作为它的实参。这里的任务是以函数或函数对象的形式出现的。
+ 一个程序的所有线程共享单一地址空间。在这一点上线程与进程不同，进程间通常不直接共享数据。由于共享单一地址空间，因此线程间可通过共享对象互相通信。通常通过锁或其他防止数据竞争的机制来控制线程间通信。

### 5.3.4 等待事件

+ 有时候thread需要等待某种外部事件，比如另一个thread完成了任务或是已经过去了一段时间。最简单的事件就是时间流逝。
+ 通过外部事件实现线程间通信的基本方式是使用condition_variable，它定义在<condition_variable>中。condition_variable提供了一种机制，允许一个thread等待另一个thread。特别的是，它允许一个thread等待某个条件(condition,通常称为一个事件，event)发生，这种条件通常是其他thread完成工作产生的结果。