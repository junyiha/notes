## 简介

+ 设计模式：可复用面向对象软件的基础 阅读笔记

## 第一章 引言

+ 设计面向对象软件比较困难，而设计可复用的面向对象软件就更加困难。你必须找到相关的对象，以适当的粒度将它们归类，再定义类的接口和继承层次，建立对象之间的基本关系

### 什么是设计模式

+ 一般而言，一个模式有四个基本要素：
  + 模式名称(pattern name)，一个助记名，它用一两个词来描述模式的问题，解决方案和效果。
  + 问题(problem)，描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，例如怎样用对象表示算法等。也可能描述了导致了不灵活设计的类或对象结构。
  + 解决方案(solution)，描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类或对象组合)来解决这个问题
  + 效果(consequences)，描述了模式应用的效果以及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价和好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性，扩充性或者可移植性的映像。

+ 本书中的设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述

### 组织编目

+ 根据两条准则对模式进行分类。

+ 第一是目的准则，即模式是用来完成什么工作的。
  + 模式依据其目的可分为创建型(Creational)，结构型(Structural)，或行为型(Behavioral)三种。
    + 创建型模式与对象的创建有关；
    + 结构型模式处理类或对象的组合；
    + 行为型模式对类或对象怎样交互和怎样分配职责进行描述

+ 第二是范围准则，指定模式主要用作于类还是用作于对象。
  + 类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。
  + 对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具有动态性。
  + 从某种意义上来说，几乎所有模式都使用继承机制，所以 类模式 只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴

### 设计模式怎样解决设计问题

+ 设计模式采用多种方法解决面向对象设计者经常碰到的问题

#### 寻找合适的对象

+ 面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或者操作。对象在收到客户的请求(或消息)后，执行相应的操作

+ 客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，他不能被直接访问，它的表示对于对象外部是不可见的

+ 面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装，粒度，依赖关系，灵活性，性能，演化，复用等等，它们都影响着系统的分解，并且这些因素通常还是互相冲突的

+ 设计模式帮你确定并不明显的抽象和描述这些抽象的对象

#### 决定对象的粒度

+ 对象在大小和数目上变化极大。它们能表示下自硬件或者上自整个应用的任何事物

#### 指定对象接口

+ 对象声明的每一个操作指定操作名，作为参数的对象和返回值，这就是所谓的操作的型构(signature)。
+ 对象操作所定义的所有操作型构的集合被称为该对象的接口(interface)。
+ 对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象

+ 类型(type)是用来标识特定接口的一个名字。
+ 接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的子类型(subtype)，另一个类型称之为它的超类型(supertype)。
+ 我们常说子类型继承了它的超类型的接口

+ 当给对象发送请求时，所引起的具体操作即与请求本身有关又与接收对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定(dynamice binding)
+ 动态绑定是指发送的请求直到运行时刻才受到你的具体的实现的约束。
+ 进一步将，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为多态(polymorphism)，它是面向对象系统中的核心概念之一

#### 描述对象的实现

+ 对象的实现是由它的类决定的，类指定了对象的内部数据和表示，也定义了对象所能够完成的操作。

+ 对象通过实例化类来创建，此时对象被称为该类的实例。当实例化类时，要给对象的内部数据(由实例变量组成)分配存储空间，并将操作与这些数据联系起来。

+ 新的类可以由已存在的类通过类继承(class inheritance)来定义。当子类(subclass)继承父类(parent class)时，子类包含了父类定义的所有数据和操作

+ 抽象类(abstrace class)的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或者全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作(abstract operation)。
+ 非抽象类称为具体类

+ 子类能够改进和重新定义它们的父类的操作。更具体的说，类能够重定义(override)父类定义的操作，重定义使得子类能够接管父类对请求的处理操作。

+ 混入类(mixin class)是给其他类提供可选择的接口或者功能的类。它与抽象类一样不能实例化。混入类要求多继承

##### 类继承与接口继承的比较

+ 理解对象的类(class)与对象的类型(type)之间的差别非常重要

+ 一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。
+ 但是对象的类型只与它的接口有关，接口即对象能够响应的请求的集合。
+ 一个对象可以有多个类型，不同类的对象可以有相同的类型。

+ 理解类继承和接口继承(或子类型化)之间的差别也十分重要。

+ 类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。
+ 然而，接口继承(或子类型化)描述了一个对象什么时候能被用来替代另一个对象。

+ 因为许多语言并不显式地区分这两个概念，所以容易被混淆。在C++ 和 Eiffel语言中，继承既指接口的继承又指实现的继承。
+ C++中接口继承的标准方法是公有继承一个含(纯)虚成员函数的类。
+ C++中纯接口继承接近于公有继承纯抽象类，纯实现继承或纯类继承接近于私有继承

##### 对接口编程，而不是对实现编程

+ 类继承是一个通过复用父类功能而扩展应用功能的基本机制。

+ 然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的(通常可以从抽象类来继承)。
+ 为什么？因为多态依赖于这种能力

+ 当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。
+ 这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。

+ 只根据抽象类中定义的接口来操作对象有以下两个好处：
  + 客户无须知道它们使用对象的特定类型，只须对象有客户所期望的接口
  + 客户无须知道它们使用的对象是用什么类来实现的，它们只须知道定义接口的抽象类。

+ 这将极大地减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：
  + 针对接口编程，而不是针对实现编程。

+ 不将变量声明为某个特定的具体类的实例对象，而是让它遵循从抽象类所定义的接口。这是本书设计模式的一个常见主题。

##### 运用复用机制