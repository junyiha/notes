## 简介

+ 深入理解计算机系统书籍的阅读，第一阶段为上下班阅读，拍下来需要记录的文字，回到公司整理到这里

## 第三章 程序的机器级表示

### 链接器

+ 链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置

### 反汇编器(disassembler)

+ 要查看机器代码文件的内容，有一类称为反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式
+ 在Linux系统中，带`-d`命令行标志的程序OBJDUMP表示(object dump)可以充当这个角色
+ 示例：
```bash
objdump -d mstore.o
```

### C 指针

+ C语言中所谓的指针，其实就是地址。

+ 间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器
+ 其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中，访问寄存器比访问内存要快得多

### C 指针运算

+ C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩

+ 单操作数操作符 `&` 和 `*` 可以产生指针和间接引用指针。也就是：
  + 对于一个表示某个对象的表达式Expr， &Expr是给出该对象地址的一个指针。
  + 对于一个表示地址的表达式AExpr， *AExpr给出该地址处的值

+ 因此，表达式Expr与 * &Expr是等价的。可以对数组和指针应用数据下标操作。
+ 数组引用A[i]等同于表达式 * (A + i)。它计算第 i 个数组元素的地址，然后访问这个内存位置

### 定长数组

+ 示例：
```c
#define N 16
typedef int fix_matrix[N][N]
```

+ 当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过 #define 声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。
+ 这样一来，如果需要修改这个值，只用简单地修改这个 #define 声明就可以了

### 运行时栈

+ C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则

+ 程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据，分配内存所需要的信息。

### 异质的数据结构

+ C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制
  + 结构(structure)，用关键字struct来声明，将多个对象集合到一个单位中
  + 联合(union)，用关键字union声明，允许用几种不同的类型来引用一个对象

+ C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。
+ 类似于数据的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
+ 编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用

### 数据对齐

+ 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4，8)的倍数。
+ 这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计

### 栈随机化

+ 栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的站地址都是不同的。
+ 实现的方式：
  + 程序开始时，在栈上分配一段0-n字节之间的随机大小的空间，例如，使用分配函数alloca在栈上分配指定字节数量的空间。
  + 程序不适用这段空间，但是他会导致程序每次执行时后续的栈位置发生了变化。
  + 分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间

+ 在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化(Address-Space Layout Randomization)，或者简称ASLR
+ 采用ASLR，每次运行时程序的不同部分，包括程序代码，库代码，栈，全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，他们的地址映射大相径庭。这样才能对抗一些形式的攻击

### 第三章 小结

+ 编译器C++与编译C非常相似。实际上，C++的早期实现就只是简单地执行了从C++到C的源到源的转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似于C的struct。C++的方法是用指向实现方法的代码的指针来表示的。

+ 相比而言，Java的实现方式完全不同。Java的目标代码是一种特殊的二进制表示，称为Java字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。

+ 另外，有一种称为及时编译(just-in-time compilation)的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时(例如在循环中)，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行。

## 第五章 优化程序性能

### 理解现代处理器

+ 为了理解改进性能的方法，我们需要理解现代处理器的微体系结构。由于大量的晶体管可以被集成到一块芯片上，现在微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与通过观察机器级程序所察觉到的大相径庭。
+ 在代码级上，看上去似乎试一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为 指令级并行

### 应用： 性能提高技术

+ 优化程序性能的基本策略：
  + 高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术

+ 基本编码原则：避免限制优化的因素，这样编译器就能产生高效的代码
  + 消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获取更大的效率
  + 消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中

+ 低级优化：结构化代码以利用硬件功能
  + 展开循环，降低开销，并且使得进一步的优化成为可能
  + 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行
  + 用功能性的风格重写条件操作，使得编译采用条件数据传送

### 程序剖析 code profiler

+ 程序剖析运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。这对于确认程序中我们需要集中注意力优化的部分是很有用的。
+ 剖析的一个有力之处在于可以在现实的基准数据(benchmark data)上运行实际程序的同时，进行剖析

+ Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。
  + 首先，它确定程序中每个函数花费了多少CPU时间
  + 其次，它计算每个函数被调用的次数，以执行调用的函数来分类
+ 这两种形式的信息都非常有用。这些计时给出了不同函数在确定整体运行时间中的相对重要性。调用信息使得我们能够理解程序的动态行为

+ 用GPROF进行剖析需要三个步骤，就像C程序prog.c所示，它运行时命令参数为file.txt：
  + 首先，程序必须为剖析而编译和链接。使用GCC(以及其他C编译器),就是在命令行上简单地包括运行时标志`-pg`。确保编译器不通过内联替换来尝试执行任何优化是很重要的，否则就可能无法正确刻画函数调用。我们使用优化标志`-Og`，以保证能正确跟踪函数调用
    + `linux> gcc -Og -pg prog.c -o prog`
  + 其次，程序像往常一样执行：
    + `linux> ./prog file.txt`
    + 它运行得会比正常时稍微慢一点(大约慢两倍),不过除此之外唯一的区别就是它产生了一个文件gmon.out
  + 调用GPROF来分析gmon.out中的数据
    + `linux> gprof prog`

+ 剖析报告的第一部分列出了执行各个函数花费的时间，按照降序排列。
+ 每一行代表对某个函数的所有调用所花费的时间
  + 第一列表明花费在这个函数上的时间占整个时间的百分比
  + 第二列显示的是直到这一行并包括这一行的函数所花费的累计时间
  + 第三列显示的是花费在这个函数上的时间
  + 第四列显示的是它被调用的次数(递归调用不计算在内)

+ 剖析报告的第二部分是函数的调用历史
  + 根据这个调用信息，我们通常可以推断出关于程序行为的有用信息

### 小结

+ 当处理大型程序时，将注意力集中在最耗时的部分变得很重要。代码剖析程序和相关的工具能帮助我们系统地评价和改进程序性能。
+ 我们描述了GPROF，一个标准的Unix剖析工具，还有更加复杂完善的剖析程序可用，例如Intel的VTUNE程序开发系统，还有Linux系统基本上都有的VALGRIND。
+ 这些工具可以在过程级分解执行时间，估计程序每个基本块(basic block)的性能。(基本块是内部没有控制转移的指令序列，因此基本块总是整个被执行的)

## 第六章 存储器层次结构

+ 存储器系统(memory system)是一个具有不同容量，成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。
+ 靠近CPU的小的，快速的高速缓存存储器(cache memroy)作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域
+ 主存缓存，存储在容量较大的，慢速磁盘上的数据，而这些磁盘常常有作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域

+ 这个思想围绕着计算机程序的一个称为局部性(locality)的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。
+ 具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层次出访问数据项，因此运行得更快

### 随机访问存储器

+ 随机访问存储器(Random-Access Memory, RAM)分为两类：静态的和动态的

+ 静态RAM(SRAM)比动态RAM(DRAM)更快，但也贵得多
+ SRAM用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下
+ SRAM将每个位存储在一个双稳态的(bistable)存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同电压配置(configuration)或状态(state)之一。其他任何状态都是不稳定的：从不稳定状态开始，电路会讯速地转移到两个稳定状态中的其中一个。这样一个存储器单元类似于一个倒转的钟摆

+ DRAM将每个位存储为一个电容的充电

+ 内存模块
  + DRAM芯片封装在内存模块(memory module)中，它查到主板的扩展槽上

### 非易失性存储器

+ 如果断电，DRAM和SRAM会丢失它们的信息，从这个意义上说，它们是易失的(volatile)。
+ 另一方面，非易失性存储器(nonvolatile memory)即使是在关电后，仍然保存着它们的信息。

+ 由于历史原因，虽然ROM中有的类型既可以读也可以写，但是它们整体上都被称为只读存储器(Read-Only Memory, ROM)。
+ ROM是它们能够被重编程(写)的次数和对它们进行重编程所用的机制来区分的

+ PROM(Programmable ROM, 可编程ROM)只能被编程一次。PROM的每个存储器单元有一种熔丝(fuse)，只能用高电流熔断一次

+ 可擦写可编程ROM(Erasable Programmable ROM, EPROM)有一个透明的石英窗口，允许光到达存储单元。紫外线光照射过窗口，EPROM单元就被清除为0。对EPROM编程是通过使用一种把1写入EPROM的特殊设备来完成的。
+ EPROM能够被擦除和重编程的次数的数量级可以达到1000次。

+ 电子可擦除EROM(Electrically Erasable PROM, EEPROM)类似于EPROM，但是他不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM能够被编程的次数的数量级可以达到10的五次方

+ 闪存(flash memory)是一类非易失性存储器，基于EEPROM，他已经称为了一种重要的存储技术。
+ 新型的基于闪存的磁盘驱动器，称为固态硬盘(Solid State Disk, SSD)，它能提供相对于传统旋转磁盘的一种更快速，更强健和更低能耗的选择

+ 存储在ROM设备中的程序通常被称为固件(firmware)。当一个计算机系统通电以后，他会运行存储在ROM中的固件。一些系统在固件中提供了少量基本的输入和输出函数：例如PC的BIOS(基本输入/输出系统)例程

+ 逻辑磁盘块
  + 正如我们看到的那样，现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现在磁盘将它们的构造呈现为一个简单的视图，一个B个扇区大小的逻辑块的序列，编号为0，1，。。。，B-1。磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际(物理)磁盘扇区之间的映射关系。

+ 当操作系统想要执行一个I/O操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。
+ 控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个(盘面，磁道，扇区)的三元组，这个三元组唯一的标识了对应的物理扇区，控制器上的硬件会解释这个三元组，将读/写头移动到适当的柱面，等待扇区移动到读/写头下，将读/写头感知到的位放到控制器上的一个小缓冲区中，然后将他们复制到主存中

+ 格式化的磁盘容量
  + 磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据
  + 格式化包括用标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及在每个区中预留出一组柱面作为备用，如果区中一个或多个柱面在磁盘使用过程中坏掉了，就可以使用这些备用的柱面
  + 因为存在着这些备用的柱面，所以磁盘制造商所说的格式化容量比最大容量要小