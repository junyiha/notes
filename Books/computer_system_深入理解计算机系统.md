## 简介

+ 深入理解计算机系统书籍的阅读，第一阶段为上下班阅读，拍下来需要记录的文字，回到公司整理到这里

## 第三章 程序的机器级表示

### 链接器

+ 链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置

### 反汇编器(disassembler)

+ 要查看机器代码文件的内容，有一类称为反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式
+ 在Linux系统中，带`-d`命令行标志的程序OBJDUMP表示(object dump)可以充当这个角色
+ 示例：
```bash
objdump -d mstore.o
```

### C 指针

+ C语言中所谓的指针，其实就是地址。

+ 间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器
+ 其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中，访问寄存器比访问内存要快得多

### C 指针运算

+ C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩

+ 单操作数操作符 `&` 和 `*` 可以产生指针和间接引用指针。也就是：
  + 对于一个表示某个对象的表达式Expr， &Expr是给出该对象地址的一个指针。
  + 对于一个表示地址的表达式AExpr， *AExpr给出该地址处的值

+ 因此，表达式Expr与 * &Expr是等价的。可以对数组和指针应用数据下标操作。
+ 数组引用A[i]等同于表达式 * (A + i)。它计算第 i 个数组元素的地址，然后访问这个内存位置

### 定长数组

+ 示例：
```c
#define N 16
typedef int fix_matrix[N][N]
```

+ 当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过 #define 声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。
+ 这样一来，如果需要修改这个值，只用简单地修改这个 #define 声明就可以了

### 运行时栈

+ C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则

+ 程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据，分配内存所需要的信息。

### 异质的数据结构

+ C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制
  + 结构(structure)，用关键字struct来声明，将多个对象集合到一个单位中
  + 联合(union)，用关键字union声明，允许用几种不同的类型来引用一个对象

+ C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。
+ 类似于数据的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
+ 编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用

### 数据对齐

+ 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4，8)的倍数。
+ 这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计

### 栈随机化

+ 栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的站地址都是不同的。
+ 实现的方式：
  + 程序开始时，在栈上分配一段0-n字节之间的随机大小的空间，例如，使用分配函数alloca在栈上分配指定字节数量的空间。
  + 程序不适用这段空间，但是他会导致程序每次执行时后续的栈位置发生了变化。
  + 分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间

+ 在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化(Address-Space Layout Randomization)，或者简称ASLR
+ 采用ASLR，每次运行时程序的不同部分，包括程序代码，库代码，栈，全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，他们的地址映射大相径庭。这样才能对抗一些形式的攻击

### 第三章 小结

+ 编译器C++与编译C非常相似。实际上，C++的早期实现就只是简单地执行了从C++到C的源到源的转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似于C的struct。C++的方法是用指向实现方法的代码的指针来表示的。

+ 相比而言，Java的实现方式完全不同。Java的目标代码是一种特殊的二进制表示，称为Java字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。

+ 另外，有一种称为及时编译(just-in-time compilation)的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时(例如在循环中)，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行。

## 第四章 优化程序性能

### 理解现代处理器

+ 为了理解改进性能的方法，我们需要理解现代处理器的微体系结构。由于大量的晶体管可以被集成到一块芯片上，现在微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与通过观察机器级程序所察觉到的大相径庭。
+ 在代码级上，看上去似乎试一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为 指令级并行

### 应用： 性能提高技术

+ 优化程序性能的基本策略：
  + 高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术

+ 基本编码原则：避免限制优化的因素，这样编译器就能产生高效的代码
  + 消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获取更大的效率
  + 消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中

+ 低级优化：结构化代码以利用硬件功能
  + 展开循环，降低开销，并且使得进一步的优化成为可能
  + 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行
  + 用功能性的风格重写条件操作，使得编译采用条件数据传送

### 程序剖析 code profiler

+ 程序剖析运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。这对于确认程序中我们需要集中注意力优化的部分是很有用的。
+ 剖析的一个有力之处在于可以在现实的基准数据(benchmark data)上运行实际程序的同时，进行剖析

+ Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。
  + 首先，它确定程序中每个函数花费了多少CPU时间
  + 其次，它计算每个函数被调用的次数，以执行调用的函数来分类
+ 这两种形式的信息都非常有用。这些计时给出了不同函数在确定整体运行时间中的相对重要性。调用信息使得我们能够理解程序的动态行为

+ 用GPROF进行剖析需要三个步骤，就像C程序prog.c所示，它运行时命令参数为file.txt：
  + 首先，程序必须为剖析而编译和链接。使用GCC(以及其他C编译器),就是在命令行上简单地包括运行时标志`-pg`。确保编译器不通过内联替换来尝试执行任何优化是很重要的，否则就可能无法正确刻画函数调用。我们使用优化标志`-Og`，以保证能正确跟踪函数调用
    + `linux> gcc -Og -pg prog.c -o prog`
  + 其次，程序像往常一样执行：
    + `linux> ./prog file.txt`
    + 它运行得会比正常时稍微慢一点(大约慢两倍),不过除此之外唯一的区别就是它产生了一个文件gmon.out
  + 调用GPROF来分析gmon.out中的数据
    + `linux> gprof prog`

+ 剖析报告的第一部分列出了执行各个函数花费的时间，按照降序排列。
+ 每一行代表对某个函数的所有调用所花费的时间
  + 第一列表明花费在这个函数上的时间占整个时间的百分比
  + 第二列显示的是直到这一行并包括这一行的函数所花费的累计时间
  + 第三列显示的是花费在这个函数上的时间
  + 第四列显示的是它被调用的次数(递归调用不计算在内)

+ 剖析报告的第二部分是函数的调用历史
  + 根据这个调用信息，我们通常可以推断出关于程序行为的有用信息