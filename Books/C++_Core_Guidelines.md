## 简介

+ C++ Core Guidelines笔记

## 第二章 理念

### 在代码中直接表达思想

+ 程序员应该直接用代码直接表达他们的思想，因为代码可以被编译器和工具检查
+ 一个专业的C++开发者应该了解STL算法

### 用ISO标准C++写代码

+ 使用当前的C++标准，不要使用编译器扩展
+ 此外，要注意未定义行为和实现定义行为
  + 未定义行为： 
  + 实现定义行为：程序的行为可能因编译器实现而异。实现必须在文档里描述实现的行为

在C++编程中，有两个重要的概念：未定义行为（Undefined Behavior）和实现定义行为（Implementation Defined Behavior）。

1. **未定义行为 (Undefined Behavior)**:
   - 当程序包含未定义行为时，C++标准没有规定程序的行为，允许编译器和运行时环境采用任何行为。这可能导致程序崩溃、产生意外结果、或者在不同的编译器、平台或编译选项下表现不同。
   - 未定义行为可能是由于程序中的错误、溢出、指针操纵等原因引起的，也可能是标准规定没有定义的操作。

2. **实现定义行为 (Implementation Defined Behavior)**:
   - 当某个方面的行为是由C++标准定义的，但是标准允许不同的实现在这方面做出不同的选择，这被称为实现定义行为。
   - 例如，标准规定某个操作的结果可以有多种可能，但实现需要选择其中一种并在文档中明确说明。

示例：

```cpp
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    std::cout << arr[5] << std::endl; // 未定义行为，越界访问数组

    int x = -5;
    unsigned int y = 10;
    std::cout << x * y << std::endl; // 实现定义行为，结果取决于具体的实现
    return 0;
}
```

在这个例子中，访问数组`arr`的第六个元素是未定义行为，因为数组索引越界。而对于`x * y`的乘法，结果是实现定义的，因为标准并没有规定对于负数和无符号数相乘的具体行为。

在编写C++代码时，尽量避免未定义行为，因为它可能导致代码在不同环境下的行为不可预测。实现定义行为可能会因不同的编译器或平台而异，但至少有一个可预测的结果。

+ 当你必须使用没有写在ISO标准里的扩展时，可以用一个稳定的接口将它们封装起来

### 表达意图

+ 表达意图是良好的代码文档的一个重要准则。文档应该说明代码会做什么，而不是代码会怎么做

### 不要泄漏任何资源

+ 资源可以是内存，也可以是文件句柄或者套接字。
+ 处理资源的惯用法是RAII。RAII是 Resource Acquisition Is Initialization(资源获取即初始化)的缩写，本质上意味着你在用户定义类型的构造函数中获取资源，在析构函数中释放资源。通过使对象成为一个有作用于的对象，C++的运行时会自动照顾到资源的生存期
+ C++大量使用RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL的容器负责处理底层元素，等等

### 不可变数据优先于可变数据

+ 使用不可变数据的理由有很多。
+ 首先，当你使用常量时，你的代码更加容易验证
+ 最重要的是常量在并发程序中具有很大的优势
+ 不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改

### 封装杂乱的构件，不要让他在代码中散布开

+ 混乱的代码往往是低级代码易于隐藏错误，容易出现问题。
+ 如果可能的话，用STL中的高级构件(例如容器和算法)来取代你的杂乱代码。
+ 如果这不可能，就把那些杂乱的代码封装带一个用户自定义的类型或者函数中

### 适当使用辅助工具

+ 计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具，并发工具和测试工具来自动完成这些验证。
+ 用一个以上的C++编译器来编译代码，往往是验证代码的最简单方式。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样的情况下发出警告或者产生错误

### 适当使用支持库

+ 你应该去找设计良好，文档齐全，支持良好的库。
+ 突出的例子包括：
  + C++标准库
  + Guidelines支持的库
  + Boost库

## 第三章 接口

+ 接口是服务的提供者和使用者之间的契约

### 避免非const的全局变量

+ 全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分
+ 非const的全局变量有许多弊端。首先，非const的全局变量破坏了封装。这种对封装的破坏让你无法对函数/类(实体)进行孤立思考。

### 避免单例

+ 单例就是全局变量，因此你应当尽可能避免单例。单例简单，直接地保证该类最多只有一个实例存在。
+ C++ 单例模式 详解
单例模式是一种设计模式，其目的是确保一个类只有一个实例，并提供全局访问点。这有助于确保在整个应用程序中共享相同的资源或状态，以及提供一种方便的方法来访问该实例。下面详细解释C++中的单例模式。

### 实现单例模式的步骤：

1. **私有构造函数：** 将类的构造函数声明为私有，以防止外部直接实例化类。

    ```cpp
    class Singleton {
    private:
        Singleton() {}  // 私有构造函数
    };
    ```

2. **静态成员变量：** 在类中声明一个静态私有指针，用于保存唯一的实例。

    ```cpp
    class Singleton {
    private:
        static Singleton* instance;  // 静态私有指针
        Singleton() {}  // 私有构造函数
    };
    ```

3. **静态方法：** 提供一个公共的静态方法，用于获取类的实例。在这个方法中，检查实例是否已经存在，如果不存在，则创建一个新实例并返回。

    ```cpp
    class Singleton {
    private:
        static Singleton* instance;  // 静态私有指针
        Singleton() {}  // 私有构造函数

    public:
        static Singleton* getInstance() {
            if (instance == nullptr) {
                instance = new Singleton();
            }
            return instance;
        }
    };
    ```

4. **删除复制构造函数和赋值运算符：** 为了防止通过复制构造函数或赋值运算符创建新实例，将它们声明为私有并不实现。

    ```cpp
    class Singleton {
    private:
        static Singleton* instance;  // 静态私有指针
        Singleton() {}  // 私有构造函数

    public:
        static Singleton* getInstance() {
            if (instance == nullptr) {
                instance = new Singleton();
            }
            return instance;
        }

    private:
        Singleton(const Singleton&);  // 禁止复制构造函数
        Singleton& operator=(const Singleton&);  // 禁止赋值运算符
    };
    ```

### 线程安全性：

上述实现在单线程环境下是有效的，但在多线程环境中可能会有问题。为了确保线程安全，可以使用加锁机制，例如互斥锁。

```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;  // 静态私有指针
    static std::mutex mutex;     // 互斥锁
    Singleton() {}               // 私有构造函数

public:
    static Singleton* getInstance() {
        std::lock_guard<std::mutex> lock(mutex);  // 加锁
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

private:
    Singleton(const Singleton&);             // 禁止复制构造函数
    Singleton& operator=(const Singleton&);  // 禁止赋值运算符
};

// 初始化静态成员变量
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;

int main() {
    // 获取单例实例
    Singleton* singletonInstance1 = Singleton::getInstance();
    Singleton* singletonInstance2 = Singleton::getInstance();

    std::cout << "Address of instance 1: " << singletonInstance1 << std::endl;
    std::cout << "Address of instance 2: " << singletonInstance2 << std::endl;

    return 0;
}
```

这个例子中，通过 `std::mutex` 实现了简单的互斥锁，确保在多线程环境中仍然能够正确地创建单例实例。

### 运用依赖注入化解

+ 当某个对象使用单例的时候，隐藏的依赖就被注入对象中。而借助依赖注入技术，这个依赖可以变成接口的一部分，并且服务是从外界注入的。这样，客户代码和注入的服务之间就没有了依赖。
+ 依赖注入的典型方式是构造函数，设置函数(setter)成员或者模板参数

### 构建良好的接口

+ 函数应该通过接口(而不是全局变量)进行沟通。
+ 接口应当遵循以下规则：
  + 接口明确
  + 接口精确并且具有强类型
  + 保持较低的参数数目
  + 避免相同类型却不相关的参数相邻

+ 术语"可调用"(callable)。可调用实体是在行为上像函数的东西。它可以是函数，也可以是函数对象，或者是lambda表达时。
+ 如果可调用实体接受一个参数，它就是一元可调用实体；如果它接受两个参数，则称为二元可调用实体
+ std::transform_reduce先将一元可调用实体应用到一个范围或者将二元可调用实体应用到两个范围，然后将二元可调用实体应用到前一步的结果的范围上。

### 不要用单个指针来传递数组

+ 这条规则的出现是为了解决一些未定义行为
+ 补救的方法也简单，使用STL中的容器，例如std::vector，并在函数体中检查容器的大小

### 为了库ABI的稳定，考虑使用PImpI惯用法

+ 应用程序二进制接口(ABI)是两个二进制程序模块间的接口
+ 借助PImpI惯用法，可以隔离类的用户和实现，从而避免重复编译。
+ PImpI是 pointer to implementation(指向实现的指针)的缩写，它指的是C++中的一种编程技巧：
  + 将实现细节放在另一个类中，从而将其从类中移除。而这个包含实现的细节的类是通过一个指针来访问的。
  + 这么做是因为私有数据成员会参与类的内存布局，而私有函数成员会参与重载决策。这些依赖意味着对成员实现细节的修改会导致所有类的用户都需要重新编译。
  + 持有指向实现的指针(PImpI)的类可将用户隔离在类实现的变化之外，而代价则是多了一次间接。

+ C++ PImpI编程技巧  详解
PImpl（Pointer to Implementation）是一种编程技巧，也称为“编译期实现”或“内部实现”，它的目的是将类的实现细节封装在一个单独的实现类中，从而减少头文件的依赖关系，提高代码的模块化性和可维护性。

### PImpl模式的实现步骤：

1. **声明外部接口：** 在类的头文件中声明类的公共接口，但将实际的成员变量和实现细节的声明放到一个内部类中。

    ```cpp
    // MyClass.h
    class MyClass {
    public:
        MyClass();
        ~MyClass();

        void publicMethod1();
        void publicMethod2();

    private:
        class Impl;  // 内部实现类的前向声明
        Impl* pImpl;  // 内部实现类的指针
    };
    ```

2. **定义实现类：** 在实现文件中定义内部实现类，并将实际的成员变量和函数实现放在这里。

    ```cpp
    // MyClass.cpp
    #include "MyClass.h"

    // 实现内部实现类
    class MyClass::Impl {
    public:
        void privateMethod1() {
            // 实现细节
        }

        void privateMethod2() {
            // 实现细节
        }

        // 成员变量
        int data;
    };

    // MyClass 构造函数
    MyClass::MyClass() : pImpl(new Impl()) {}

    // MyClass 析构函数
    MyClass::~MyClass() {
        delete pImpl;
    }

    // 公共方法的实现调用内部实现类的方法
    void MyClass::publicMethod1() {
        pImpl->privateMethod1();
    }

    void MyClass::publicMethod2() {
        pImpl->privateMethod2();
    }
    ```

### PImpl的优势：

1. **降低编译依赖：** 将实现细节从头文件中移除，降低了头文件的依赖关系。这样，当实现发生变化时，只有实现文件需要重新编译，而不会影响到调用方。

2. **隐藏实现细节：** 将实现细节放在内部实现类中，可以隐藏对类的具体实现的细节，只需要暴露公共接口给用户。

3. **减小编译时间：** 当头文件发生变化时，只有依赖头文件的文件需要重新编译，而不会触发整个项目的重新编译。

4. **改善二进制兼容性：** 通过将实现细节放在内部实现类中，可以减少对外部接口的更改，提高二进制兼容性。

5. **模块化设计：** 可以更容易地设计模块化的系统，每个模块只关注自己的接口和实现细节。

### 注意事项：

1. **内存管理：** 要确保在类的析构函数中正确释放内部实现类的内存，以防止内存泄漏。

2. **拷贝和赋值：** PImpl模式可能导致默认的拷贝构造函数和赋值运算符不再适用，需要自定义这些函数并确保正确处理内部实现类的拷贝和赋值。

3. **性能开销：** PImpl模式引入了指针和额外的间接层，可能会带来一些微小的性能开销，但通常在维护性和可读性上的优势远远超过了这些开销。

PImpl是一种强大的C++编程技巧，特别适用于大型项目和库的开发，有助于提高代码的模块化性和可维护性。

### 本章精华

+ 不要使用全局变量，它们会引入隐藏的依赖
+ 单例就是变相的全局变量
+ 接口，尤其是函数，应该表达出意图
+ 接口应当是强类型的，而且应该只有几个不容易弄混的参数
+ 不要按指针接收C数组，而应该使用std::span
+ 如果你想要将类的使用和实现分开，请使用PImpI惯用法

## 第四章 函数

+ 软件开发人员通过将复杂的任务划分为较小的单元来掌控复杂性。在处理完小单元后，他们把小单元放在一起来掌控复杂的任务。
+ 函数是一种典型的单元，也是程序的基本构件。

### 函数定义

+ 好软件的最重要原则是好名字。
+ 将有意义的操作打包成精心命名的函数
+ 一个函数应该执行单一的逻辑操作
+ 使函数保持简短

+ 当你无法为函数找到一个有意义的名称时，这充分说明你的函数执行不止一项逻辑操作，而且你的函数并不简短

### 如果函数有可能需要在编译期求值，就把它声明为 constexpr

+ constexpr函数是可能在编译期运行的函数。当你在常量表达式中调用constexpr函数时，或者当你要用一个constexpr变量来获取constexpr函数的结果时，它会在编译期运行。也可以用只能在运行其求值的参数来调用constexpr函。
+ constexpr函数是隐含內联的
+ 编译期求值的constexpr的结果通常会被系统标记为只读
+ 性能是constexpr函数的第一大好处；它的第二大好处是，编译期求值的constexpr函数是纯函数，因此constexpr函数是线程安全的
+ 最后，计算结果会在运行期作为只读存储区域中的常量来提供

### 如果你的函数必定不抛异常，就把它声明为noexcept

+ 通过将函数声明为noexcept，你减少了备选控制路径的数量；因此，noexcept对优化器来说是一个有价值的提示
+ 即使你的函数可以抛出异常，noexcept往往也合理。noexcept在这种情况下意味着：我不在乎异常。其原因可能是：你无法对异常作出反应。在这种情况下，系统处理异常的唯一办法是调用std::terminate()
+ 以下类型的函数永远不应该抛出异常：
  + 析构函数
  + swap函数
  + 移动操作和默认构造函数

### 优先使用纯函数

+ 纯函数是指在给定相同参数时总是返回相同结果的函数。这个属性也被称为引用透明性。纯函数的行为就像无限大的查找表
+ 非纯函数是指random()或者time()这样的函数，它们会在不同的调用中返回不同的结果。换句话说，与函数体之外的状态交互的函数是不纯的
+ 纯函数有一些非常有趣的属性
  + 孤立的测试
  + 孤立的验证或重构
  + 还存其结果
  + 被自动重排或者在其他线程上执行

+ 纯函数也常被称为数学函数。
+ constexpr函数在编译期求值时是纯的。模板元编程是一种嵌在命令式语言C++中的纯函数式语言

### 优先采用简单而约定俗成的信息传递方式

+ 数据的类型：
  + 拷贝开销低或者不可能拷贝构造： func(X)
  + 移动开销低：std::vector<T>, std::string
  + 移动开销中: std::array<std::vector>或者BigPOD(POD代表 Plain Old Data，简旧数据，意为一般的传统数据--没有析构函数，构造函数以及虚成员函数的类)
  + 移动开销未知: 模板
  + 移动开销高：BigPOD[]或者std::array<BigPOD>

+ 参数传递的方向
  + 入：输入参数
  + 入并保留拷贝：被调用者保留一份数据
  + 入并移入：参数处在所谓的被移动状态。被移动状态意味着它处于合法但未指定的状态。基本上，你在重新使用被移动的对象前必须对他进行初始化
  + 入/出：参数会被修改
  + 出：输出参数

### 对于入参，拷贝开销低的类型按值传递，其他类型则以const引用来传递

+ 默认情况下，输入值可以拷贝就拷贝。如果拷贝开销不低，就通过const引用来传入。
+ 经验法则：
  + 如果 sizeof(par) <= 2 * sizeof(void*)，则按值传递参数par
  + 如果 sizeof(par) > 2 * sizeof(void*)，则按const引用传递par

### 对于转发参数，要用TP&&来传递，并且只std::forward该参数

+ 有时你想转发参数par。这意味着你希望保持左值的左值性，以及右值的右值性，这样才能完美地转发参数，使它的语义不发生变化
+ 转发参数的典型用例是工厂函数，工厂函数通过调用某个用户指定对象的构造函数创建出该对象。你不知道参数是不是右值，也不知道构造函数需要多少个参数

在C++中，工厂函数是一种设计模式，它提供了一种创建对象的方式，使得在不暴露对象的具体实现细节的情况下能够创建对象。工厂函数通常用于创建类的实例，而不是直接调用类的构造函数。这有助于实现抽象和封装，同时提供了灵活性和可维护性。

以下是关于C++工厂函数的一些详解：

1. **定义**：
   工厂函数是一个函数，负责创建和返回类的实例。它通常是类的静态成员函数，或者是一个独立于类的函数。

   ```cpp
   class Product {
   public:
       virtual ~Product() {}
       virtual void doSomething() = 0;
   };

   class ConcreteProduct : public Product {
   public:
       void doSomething() override {
           // 具体产品的实现
       }
   };

   class Factory {
   public:
       static Product* createProduct() {
           return new ConcreteProduct();
       }
   };
   ```

2. **返回类型**：
   工厂函数通常返回一个指向基类（抽象类）的指针或引用，这样可以隐藏具体实现的细节，同时允许客户端代码通过基类接口使用对象。

3. **抽象类**：
   工厂函数通常用于创建抽象类的实例，这样可以根据需要选择合适的具体实现。在上面的例子中，`Product` 是抽象类，而 `ConcreteProduct` 是它的具体实现。

4. **灵活性**：
   工厂函数提供了一种动态创建对象的方式，允许在运行时根据条件或配置选择要创建的具体类型，从而提供更大的灵活性。

   ```cpp
   int main() {
       Product* product = Factory::createProduct();
       product->doSomething();
       delete product;

       return 0;
   }
   ```

5. **多态性**：
   通过返回基类指针，工厂函数支持多态性，允许通过基类接口调用具体类的方法。

6. **单例工厂**：
   工厂函数可以实现为单例，确保在应用程序中只存在一个工厂实例，从而确保对对象创建的全局控制。

   ```cpp
   class SingletonFactory {
   public:
       static SingletonFactory& getInstance() {
           static SingletonFactory instance;
           return instance;
       }

       Product* createProduct() {
           return new ConcreteProduct();
       }

   private:
       SingletonFactory() {}  // 私有构造函数，确保只能通过 getInstance() 访问
   };
   ```

总的来说，工厂函数是一种有用的设计模式，它提供了一种灵活、可扩展且易于维护的方式来创建对象，特别是在需要隐藏具体实现的情况下。

+ 三个点(省略号)表示形参包。我们将使用形参包的模板称为变参模板
+ 形参包的打包和解包
  + 当省略号在类型参数T1的左边时，参数包被打包；当省略号在右边时，参数包被解包
  + 返回语句 T(std::forward<T1>(t1)...)中的这种解包实质上意味着表达式std::forward<T1>(t1)被不断重复，直到形参表的所有参数都被消耗掉，并且会在每个子表达式之间加一个逗号
+ C++ 形参包 详解

在C++中，形参包（parameter pack）是C++11引入的一个特性，它允许你定义一个可以包含任意数量参数的函数或类模板。形参包的主要优势之一是在不知道参数数量的情况下，仍然能够编写通用的代码。

以下是有关C++形参包的详解：

1. **定义形参包**：
   形参包使用省略号 `...` 表示。它可以用在函数模板或类模板的参数列表中。

   ```cpp
   // 函数模板形参包的例子
   template <typename... Args>
   void myFunction(Args... args) {
       // 使用args...
   }
   ```

   在上面的例子中，`Args` 是一个模板参数包，而 `args` 是函数参数包。

2. **展开形参包**：
   通过使用展开操作符 `...`，可以在函数体内展开形参包，以便对每个参数执行相同的操作。

   ```cpp
   template <typename... Args>
   void printValues(Args... args) {
       (std::cout << ... << args) << '\n';  // 展开形参包，逐个输出参数
   }
   ```

   在上面的例子中，`(std::cout << ... << args)` 部分展开了形参包，逐个将参数传递给 `std::cout`。

3. **递归展开**：
   形参包可以用于递归展开，实现对每个参数的逐一处理。

   ```cpp
   template <typename T>
   void printSingleValue(const T& value) {
       std::cout << value << '\n';
   }

   template <typename T, typename... Args>
   void printValues(T first, Args... rest) {
       printSingleValue(first);    // 处理第一个参数
       printValues(rest...);       // 递归展开处理剩余参数
   }
   ```

   在上面的例子中，`printValues` 函数递归展开形参包，对每个参数调用 `printSingleValue` 函数。

4. **折叠表达式**：
   C++17 引入了折叠表达式，使得展开形参包更加简洁。

   ```cpp
   template <typename... Args>
   void printValues(Args... args) {
       (std::cout << ... << args) << '\n';  // 折叠表达式
   }
   ```

   折叠表达式使得对形参包的处理更加紧凑和易读。

5. **使用形参包的场景**：
   形参包通常在需要处理可变数量参数的通用函数或模板中使用，例如元组的操作、可变参数模板、泛型代码等。

形参包是C++中强大的工具，它为编写通用和灵活的代码提供了便利。在处理不定数量参数的场景中，形参包的使用可以显著提高代码的可读性和可维护性。

+ 转发与变参模板的结合是C++中典型的创建模式

### 对于 入-出 参数，使用非const的引用来传递

+ 这条规则把函数的设计意图传达给了调用法：该函数会修改它的参数

### 对于 出 的输出值，优先使用返回值而非输出参数

+ 用返回值就好，但是别用const，因为它不但没有附加价值，而且还会干扰移动语义

### 要返回多个 出 值，优先考虑返回结构体或者多元组

+ 当你向std::set中插入一个值时，成员函数insert的重载会返回一个std::pair，它由两部分组成：
  + 一个指向所插入元素的迭代器
  + 还有一个bool，如果插入成功，它会被设置为true

+ C++11中的std::tie和C++17中的结构化绑定是将两个值绑定到某变量的两种优雅方式
+ 结构化绑定
C++结构化绑定（Structured Bindings）是C++17引入的一项特性，它提供了一种方便的方式来将多个变量绑定到结构体、元组或其他类似的数据结构的成员上。结构化绑定的目的是简化对结构化数据的访问和处理。

在结构化绑定中，可以使用`auto`关键字和花括号来声明和初始化多个变量，这些变量会被绑定到结构体或元组的成员。这使得代码更加简洁和可读。

以下是结构化绑定的基本语法：

```cpp
#include <tuple>

int main() {
    // 示例：使用结构化绑定绑定元组的元素
    std::tuple<int, double, std::string> myTuple{42, 3.14, "Hello"};

    auto [a, b, c] = myTuple;  // 结构化绑定

    // 现在 a, b, c 分别是 myTuple 的元素
    // a = 42, b = 3.14, c = "Hello"

    return 0;
}
```

上述例子中，`auto [a, b, c]` 表示使用结构化绑定将`myTuple`中的元素绑定到变量`a`、`b`、`c`上。

另外，结构化绑定还可以用于对结构体成员的绑定，如下所示：

```cpp
struct Point {
    int x;
    int y;
};

int main() {
    Point p{10, 20};

    auto [px, py] = p;  // 结构化绑定

    // px = 10, py = 20

    return 0;
}
```

结构化绑定在循环中也非常有用，可以方便地遍历容器中的元素：

```cpp
#include <vector>

int main() {
    std::vector<std::pair<int, double>> vec{{1, 3.14}, {2, 6.28}, {3, 9.42}};

    for (const auto& [index, value] : vec) {
        // 使用结构化绑定遍历容器中的元素
        // index 和 value 分别绑定到 pair 的第一个和第二个元素
        // ...
    }

    return 0;
}
```

结构化绑定在C++中提供了一种更简洁、更灵活的方式来处理结构化数据，从而使代码更加清晰易读。这个特性的引入使得C++语言更具现代感和表达力。

### 参数传递： 所有权语义

+ func(value): 函数func自己有一份value的拷贝并且就是其所有者。func会自动释放该资源
+ func(pointer*)： func借用了资源，所以无权删除该资源。func在每次使用前都必须检查该指针是否为空指针
+ func(reference&)：func借用了资源。与指针不同，引用的值总是合法的
+ func(std::unique_ptr): func是资源的新所有者。func的调用方法显式地把资源的所有权传递给了被调用方。func会自动释放该资源
+ func(std::shared_ptr): func是资源的额外所有者。func会延长资源的生存期。在func结束时，它也会结束对资源的所有权。如果func是资源的最后一个所有者，那么它的结束会导致资源的释放

+ 在应用层面使用std::move的意图并不在于移动。在应用层面使用std::move的目的是所有权的转移

+ C++ 所有权语义 详解
C++的所有权语义指的是对于对象内存的所有权管理方式，即确定何时创建、拥有、传递和销毁对象。在C++中，主要有两种所有权语义，即值语义和引用语义。

1. **值语义（Value Semantics）**：
   - **对象拥有其值**：当使用值语义时，对象在栈上或作为成员变量直接存储其值。当对象复制时，新的对象独立拥有自己的值，不受原始对象的影响。
   - **拷贝构造函数和赋值运算符**：值类型对象通常需要定义拷贝构造函数和赋值运算符，以确保正确地复制对象的值。

   ```cpp
   class ValueSemanticsExample {
   public:
       ValueSemanticsExample(int val) : value(val) {}
       
       // 拷贝构造函数
       ValueSemanticsExample(const ValueSemanticsExample& other) : value(other.value) {}
       
       // 赋值运算符
       ValueSemanticsExample& operator=(const ValueSemanticsExample& other) {
           if (this != &other) {
               value = other.value;
           }
           return *this;
       }

   private:
       int value;
   };
   ```

2. **引用语义（Reference Semantics）**：
   - **对象拥有引用**：当使用引用语义时，对象本身并不存储值，而是存储对其他对象的引用。多个对象可以共享相同的值。
   - **拷贝构造函数和赋值运算符需小心**：引用类型对象通常需要小心处理拷贝构造函数和赋值运算符，以避免意外地共享底层资源。

   ```cpp
   class ReferenceSemanticsExample {
   public:
       ReferenceSemanticsExample(int& valRef) : valueReference(valRef) {}

   private:
       int& valueReference;
   };
   ```

在现代C++中，智能指针也提供了一种更灵活的所有权语义。智能指针允许在堆上动态分配内存，并通过引用计数等机制来管理内存的释放。`std::unique_ptr`提供了独占所有权，而`std::shared_ptr`允许多个指针共享同一块内存。

```cpp
#include <memory>

class SmartPointerExample {
public:
    SmartPointerExample(int val) : value(std::make_unique<int>(val)) {}

private:
    std::unique_ptr<int> value;
};
```

在选择值语义还是引用语义时，需要根据程序的需求和性能考虑。值语义通常更容易理解和使用，而引用语义可以更有效地共享资源，但需要小心管理共享状态，以避免潜在的问题。

### 返回 T* (仅仅)用于表示位置

+ 指针仅用于表示位置。这正是函数find的作用

+ 指针或引用永远不应该转移所有权

### 当不希望发生拷贝，也不需要表达 没有返回对象 时，应该返回 T&

+ 当不存在 没有返回对象 这种可能性的时候，就可以返回引用而非指针了
+ 有时你想进行链式操作，但是不详为不必要的临时对象进行拷贝和析构

+ 返回局部对象的引用(指针)是未定义行为。未定义行为本质上意味着，不要假想程序的行为

### 不要返回 T&&

### 不要返回 std::move(本地变量)

### main()的返回类型是 int

+ 依照C++标准,main函数有两种变体
  + int main() {...}
  + int main(int argc, char** argv[]) {...}

+ 第二个版本等效于 int main(int argc, char* argv[]) {...}
+ main函数并不需要返回语句。如果控制流到达main函数的末尾而没有碰到一条返回语句，其效果相当于执行 return 0; 这意味着程序的成功执行

### 当函数不适用时(需要捕获局部变量，或者编写一个局部函数)，请使用lambda表达式

+ 什么时候必须用lambda表达式，什么是否必须使用普通函数。这里有两条明显的理由
  + 如果可调用实体必须捕获局部变量或者它是在局部作用域内声明的，你就必须使用lambda函数
  + 如果可调用实体需要支持重载，那么应该使用普通函数

## 在局部使用(包括要传递给算法)的lambda表达式中，优先通过引用来捕获

## 在非局部使用(包括要被返回，存储在堆上或者要传递给其他线程)的lambda表达式中，避免通过引用来捕获

+ 这两条规则高度关联，它们可以归结为： lambda表达式应该只对有效数据进行操作。
  + 当lambda通过拷贝捕获数据时，根据定义，数据总是有效的
  + 当lambda通过引用捕获数据时，数据的生存期必须超过lambda的生存期

### 在有选择的情况下优先采用默认参数而非重载

+ 如果你需要用不同数量的参数来调用一个函数，尽可能优先采用默认参数而不是重载。这样你就遵循了DRY(不要重复自己)原则

### 不要使用 va_arg 参数

+ 当你的函数需要接受任意数量的参数时，要使用变参模板而不是va_arg参数

+ 变参数函数(variadic function)是像std::printf这样的函数，可以接受任意数量的参数。
+ 问题是，必须假设传递的类型是正确的。当然这种假设非常容易出错，其正确性依赖于程序员的素养

+ va_arg宏的背景信息
  + va_list : 保存下列宏的必要信息
  + va_start : 启用对变参数函数参数的访问
  + va_arg : 访问下一个变参数函数的参数
  + va_end : 结束对变参数函数参数的访问
+ C++ va_arg 变参数函数参数 详解
`va_arg` 是C语言中用于处理可变参数函数（变参函数）的宏，它允许函数接受可变数量的参数。在C++中，虽然不鼓励使用C风格的可变参数函数，但仍然支持这一特性。

以下是关于`va_arg`的详解：

1. **头文件**：
   使用 `va_arg` 需要包含 `<cstdarg>` 头文件，其中定义了一组宏和类型，用于处理可变参数函数。

   ```cpp
   #include <cstdarg>
   ```

2. **可变参数函数的声明和定义**：
   可变参数函数通常以省略号 `...` 结尾，其中包含不定数量的参数。`va_list` 类型用于存储参数列表。

   ```cpp
   #include <cstdarg>
   #include <iostream>

   void myVarArgsFunction(int num, ...) {
       va_list args;
       va_start(args, num);

       for (int i = 0; i < num; ++i) {
           int value = va_arg(args, int);
           std::cout << "Argument " << i + 1 << ": " << value << std::endl;
       }

       va_end(args);
   }
   ```

   在上面的例子中，`myVarArgsFunction` 接受一个整数参数 `num`，表示后续可变参数的数量。函数通过 `va_arg` 从参数列表中获取具体的参数值。

3. **`va_start` 和 `va_end`**：
   在使用 `va_arg` 之前，需要使用 `va_start` 宏初始化 `va_list` 对象，以及在函数结束时使用 `va_end` 宏清理资源。

   ```cpp
   void myVarArgsFunction(int num, ...) {
       va_list args;
       va_start(args, num);

       // ...

       va_end(args);
   }
   ```

4. **注意事项**：
   - 参数传递的方式对使用 `va_arg` 很重要。对于整数、指针等基本类型，`va_arg` 可以很好地工作。但对于复杂的用户自定义类型，需要谨慎处理。
   - 没有可变参数的方式获取参数数量，需要依赖固定参数来传递数量信息。
   - 使用 `va_arg` 时，需要清楚每个参数的类型，以避免类型不匹配的问题。

5. **C++ 中的替代方案**：
   在现代C++中，推荐使用模板和标准库中的可变参数模板（variadic templates）来代替传统的可变参数函数。这种方式更类型安全，更灵活。

   ```cpp
   #include <iostream>

   template <typename... Args>
   void myVarArgsFunction(Args... args) {
       (std::cout << ... << args) << std::endl;
   }

   int main() {
       myVarArgsFunction(1, "Hello", 3.14);
       return 0;
   }
   ```

   在上面的例子中，使用可变参数模板实现了类似的功能，同时获得了更好的类型安全性。

+ 这些问题可以通过C++17的折叠表达式轻松解决。跟va_arg相比，折叠表达式会自动推导出其参数的数量和类型
+ 变参模板可以接受任意数量的参数。这些任意数量的参数由所谓的参数包持有，用省略号表示。
+ 此外，在C++17中，可以用二元运算符直接对参数包进行归约。这一针对变参模板的增强被称为折叠表达式

### 本章精华

+ 一个函数应该执行一个操作，要简短，并有一个精心选择的名字
+ 要把可以在编译期运行的函数实现为constexpr
+ 如果可能的话，将你的函数实现为纯函数
+ 区分一个函数的入，入/出和出参。对入参使用按值传递或者按const引用传递，对入/出参数使用按引用传递，对出参使用按值传递
+ 向函数传递参数涉及所有权语义的问题。按值传递使函数成为资源的独立所有者。按指针或引用传递意味着函数值是借用了该资源。std::unique_ptr将所有权转移给函数,std::shared_ptr则使函数称为共享的所有者
+ 当你的函数需要接受任意数量的参数时，要使用变参模板而不是va_arg参数

## 第五章 类和类层次结构

+ 类是一种用户定义类型，程序员可以为其指定表示方法，操作和接口。
+ 类的层次结构被用来组织相关的结构

+ Guidelines先给出了一些概要规则：
  + 具体类型
  + 构造函数，赋值和析构函数
  + 类的层次结构
  + 重载和运算符重载
  + 联合体

### class(类)和struct(结构体)之间的语法差异

+ 在结构体中，所有成员默认为 public(公开)。在类中，所有成员默认 private(私有)
+ 继承的情况也是如此。结构体的基类默认为 public，类的基类默认为 private

### 把相关的数据组织到结构(struct或class)中

+ 通过将相关元素放在结构体中，函数签名变得可以自我描述。

### 当类具有不变式时使用class；如果数据成员可以独立变化，则使用struct

+ 类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。不变式约束了类的实例的可能取值。
+ C++ 类中的不变式是什么意思
  + 在C++中，类的不变式（invariant）指的是在类的对象上始终保持成立的条件或属性。这是一种约定或规则，用于确保对象的有效性和一致性。在面向对象编程中，不变式是类设计的一部分，用于描述对象应该具有的状态。
  + 不变式通常与类的公共接口和方法一起工作，确保在对象上执行操作时，类的内部状态不会违反这些不变式。不变式可以看作是类内部约定的一部分，旨在维护对象的有效性。
  + 例如，考虑一个表示时间的类，该类有小时和分钟两个成员变量。一个可能的不变式是，小时应该在0到23之间，分钟应该在0到59之间。在类的方法中，如果有任何操作可能破坏这个不变式，需要在方法执行前或执行后重新确保不变式的成立。

+ 类的不变式在构造函数中被初始化和检查

### 在类中体现出接口和实现之间的区别

+ 类的公开成员函数是类的接口，私有部分则是实现

### 仅当函数需要直接访问类的内部表示时，才把它变成成员

+ 如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而类的内部结构的改变不会影响辅助函数

+ 运算符 =, (), [] 和 -> 必须是类的成员

### 将辅助函数与它们支持的类放在同一个命名空间中

+ 辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。

### 不要在一条语句里定义类或者枚举的同时声明该类型的变量

+ 如果在一条语句里定义类或者枚举同时声明其类型的变量，会引起混淆，因此应该避免

### 如有任何非公开成员，就使用class，而不是struct

### 尽量减少成员的暴露

+ 数据隐藏和封装是面向对象类设计的基石之一:你将类中的成员封装起来，只允许通过公共成员函数进行访问。
+ 你的类可能有两种接口
  + 一种是用于外部的 public 接口
  + 一种是用于派生类的 protected接口。
+ 其余成员都应该属于 private

### 具体类型

+ 具体类型是 最简单的一种类。它常常被称作为值类型，不属于某个类型层次结构的一部分
+ 规范类型是一种 行为类似于int 的类型，因此，它必须支持拷贝和赋值，相等比较，以及可交换。更正式的说法是，一个规范类型X行为上像int，支持下列操作
  + 默认构造: X()
  + 拷贝构造: X(const X&)
  + 拷贝赋值: operator = (const X&)
  + 移动构造: X(X&&)
  + 移动赋值: operator = (X&&)
  + 析构: ~X()
  + 交换操作: swap(X&, X&)
  + 相等运算符: operator == (const X&, const X&)

### 优先使用具体类型而不是类层次结构

+ 如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小且更快。
+ 不必担心继承，虚性，引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期的开销

### 让具体类型规范化

+ 如果你有一个具体类型，可以考虑将它升级为规范类型
+ 内置类型(例如int或者double)是规范类型，而用户定义类型(例如std::string)或容器(std::vector, std::unordered_map)也是如此

### 构造函数 ，赋值函数和析构函数

+ 六个特殊的成员函数，它们控制着对象的生命周期
  + 默认构造函数: X()
  + 拷贝构造函数: X(const X&)
  + 拷贝赋值函数: operator = (const X&)
  + 移动构造函数: X(X&&)
  + 移动赋值函数: operator = (X&&)
  + 析构函数: ~X()

+ 编译期可以为这 六大 生成默认实现，但是也可以明确用 =default(预置) 来要求编译提供它们，或者使用 =delete(预置) 来删除它们
+ 默认构造函数可以在没有参数的情况下被调用，但是它可能每个参数都有默认值

### 如果能避免定义默认操作，那就这么做

+ 这一规则也被称为 零法则。这意味着你可以通过使用有合适的拷贝/移动语义类型，来避免自行编写构造函数，拷贝/移动构造函数，赋值运算符或者析构函数。
+ 有合适的拷贝/移动语义的类型包括规范类型，例如内置类型bool或者double，也包括标准模板库(STL)的容器，例如std::vector或者std::string

+ 当编译器为一个类自动生成拷贝构造函数时，它调用该类的所有成员和所有基类的拷贝构造函数

### 如果定义或 =delete 了任何默认操作，就对所有默认操作都进行定义或 =delete

+ 六大 是紧密相关的。由于这种关系，你应该对所有特殊成员函数进行定义或者 =delete

### 让默认操作保持一致

### 构造函数应当创建完全初始化的对象

+ 构造函数的职责就是创建完全初始化的对象。类不应该有init(初始化)成员函数。将成员函数init设为私有，并从所有构造函数中调用它，这样做好一些，但是仍然不是最佳选择。
+ 当一个类的所有构造函数有共同的操作时，请使用委托构造函数.

+ C++ 委托构造函数是什么
C++11引入了委托构造函数的概念，它允许一个构造函数调用同一类中的另一个构造函数，以便避免代码的重复。

具体来说，委托构造函数是通过在成员初始化列表中使用自身类的其他构造函数来实现的。这样可以在一个构造函数中调用另一个构造函数，从而避免重复初始化相同的代码。

以下是一个简单的示例：

```cpp
#include <iostream>

class MyClass {
public:
    // 委托构造函数
    MyClass(int x) : MyClass(x, 0) {}

    // 主要构造函数
    MyClass(int x, int y) : x(x), y(y) {
        std::cout << "Constructing MyClass(" << x << ", " << y << ")" << std::endl;
    }

    void print() {
        std::cout << "x: " << x << ", y: " << y << std::endl;
    }

private:
    int x;
    int y;
};

int main() {
    MyClass obj1(42);
    obj1.print();

    MyClass obj2(10, 20);
    obj2.print();

    return 0;
}
```

在上面的示例中，`MyClass`有两个构造函数，其中一个是主要构造函数，另一个是委托构造函数。委托构造函数通过调用主要构造函数来初始化对象。

通过委托构造函数，可以在不同的构造函数中共享初始化逻辑，提高代码的可维护性。需要注意的是，委托构造函数的调用必须在成员初始化列表中完成，而不能在构造函数的函数体内。

### 如果构造函数无法构造出有效对象,则应该抛出异常

+ 如果使用无效的对象,你就总得在使用之前检查对象的状态.这样非常繁琐,低效而且容易出错.

### 确保可拷贝的(值类型)类有默认构造函数

+ 不正式的说，当类的实例缺少有意义的默认值时，该类就不需要默认构造函数

### 不要定义仅初始化数据成员的默认构造函数，而应该使用成员初始化器

+ 在设计新类时遵循的方法是：在类的主体中定义默认行为。明确定义的构造函数只用来改变默认行为

### 默认情况下，把单参数的构造函数声明为explicit

+ 说的更明确一点，一个没有explicit的单参数构造函数是个转换构造函数。

### 按照成员声明的顺序定义和初始化成员变量

+ 类成员是按照它们的声明顺序进行初始化的
+ 类的成员完全按照它们初始化的相反顺序被销毁

### 在使用常量来初始化时，优先选择类内初始化器，而不是构造函数的成员初始化

+ 虽然类内初始化规定了一个对象的默认行为，但是构造函数可以改变这一默认行为。

### 在构造函数里优先使用初始化而不是赋值

+ 初始化对赋值有两个最明显的优点：
  + 你不会因为忘记赋值而使用未初始化的成员
  + 初始化可能更快，并且绝不会比赋值慢

### 特殊构造函数

+ 从C++11开始，一个构造函数可把它的工作委托给同一个类的另一个构造函数，并且构造函数可从父类继承。

### 使用委托构造函数来表示类的所有构造函数的共同动作

+ 一个构造函数可以把它的工作委托给同一个类的另一个构造函数。委托是C++中把所有构造函数的共同动作放到一个构造函数中的现代方式。
+ 递归调用构造函数是未定义行为。

### 使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中

+ 如果可以的话，在派生类中重用基类的构造函数。当派生类没有成员时，这种重用的想法很合适。
+ 如果在可重用构造函数时不重用，就违反了DRY(不要重复自己)原则。
+ 继承的构造函数保留了它们在基类中定义的所有特性，例如访问说明符或者属性explicit和constexpr

### 拷贝操作

+ 在拷贝之后(a = b)，a 和 b必须相同(a == b)
+ 拷贝可深可浅。
  + 深拷贝意味着对象a和b之后时相互独立的(值语义)
  + 浅拷贝意味着对象a和b之后共享一个对象(引用语义)

### 移动操作

+ C++标准要求被移动的对象之后必须处于一个未指定但是有效的状态。通常情况下，这个被移动的状态是移动操作源对象的默认状态

### 多态类应当抑制公开的拷贝/移动操作

+ 多态类是定义或者继承了至少一个虚函数的类
+ 拷贝一个多态类的操作可能会以切片而告终。切片是C++中最黑暗的部分之一
  + 切片意味着你想在赋值或者初始化过程中拷贝一个对象，但是你只得到该对象的一部分。

### 析构函数

+ 对象的析构函数会在其生存期结束时被自动调用。更准确地说，对象的析构函数是在对象超出作用域时调用的

### 如果一个类在对象销毁时需要明确的动作，那就定义析构函数

+ 问题在于，在你的情况下，编译器生成的析构函数是否已经够用。
  + 如果必须在用户定义类型的生存期结束时执行额外的代码，就必须写析构函数。
  + 反过来说，如果类中没有成员需要额外的清理，就没必要定义析构函数

### 类获得的所有资源都必须在该类的析构函数中释放

### 指针和引用

+ 如果你的类有原始指针或者引用，则必须要回答一个关键问题: 谁是所有者

### 如果类里有原始指针(T*)或者引用(&)，请考虑它是否有所有权

+ 如果一个类有原始指针或者引用，你必须明确所有权问题，因为指针既可以表示所有权，也可以表示借用。
+ 如果所有权不明确，你可能会删除你不拥有的一个对象的指针，也可能会漏删你拥有的一个指针。在第一种情况下，由于双重删除，会有未定义行为；在第二种情况下，会面临内存泄漏

### 如果类具有所有权的指针成员，请定义析构函数

+ 如果类拥有一个对象，它就要负责销毁它，销毁是析构函数的工作。

### 基类的析构函数应该要么是public且virtual，要么是protected且非virtual

+ 公开的虚析构函数
  + 如果基类有public且virtual的析构函数，你可以通过基类的指针来销毁派生类的实例，引用也是如此。

+ 受保护的非虚析构函数
  + 如果基类的析构函数是protected，你就不能用基类的指针或者引用来销毁派生对象；因此，析构函数不需要声明为virtual

+ 关于基类的析构函数的访问说明符的一些总结性意见
  + 如果基类的析构函数私有(private)，你就无法从该类派生
  + 如果基类的析构函数受保护(protected)，那么你能从该类派生出子类，然而只能使用子类

### 如果你需要明确使用默认语义，则使用 =default

### 当想要禁用默认行为(且不需要替代方法)时使用 =delete

### 不要在构造函数和析构函数中调用虚函数

+ 在构造函数或析构函数中调用纯虚函数是未定义行为。

### 使 == 对操作数的类型对称，并使其 noexcept

+ 解决不对称的优雅方法是在类中声明一个友元运算符 ==
+ 示例
```cpp
class MyInt
{
    int num;
public:
    MyInt(int n) : num(n) {};
    friend bool operator == (const MyInt& lhs, const MyInt& rhs) noexcept
    {
        return lhs.num == rhs.num;
    }
}; 
```

### 类层次结构

+ 什么是类的层次结构？
  + 一个类的层次结构代表了一组分层组织的概念。
  + 基类通常有两种用途。一种通常被称为接口继承，另一种是实现继承。

+ 接口继承使用公共继承，它把用户和实现分开，允许派生类增加或者改变基类的功能，而不影响基类的用户。
+ 实现继承经常使用私有继承。在典型情况下，派生类通过调整基类的功能来提供其功能。实现继承的一个突出例子是适配器模式，因为你可以用多重继承来实现。适配器模式的想法是将现有的接口改编成一个新的接口。适配器使用了对实现的四有继承和对新接口的公共继承。新的接口使用现有的实现来为用户提供服务。

### (仅)使用类的层次结构来表达具有内在层次结构的概念

### 如果基类被当作接口使用，那就把它变成抽象类

+ 抽象类是至少有一个纯虚函数的类。纯虚函数(virtual void function() = 0)是必须由派生类实现的函数(除非派生类也是抽象类)。一个抽象类不能被实例化。
+ 抽象类可以为纯虚函数提供一个实现。这样，派生类也可以使用这个实现。
+ 接口通常应该由公共的纯虚函数组成，没有数据成员，并且有默认/空的虚析构函数(virtual ~My_interface() = default)

### 当需要完全分离接口和实现时，以抽象类作为接口

+ 抽象类的目的就是分离接口和实现。

### 如果要对多态类进行深拷贝，应该使用虚函数clone，而不是公开的拷贝构造/赋值

+ 拷贝一个多态类可能会导致切片问题。为了解决这个问题，应该覆盖一个虚clone函数，让它根据实际类型进行复制并且返回一个到新对象的有所有权的指针(std::unique_ptr)
+ 在派生类里，通过使用所谓的协变返回类型来返回派生类型
  + 协变返回类型 : 允许覆盖成员函数返回被覆盖成员函数的返回类型的派生类型。

+ C++ 协变返回类型是什么
C++11引入了协变返回类型（Covariant Return Types）的概念，允许在派生类中覆盖基类的虚函数时，返回类型可以是基类函数返回类型的派生类型。

在使用协变返回类型时，你可以在派生类中重新定义虚函数的返回类型，而不必显式使用类型转换。这使得代码更加清晰和类型安全。

以下是一个简单的示例：

```cpp
#include <iostream>

class Base {
public:
    virtual Base* clone() const {
        std::cout << "Base::clone()" << std::endl;
        return new Base(*this);
    }
};

class Derived : public Base {
public:
    // 协变返回类型
    virtual Derived* clone() const override {
        std::cout << "Derived::clone()" << std::endl;
        return new Derived(*this);
    }
};

int main() {
    Derived derived;
    Base* basePtr = &derived;

    // 调用协变返回类型的虚函数
    Base* cloned = basePtr->clone();

    delete cloned;

    return 0;
}
```

在上述示例中，`Derived` 类覆盖了基类 `Base` 的虚函数 `clone`，并使用协变返回类型，返回的类型是 `Derived*` 而不是 `Base*`。这样，通过基类指针调用虚函数时，返回的是正确的派生类型。

### 不要无缘无故的把函数变成 virtual

+ 虚函数不是一个无代价的特性
  + 增加了运行时间和对象代码的大小
  + 因为它可以在派生类中被覆盖，它更容易出问题

+ 通常情况下，一个类的所有数据成员的访问说明符都相同：所有数据成员要么全部属于public，要么全部属于private
  + 如果数据成员上面没有不变式，则用public。使用struct关键字
  + 如果数据成员上有不变式，则用private。使用class关键字。

### 避免无价值的取值和设值函数

+ 如果取值和设值函数没有对数据成员提供额外的语义，它们就没有价值
+ x和y可以取任意值。这意味着Point的实例并没有对x和y维持一个不变式。x和y仅仅是数值而以，更合适的做法是以struct作为值的集合。

### 避免protected数据

+ protected数据使程序变得复杂且容易出错。如果把protected数据放到基类里，你就不能单独考虑派生类，因而破坏了封装。你会不得不对类的整个层次结构进行思考
  + 我必须实现一个构造函数来初始化protected数据吗
  + 如果我使用protected数据，它们的实际价值是什么
  + 如果我修改protected数据，谁会受影响

+ 在类层次结构变得越来越复杂的时候，这些问题也会变得越来越难以回答
+ 换句话说，protected数据都是类层次结构范围内的一种全局数据而你知道非const的全局数据不好。

### 确保所有的非const数据成员都具有相同的访问级别

### 多重继承

+ 多重继承有两个典型的使用场景：
  + 将接口继承和实现继承分开
  + 实现多个不同的接口

### 在设计类的层次结构时，要区分实现继承和接口继承

+ 接口继承关注的是接口和实现的分离，这样派生类的修改就可以不影响基类的用户；
+ 实现继承则使用继承来扩展现有的功能，从而支持新功能。

+ 纯接口继承是指你的基类只有纯虚函数。相反，如果你的基类有数据成员，或者已经有函数实现，那就是实现继承了。

+ 不应该把接口继承和实现继承的概念混在一起。我们如何才能两者兼顾：用接口分层的稳定接口，还有实现继承的代码重用？
  + 一个可能的答案是双重继承。
  + 另一个答案是PImpl惯用法。

+ PImpl代表指向实现的指针(pointer to implementation)。它把实现的细节放在一个单独的类里，并通过指针来访问。

### 使用多重继承来表示多个不同的接口

### 使用using为派生类及其基类创建重载集

### 不要为虚函数和它的覆盖函数提供不同的默认参数

+ 如果你为虚函数和覆盖函数提供不同的默认参数。你的类可能会引发很多混乱

### dynamic_cast

+ dynamic_cast的职责说明:
  + 沿继承层及向上，向下及侧向，安全的转换到其他类的指针和引用

### 在穿越类层次不可避免时，应该使用 dynamic_cast

+ dynamic_cast的职责就是在类层次中穿越

### 当 找不到所需的类 被视为错误时，须对引用类型使用 dynamic_cast

### 当 找不到所需的类 被视为有效选择时，须对指针类型使用 dynamic_cast

+ 简而言之，你可以对一个指针或引用使用 dynamic_cast。
+ 如果 dynamic_cast 失败了，对于指针，你会得到一个空指针，对于引用，则会出现 std::bad_cast 异常。
+ 因此，如果失败是一种有效选择，请对指针使用 dynamic_cast；如果失败不是一个有效选择，那就是用使用

### 永远不要把指向派生类对象数组的指针赋值给指向基类的指针

+ 其结果可能是无效对象访问或者内存破坏

+ 退化，是一种隐式转换的名称，它进行左值到右值，数组到指针以及函数到指针的转换，并去除const和volatile限定。

### 重载和运算符重载

+ 你可以对函数，成员函数，模板函数和运算符进行重载。你不能重载函数对象，因此你也不能重载lambda表达式。
+ 重载和重载运算符的七条规则遵循一个关键思想：为用户构建直观的软件系统。

### 应当对带有常规含义的操作使用运算符

+ 常规意义暗示着，你应当使用合适的运算符。举例来说：
  + ==, !=, <, <=, >, >= : 比较操作
  + +, -, *, /, % : 算术操作
  + ->, 一元*, [] : 对象访问
  + = : 对象赋值
  + <<, >> : 输入和输出操作

### 对于对称的运算符，应采用非成员函数

### 避免隐式转换运算符

### 重载的操作应当大致等价

## 仅对大致等价的操作进行重载

+ 等价的操作应该有相同的名字。

### 在操作数所在的命名空间中定义重载运算符

+ 实参依赖查找(ADL,也叫Koenig查找)意味着，对于无限定的(unqualified)函数调用，C++在编译时会把函数参数命令空间中的函数也考虑进去。
+ 对于运算符，C++编译时也考虑操作数的命名空间。因此，应该在操作数的命名空间中定义重载运算符。

### 联合体

+ 联合体是一种特殊的类类型。所有成员都从同一地址开始。一个联合体一次只能容纳一个类型：因此你可以节约内存。
+ 一个带标签联合体(又称可辨识联合体)是一个可以跟踪其类型的联合体。std::variant就是一个带标签联合体。
+ C++ Core Guidelines指出，联合体的职责是节约内存。你不应该使用裸联合体，而应该使用std::variant这样的带标签联合体。

### 使用union来节约内存

### 避免裸联合体

+ 裸联合体非常容易出错，因为你必须跟踪底层类型。

### 使用匿名union来实现带标签联合体

### 本章精华

+ 尽量使用具体类型而不是类的层次结构。让你的具体类型称为规范类型。规范类型支持六大(默认构造函数，析构函数，拷贝和移动构造函数，拷贝和移动赋值运算符)，交换函数和相等运算符。
+ 如果可能的话，就让编译器生成这六大。如果不能，就通过default请求所有这些特殊成员函数。如果这也不行，就明确实现所有这些函数，并给它们一个一致的设计。拷贝构造函数或拷贝赋值运算符应该拷贝构造。移动构造函数或移动赋值运算符应该移动。
+ 构造函数应该返回一个完全初始化的对象。使用构造函数来建立不变式。(不变式(invariant),是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式)。不要使用构造函数来设置成员的默认值。尽量使用类内初始化来减少重复。
+ 如果你需要在对象销毁时进行清理动作，请实现析构函数。基类的析构函数应该要么是public且virtual，要么是protected且不是虚函数
+ 要对具有内在层次的结构使用类的层次结构进行建模。如果基类作为一个接口使用，就让基类成为抽象类，以便分离接口和实现。一个抽象类应该只有一个预置的默认构造函数
+ 区分接口继承和实现继承。接口继承的目的是将用户与实现分隔开：实现继承是为了重用现有的实现。不要在一个类中混合这两个概念。
+ 在一个有虚函数的类里，析构函数应该要么是public加virtual，要么是protected。对于一个虚函数，要使用virtual override或者final中的一个，不多也不少。
+ 一个类的数据成员应该要么全部public，要么全部private。如果类建立了一个不变式，就让它们全部private，并使用class。如果不是，就让他们public，并使用struct
+ 把单参数构造函数和转化运算符标记为explicit
+ 使用联合体来节约内存，但不要使用裸联合体；尽量使用带标签联合体，例如C++17中的std::variant

## 第六章 枚举

+ 枚举用来定义整数值的集合，也是这类集合的类型
+ 优先选择有作用域枚举(scopted enumeration)，而不是传统的枚举。有作用域枚举也被称为强类型枚举或枚举类(enum class)
+ 传统的枚举有什么缺陷？
  + 没有作用域
  + 会隐式转换为int
  + 会污染全局命令空间
  + 类型未知。只要求该类型足够大且能容下所有枚举向

### 优先使用枚举而不是宏

+ 宏没有作用域，且没有类型

### 使用枚举表示相关联的具名常量的集合

### 优先使用 enum class,而不是普通enum

+ 有作用域枚举项(enum class)不会自动转型为int。要访问它们，就必须要使用作用域运算符

### 不要对枚举项使用ALL_CAPS命令方式

+ 如果对枚举项使用ALL_CAPS(全大写加下划线)，你可能会与宏发生冲突，因为宏通常写成ALL_CAPS的方式
+ 当然，这条规则不仅适用于枚举项，也适用于一般常量

### 避免使用无名枚举

+ 不是每个编译期常量都应该是enum。C++还允许将编译期常量定义为constexpr变量。只是互相关联的常量集合中使用enum

### 仅在必要时指定枚举的底层类型

+ 从C++11开始，可以指定枚举的底层类型，以节省内存。默认情况下，有作用域enum的类型是int，因此，可以前置声明enum

### 仅在必要时指定枚举项的值

+ 通过指定枚举项的值，你可能会设定一个值两次

### 本章精华

+ 使用有作用域枚举而不是传统的枚举。顾名思义，有作用域枚举具有作用域，不会隐式地转换为int，不会污染全局命名空间，默认情况下其底层类型是int
+ 仅在必要时指定有作用域枚举的底层类型和枚举项的值

## 第七章 资源管理

+ 首先，资源是什么？资源就是你必须管理的东西。这意味着，你因为资源的有限而必须获取和释放它，或者你必须对它进行保护。
+ 你拥有的存储空间，套接字，进程或线程都是有限的；而在某个时间点上，只有一个进程可以写入共享文件，只有一个线程可以写入共享变量。

+ 如果考虑到资源管理，一切都可以归结为一个关键点: 所有权。现代C++非常优秀的一点是，我们可以在代码中直接表达对所有权的意图。
  + 局部对象: C++运行时作为所有者来自动管理这些资源的生存期。全局对象或类的成员也是如此。C++ Core Guidelines中将它们称为有作用域的对象。
  + 引用: 我不是所有者。我仅仅借用了不可以为空的资源
  + 原始指针: 我不是所有者。我仅仅借用了可能为空的资源。我不可以删除该资源。
  + std::unique_ptr: 我是资源的独占所有者。我可以显式的释放资源。
  + std::shared_ptr: 我跟其他的shared_ptr共享资源，并且当我是最后一名所有者时会释放资源。我可以显式地释放我的所有权份额
  + std::weak_ptr: 我不是该资源的所有者，但是我可以通过使用成员函数lock()暂时称为该资源的共享所有者。

+ 第一条通用规则是 C++惯用法: RAII。RAII代表Resource Acquisition Is Initialization(资源获取即初始化)。C++标准库系统性地依赖于RAII

### 使用资源句柄和RAII(资源获取即初始化)自动管理资源

+ RAII的理念很简单，你为资源创建一种代理对象。代理的构造函数获取资源，而代理的析构函数释放资源。RAII的中心思想是，这个代理作为局部对象，其所有者是C++运行时，于是，它所代理的资源也归C++运行时所有。当作为本地对象的嗲里对象离开作用域的时候，代理的析构函数会被自动调用。
+ RAII在C++生态系统中被大量使用。RAII的例子有标准模板库(STL)的容器，智能指针和锁。
  + 容器管理元素
  + 智能指针管理内存
  + 锁管理互斥量

### 原始指针(T*)不表示所有权

### 原始引用(T&)不表示所有权

+ 这两条规则都概括了向函数传递指针或引用时，以及要从函数返回指针(T*)或者左值引用(T&)时所有权方面需要考量的规则。
+ 指针和引用的关键问题是，谁是资源的所有者？
  + 如果你不是所有者，只是借用了它，那你不得删除该资源

### 优先使用有作用域的对象，不做非必要的堆上分配

+ 有作用于的对象是一个带有自己作用域的对象。它可能是个本地对象，全局对象或者某个类的成员。
+ C++运行时会管理好有作用域的对象

+ 一种好用的技巧是使用额外的花括号来定义一个人工作用域。由于人工作用域的存在，你可以显式地控制一个本地对象的生存期。

### 内存分配和释放

+ 在C++中使用new创建一个对象的操作包括两个步骤
  + 为该对象分配内存
  + 在分配好的内存上构造该对象
+ operator new 或 operator new []是第一步；构造函数是第二步
+ 同样的策略也适用于析构函数，不过得反过来。
  + 首先，调用析构函数(如果有的话)，
  + 然后用operator delete或者operator delete []释放内存

### 避免malloc() 和 free()

+ new 和 malloc，或 delete 和 free 之间有什么区别？
  + C 函数malloc 和 free只做了一半的工作。malloc 分配内存，free则释放内存
  + malloc并不调用构造函数，而free也不调用析构函数
+ 这意味着，你如果使用一个仅仅通过malloc创建的对象，程序有未定义行为

### 避免显式调用 new 和 delete

+ 你应该牢记这条规则。这条规则的重点在于显式这个词，因为智能指针或STL容器会让你的对象隐式地使用 new 和 delete

### 立即将显式资源分配的结果交给一个管理者对象

+ 这条内存分配规则有一个特殊的名字: NNN.NNN是 No Naked New(不要裸的New)的缩写，它意味着内存分配的结果应该交给一个管理者对象。这个管理者对象可以是std::unique_ptr或者std::shared_ptr

### 在一条表达式语句中最多进行一次显式资源分配

### 智能指针

+ 从库的角度，智能指针是C++11标准中最重要的补充。
+ 智能指针的规则归结为两类
  + 作为所有者的基本用法
  + 以及作为函数参数的基本用法

### 用unique_ptr或shared_ptr表示所有权

+ 为了全面，这条规则还包括std::weak_pte。现代C++共有三种智能指针来表达三种不同的所有权
  + std::unique_ptr: 独占所有者
  + std::shared_ptr: 共享所有者
  + std::weak_ptr: 对std::shared所管理资源的非占有的引用

+ std::unique_ptr是其资源的独占所有者。它不可以被拷贝，只能被移动
+ std::shared_ptr则共享所有权。当你拷贝或者拷贝赋值某个共享指针，它的引用计数增加；当你删除或者重置某个共享指针，它的引用计数则减少。当引用计数变为0时，其底层资源将被删除。
+ std::weak_ptr并不是智能指针。它是一个引用，引用指向被std::shared_ptr所管理的对象。它的接口颇为有限，不可以透明地访问底层资源。通过对std::weak_ptr调用其成员函数lock，可以从某个std::weak_ptr创建出一个std::shared_ptr

### 除非需要共享所有权，否则能用unique_ptr就别用std::shared_ptr

+ 当你需要智能指针的时候，应该首选std::unique_ptr。在设计上std::unique_ptr和原始指针一样块，且一样可以高效利用内存。
+ 不要为了做拷贝而贪图方便地使用std::shared_ptr。std::unique_ptr不可以被拷贝，但仍可以被移动

### 使用make_shared()创建shared_ptr

### 使用make_unique()创建unique_ptr

+ 使用这种方式创建智能指针，有两个理由
  + 第一个理由是异常安全
  + 第二个理由只对std::shared_ptr成立
    + 当你调用std::shared_ptr<int>(new int(1998))时，会发生两次内存分配：一次时针对new int(1998)，还有一次是针对std::shared_ptr的控制块。内存分配代价较高，所以你应当尽量避免。
    + std::make_shared<int>(1998)可将两次内存分配变成一次，因此更快。
    + 此外，分配出来的对象(new int(1998))和控制块彼此相邻，所以访问也会更快。

### 使用std::weak_ptr来打破shared_ptr形成的环

+ 如果std::shared_ptr互相引用，就会形成环状引用
+ 例如，一个双向连表就会形成环。如果使用std::shared_ptr来实现链表，那引用计数永远不会为零，最终导致内存泄漏

### 函数参数

+ 本节其余规则回答了这样几个问题
  + 函数该如何接受智能指针作为参数
  + 参数应该是std::unique_ptr还是std::shared_ptr
  + 参数应该以const还是以引用的方式获取
+ 你应该将这些以智能指针作为函数参数的规则看作之前更一般函数参数传递规则的细化

+ 首先，必须回答何时以智能指针作为函数参数
+ 其次，如果函数通过引用来获取参数，会带来危险

### 只在显式表达生存期语义时以智能指针作参数

+ 如果你把指针指针作为参数传递给一个函数，而在这个函数中，你只使用智能指针的底层资源，你就做错了。
+ 在这种情况下，应该以原始指针或引用作为函数参数，因为你并不需要智能指针的生存期语义

+ 重装(reset)表示函数会修改引用参数的智能指针的内容，来指向一个不同的对象。

+ 关于类型为std::shared_ptr的参数，有三条规则
  + 接受shared_ptr<widget>参数以表达函数是共享的所有者
  + 接受shared_ptr<widget>&参数以表达函数可能会重装共享指针
  + 接受const shared_ptr<widget>&参数以表达函数可能保有指向对象的一份引用计数

### 不要传递从智能指针别名中获得的指针或引用

+ 智能指针的别名(智能指针的引用)是智能指针，但你不是所有者。如果违反这条规则，会造成悬空指针
+ 更为直白的规则：只有当你实际持有共享资源所有权的一部分时，你才可以访问该资源

### 本章精华

+ 要自动管理资源。为资源创建某种代理对象。代理的构造函数获取资源，而代理的析构函数释放资源。C++运行时会管理好代理
+ 尽可能使用有作用域的对象。有作用域的对象是一个带有自己作用域的对象。它可能是个本地对象，全局对象，或者是某个类的成员。C++运行时会管理好有作用域的对象。
+ 不要使用malloc和free，并避免使用new和delete。立即将显式资源分配的结果交给一个管理者对象，例如std::unique_ptr或std::shared_ptr
+ 使用智能指针std::unique_ptr来表达独占所有权，并使用智能指针std::shared_ptr来表达共享所有权。使用std::make_unique来创建std::unique_ptr，并使用std::make_shared来创建std::shared_ptr
+ 如果你要表达生存期语义，就以智能指针作为函数参数。否则，用普通指针或引用即可
+ 按值接受智能指针作为函数参数以表达所有权语义；按引用接受智能指针以表达函数可能会重装智能指针。

## 第八章 表达式和语句

+ 表达式和语句是表达动作和计算的最基本和最直接的方式
+ 表达式和语句的非正式定义
  + 表达式的计算结果为值
  + 语句做某事，通常由表达式或语句组成

+ 包含在块作用域中的声明是语句。块作用域是指包含在花括号内的内容

### 优先使用标准库，而不是其他库和 手工代码

+ 如果你想提高组织中的代码质量，那就用一个目标取代所有的编码规则：用算法代替原始循环。

### 优先使用合适的抽象，而非直接使用语言特性

+ 合适的抽象通常意味着不必考虑资源的所有权

### 声明

+ 首先，以下是C++ Core Guidelines对声明的定义
  + 声明是一条语句。声明将名字引入作用域中，并可能引起具名对象的构造。
+ 声明的规则是关于名字，变量及其初始化以及宏的规则

+ 好名字可能是号软件最重要的规则

### 保持作用域较小

+ 如果作用域很小，你可以把它放在一屏之中以便弄清楚状况。如果作用域变得太大，则应该将代码结构化为函数或类。在重构过程中，要时别逻辑实体并使用自解释的名称。

### 在 for 语句的初始化和条件中声明名字以限制作用域

+ 自第一个C++标准开始，就可以在for语句中声明变量
+ 自C++17以来，我们还可以在if或switch语句中声明变量

### 常用的和局部的名字要短，不常用的和非局部的名字要长

+ 给变量起名i或j，或给变量起名T，其意图立即明确
  + i和j是索引
  + T是模板参数的类型

+ 名字应该是自解释的。在简短的上下文中，你一眼就能够理解变量的含义。但它不会自动适用于较长的上下文，这时，应该使用更长的名字

### 避免看起来相似的名字

### 避免ALL_CAPS风格的名字

+ 如果使用了ALL_CAPS(全大写加下划线)风格的名字，宏替换可能会发生，因为ALL_CAPS常常用于宏

### 每条声明(仅)声明一个名字

### 使用auto来避免类型名字的多余重复

+ 如果你使用auto，修改代码可能就是小菜一碟

### 不要在嵌套作用域中复用名字

+ 出于可读性和可维护性原因，不应在嵌套作用域中复用名字。

### 始终初始化对象

+ 使用auto，这样，你再也不会忘记初始化变量。

### 不要在确实需要使用变量(或常量)之前就将其引入

### 在获得可用来初始化变量的值之前不要声明变量。

### 优先使用{}初始化语法

+ 使用 {} 初始化的原因有很多
  + 始终可用
  + 克服最令人烦恼的解析
  + 放置窄化转换
+ 前两点使C++更符合直觉，而最后一点经常可以防止未定义行为。

+ 利用auto进行类型推导
  + 如果你用auto进行自动类型推导，然后结合使用{}初始化，你会得到std::initializer_list。
  + 这种违反直觉的行为在C++17中改掉了

+ 窄化转换是指算术值的隐式转换，精度损失也包含在内。

### 不要将同一个变量用于两个不相关的目的

### 使用lambda表达式进行复杂的初始化(尤其是对const变量)

+ 为什么要就地(in place)调用lambda函数？
  + 这条规则回答了这个问题。可以把复杂的初始化步骤放在lambda里。
  + 如果你的变量应该变成const，那么lambda的就地调用尤其有价值

+ 如果不想在初始化后修改你的变量，则应该让他成为const。但有时，变量的初始化包括不止一个步骤，因此，你不能使变量称为const
+ 这个时候，lambda表达式就可以用来救场了。你可以使用一种技术，它被称为立即调用的lambda表达式。
  + 你可以把初始化代码放到lambda表达式中，通过引用捕获环境变量，用就地调用的lambda函数初始化你的const变量。
```cpp
const widget x = [&]{
  widget val;
  for (auto i = 2; i <= N; ++i>)
  {
    val += some_obj.do_something_with();
  }
  return val;
}();
```
  + 你需要把整个初始化代码都放在lambda的函数体中，最后一对圆括号调用了它。

### 宏

+ 如果C++标准化委员会中有一个共识，那就是宏必须被淘汰。

### 避免复杂的表达式

### 如果对运算符优先级不确定，那就使用括号

### 保持指针的使用简单明了

+ 对指针的复杂操纵是错误的一个主要来源

### 避免 魔法常量，采用符号常量

+ 符号常量比魔法常量更明确

### 避免对范围检查的需要

+ 如果不需要检查范围的长度，你就不会遇到 差一错误(off-by-one error)
  + 一种常见的安全编码错误，指边界条件写错造成的循环次数差一的错误。最常见的原因是不小心把 < 和 <= 写错了

#### 使用nullptr 而不是0或者NULL

+ 为什么不应该使用0或NULL来表示空指针
  + 0 ： 字面量0可以是空指针(void*)0，也可以是数字0。这由上下文决定，因此，起初是空指针的东西，最后可能变成数字
  + NULL ： NULL是一个宏，因此你不知道里面是什么

+ 空指针nullptr避免了数字0和宏NULL的歧义。nullptr的类型会一直是std::nullptr_t。
+ 你可以将nullptr赋值给任意一个指针，该指针就会变空，不指向任何数据。
+ nullptr可以显式的或基于上下文转换为bool类型。因此，你可以在逻辑表达式中使用nullptr。

### 用delete[]删除数组，用delete删除非数组对象

+ 手工内存管理，以及不使用STL的容器或智能指针(std:unique_ptr<X[]>)是非常容易出错的
+ 用非数组形式的delete来删除C数组是未定义行为

### 不要对无效指针解引用

+ 如果你对一个无效指针解引用，你的程序就会出现未定义行为。避免这种行为的唯一方法是在使用指针之前检查它
+ 如何解决此问题
  + 不要使用裸指针。
  + 如果需要像指针的语义，请使用智能指针

### 避免有未定义求值顺序的表达式

### 不要依赖函数参数的求值顺序

### 避免转型

+ 粗略来说，C风格转型会先从static_cast开始,接着是const_cast，最后执行reinterpret_cast

### 如果必须使用转型，请使用具名转型

+ 在C++11中，我们有以下六种转型
  + static_cast : 在类似的类型之间进行转换，例如指针类型或数字类型
  + const_cast : 添加或删除const或volatile
  + reinterpret_cast : 在指针之间或在整形和指针之间转换
  + dynamic_cast : 在同一个类层次中的多态