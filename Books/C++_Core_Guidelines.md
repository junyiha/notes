## 简介

+ C++ Core Guidelines笔记

## 第二章 理念

### 在代码中直接表达思想

+ 程序员应该直接用代码直接表达他们的思想，因为代码可以被编译器和工具检查
+ 一个专业的C++开发者应该了解STL算法

### 用ISO标准C++写代码

+ 使用当前的C++标准，不要使用编译器扩展
+ 此外，要注意未定义行为和实现定义行为
  + 未定义行为： 
  + 实现定义行为：程序的行为可能因编译器实现而异。实现必须在文档里描述实现的行为

在C++编程中，有两个重要的概念：未定义行为（Undefined Behavior）和实现定义行为（Implementation Defined Behavior）。

1. **未定义行为 (Undefined Behavior)**:
   - 当程序包含未定义行为时，C++标准没有规定程序的行为，允许编译器和运行时环境采用任何行为。这可能导致程序崩溃、产生意外结果、或者在不同的编译器、平台或编译选项下表现不同。
   - 未定义行为可能是由于程序中的错误、溢出、指针操纵等原因引起的，也可能是标准规定没有定义的操作。

2. **实现定义行为 (Implementation Defined Behavior)**:
   - 当某个方面的行为是由C++标准定义的，但是标准允许不同的实现在这方面做出不同的选择，这被称为实现定义行为。
   - 例如，标准规定某个操作的结果可以有多种可能，但实现需要选择其中一种并在文档中明确说明。

示例：

```cpp
#include <iostream>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    std::cout << arr[5] << std::endl; // 未定义行为，越界访问数组

    int x = -5;
    unsigned int y = 10;
    std::cout << x * y << std::endl; // 实现定义行为，结果取决于具体的实现
    return 0;
}
```

在这个例子中，访问数组`arr`的第六个元素是未定义行为，因为数组索引越界。而对于`x * y`的乘法，结果是实现定义的，因为标准并没有规定对于负数和无符号数相乘的具体行为。

在编写C++代码时，尽量避免未定义行为，因为它可能导致代码在不同环境下的行为不可预测。实现定义行为可能会因不同的编译器或平台而异，但至少有一个可预测的结果。

+ 当你必须使用没有写在ISO标准里的扩展时，可以用一个稳定的接口将它们封装起来

### 表达意图

+ 表达意图是良好的代码文档的一个重要准则。文档应该说明代码会做什么，而不是代码会怎么做

### 不要泄漏任何资源

+ 资源可以是内存，也可以是文件句柄或者套接字。
+ 处理资源的惯用法是RAII。RAII是 Resource Acquisition Is Initialization(资源获取即初始化)的缩写，本质上意味着你在用户定义类型的构造函数中获取资源，在析构函数中释放资源。通过使对象成为一个有作用于的对象，C++的运行时会自动照顾到资源的生存期
+ C++大量使用RAII：锁负责处理互斥量，智能指针负责处理原始内存，STL的容器负责处理底层元素，等等

### 不可变数据优先于可变数据

+ 使用不可变数据的理由有很多。
+ 首先，当你使用常量时，你的代码更加容易验证
+ 最重要的是常量在并发程序中具有很大的优势
+ 不可变数据在设计上是没有数据竞争的，因为数据竞争的必要条件就是对数据进行修改

### 封装杂乱的构件，不要让他在代码中散布开

+ 混乱的代码往往是低级代码易于隐藏错误，容易出现问题。
+ 如果可能的话，用STL中的高级构件(例如容器和算法)来取代你的杂乱代码。
+ 如果这不可能，就把那些杂乱的代码封装带一个用户自定义的类型或者函数中

### 适当使用辅助工具

+ 计算机比人类更擅长做枯燥和重复性的工作。也就是说，应该使用静态分析工具，并发工具和测试工具来自动完成这些验证。
+ 用一个以上的C++编译器来编译代码，往往是验证代码的最简单方式。一个编译器可能检测不到某种未定义行为，而另一个编译器可能会在同样的情况下发出警告或者产生错误

### 适当使用支持库

+ 你应该去找设计良好，文档齐全，支持良好的库。
+ 突出的例子包括：
  + C++标准库
  + Guidelines支持的库
  + Boost库

## 第三章 接口

+ 接口是服务的提供者和使用者之间的契约

### 避免非const的全局变量

+ 全局变量会在函数中注入隐藏的依赖，而该依赖并不是接口的一部分