---
category: Books
date: 2024-09-05 09:00:00 +0800
layout: post
title: C++程序设计语言 第四部分 标准库
tag: book
---
## 简介

+ C++程序设计语言 第四部分 标准库相关笔记

## 第三十章 标准库概览

### 30.1 引言

+ 标准库是一个组件集合，在ISO C++标准中定义，在所有实现中都以一致的形式(和性能)提供。出于可移植性和长期维护的考虑，强烈推荐在合适的地方尽量使用表混库。一般而言，不要尝试重新发明轮子。

#### 30.1.1 标准库设施

+ 标准库是所有C++实现都必须提供的，以便每个程序员都能依靠它来编写程序。C++标准库提供
  + 语言特性的支持，例如内存管理，范围for语句和运行时类型信息
  + 具体C++实现所定义的一些语言相关的信息，如最大float值
  + 单纯用语言难以高效实现的基本操作，例如 is_polymorphic, is_scalar 和 is_nothrow_constructible
  + 底层(无锁)并发编程设施
  + 基于线程的并发编程的支持
  + 基于任务的并发的基本支持，例如future和async()
  + 大多数程序员难以实现最优且可移植版本的函数，例如 uninitialized_fill()和memmove()
  + 无用内存回收(垃圾收集)的基本支持，例如declare_reachable()
  + 程序员编写可移植代码所需的复杂基础组件，例如list,map,sort和IO流
  + 用于标准库自身扩展的框架，例如允许用户为自定义类型提供与内置类型相似的I/O操作的规范和基础组件以及标准模板库STL

+ 标准库的设计目标之一是成为其他库的公共基础。特别是，组合使用标准库特性可以起到三方面的支撑作用
  + 可移植性的基础
  + 一组紧凑且高效的组件，可以作为构造性能敏感的库和应用的基础
  + 一组实现库内交互的组件。

### 30.2 头文件

+ 标准库组件都定义在命名空间std中，以一组头文件的形式提供。头文件构成了标准库最主要的部分，因此，列出头文件可以给出标准库的一个概貌。
+ 以字母c开头的标准库头文件对应C标准库中的头文件。每个C标准库头文件<x.h>都定义了一些同时位于全局命名空间和命名空间std中的内容，且有一个定义相同内容的对应头文件<cx>。理想情况下，头文件<cX>中的名字不会污染全局命名空间，但不幸的是(归咎于管理多语言，多操作系统环境的复杂性)大多数实际情况下会发生污染。

+ 容器
  + <vector> 可变大小一维数组
  + <deque> 双端队列
  + <forward_list> 单向链表
  + <list> 双向链表
  + <map> 关联数组
  + <set> 集合
  + <unordered_map> 哈希关联数组
  + <unordered_set> 哈希集合
  + <queue> 队列
  + <stack> 栈
  + <array> 固定大小一维数组
  + <bitset> bool数组
+ 关联容器multimap和multiset分别声明在<map>和<set>中，priority_queue声明在<queue>中

+ 通用工具
  + <utility> 运算符和值对
  + <tuple> 元组
  + <type_traits> 类型萃取
  + <typeindex> 将type_info用作一个关键字或哈希码
  + <function> 函数对象
  + <memory> 资源管理指针
  + <scoped_allocator> 限定作用域的分配器
  + <ratio> 编译时有理数算术运算
  + <chrono> 时间工具
  + <ctime> C风格日期和时间工具
  + <iterator> 迭代器及其支持
+ 迭代器机制令标准库算法具有通用性

+ 算法
  + <algorithm> 泛型算法
  + <cstdlib> bseach(), qsort()
+ 一个典型的泛型算法能应用于任何类型的元素构成的序列。C标准库函数bsearch()和qsort()只能用于内置数组，且元素类型不能有用户自定义的拷贝构造函数和析构函数

+ 诊断
  + <exception> 异常类
  + <stdexcept> 标准异常
  + <cassert> 断言宏
  + <cerrno> C风格错误才处理
  + <system_error> 系统错误支持

+ 字符串和字符
  + <string> T的字符串
  + <cctype> 字符分类
  + <cwctype> 宽字符分类
  + <cstring> C风格字符串函数
  + <cwchar> C风格宽字符字符串函数
  + <cstdlib> C风格分配函数
  + <cuchar> C风格多字节字符串
  + <regex> 正则表达式匹配
+ 头文件<cstring>声明了strlen(),strcpy()等一族函数。头文件<cstdlib>声明了atof()和atoi()，可将C风格字符串转换为数值。

+ 输入/输出
  + <iosfwd> I/O组件的前置声明
  + <iostream> 标准iostream对象和操作
  + <ios> iostream基类
  + <streambuf> 流缓冲
  + <istream> 输入流模板
  + <ostream> 输出流模板
  + <iomanip> 操纵符
  + <sstream> 字符串流
  + <cctype> 字符分类函数
  + <fstream> 文件流
  + <cstdio> printf() I/O函数族
  + <cwchar> 宽字符printf()风格I/O函数
+ 操纵符是操作流状态的对象

+ 本地化
  + <locale> 表示文化差异
  + <clocale> 文化差异C风格表示
  + <codecvt> 代码转换
+ locale对日期输出格式，货币表示符号和字符串校勘等在不同语言和文化中有差异的内容进行本地化

+ 语言支持
  + <limits> 数值限制
  + <climits> 数值标量限制C风格宏
  + <cfloat> 浮点数限制C风格宏
  + <cstdint> 标准整数类型名
  + <new> 动态内存管理
  + <typeinfo> 运行时类型识别支持
  + <exception> 异常处理支持
  + <initializer_list> initializer_list
  + <cstddef> C标准库语言支持
  + <cstdarg> 可变长函数参数列表
  + <csetjmp> C风格栈展开
  + <cstdlib> 程序终止
  + <ctime> 系统时钟
  + <csignal> C风格信号处理
+ 头文件<cstddef>定义了sizeof()返回的类型size_t，指针减法和数组下标返回的类型ptrdiff_t以及声名狼藉的NULL宏
+ C风格栈展开(使用<csetjmp中的setjmp和longjmp>)与析构函数和异常处理不兼容，因此最好避免使用。

+ 数值
  + <complex> 复数及其运算
  + <valarray> 数值向量及其运算
  + <numeric> 推广的数值运算
  + <cmath> 标准数学函数
  + <cstdlib> C风格随机数
  + <random> 随机数发生器
+ 由于历史原因，abs()和div()不像其他数学函数那样在<cmath>中，而是在<cstdlib>中

+ 并发
  + <atomic> 原子类型及其操作
  + <condition_variable> 等待动作
  + <future> 异步任务
  + <mutex> 互斥类
  + <thread> 线程
+ C标准库的一些组件与C++程序员有着不同程度的关联，C++标准库提供了对这些组件的访问机制。

+ C兼容性
  + <cinttypes> 公共整数类型的别名
  + <cstdbool> C的bool类型
  + <ccomplex> <complex>
  + <cfenv> 浮点数环境
  + <cstdalign> C的对齐机制
  + <ctgmath> C的泛型数学函数： <complex> 和 <cmath>

### 30.3 语言支持

+ 语言支持是标准库中很小但至关重要的部分，是程序正常运行所必需的，因为语言特性依赖于这些组件。

+ 标准库支持的语言特性
  + <new> new和delete
  + <typeinfo> typeid()和type_info
  + <iterator> 范围for
  + <initializer_list> initializer_list

### 30.3.1 initializer_list 支持

+ 一个 {} 列表会依据规则转换为一个 std::initializer_list<X> 类型的对象。
+ 不幸的是, initializer_list并未提供下标运算符。如果你希望用 [] 而不是 *，可对指针使用下标
```cpp
void f(initializer_list<int> lst)
{
  const int* p = lst.begin();
  for (int i = 0; i < lst.size(); i++>)
  {
    std::cerr << p[i] << "\n";
  }
}
```

+ initializer_list自然也可用于范围for语句
```cpp
void f2(initializer_list<int> lst)
{
  for (auto x : lst)
  {
    std::cerr << x << "\n";
  }
}
```

### 30.3.2 范围for支持

+ 一条范围for语句会借助迭代器映射为一条for语句。
+ 在<iterator>中，标准库提供了std::begin()和std::end()两个函数，可用于内置数组及任何提供了begin()和end()成员的类型。
+ 所有标准库容器和字符串都支持使用范围for的迭代；容器适配器(例如stack和priority_queue)则不支持。容器的头文件(例如<vector>)会包含<initializer_list>，因此用户很少需要自己直接包含它。

### 30.4 错误处理

+ 标准库包含的组件已有将近40年的开发历程。因此，它们处理错误的风格和方法并不统一
  + C风格库函数大多数通过设置errno来指示发生了错误
  + 很多对元素序列进行操作的算法返回一个尾后迭代器来指示 未找到 或 失败
  + I/O流库要依赖于每个流中的一个状态来反映错误，并可能(根据用户需要)通过抛出异常来指示错误。
  + 一些标准库组件，例如vector,string和bitset通过抛出异常来指示错误。

+ 标准库的设计目标之一是所有组件都遵守基本保证：即，即使抛出了异常，也不会有资源(例如内存)泄露，且不会有标准库类的不变式被破坏的情况出现。

### 30.4.1 异常

+ 一些标准库组件通过抛出异常来报告错误
+ 标准库异常
  + bitset: 抛出invalid_argument, out_of_range,overflow_error
  + iostream: 如果允许异常的话，抛出ios_base::failure
  + regex: 抛出regex_error
  + string: 抛出length_error,out_of_range
  + vector: 抛出out_of_range
  + new T: 如果不能为一个T分配内存，抛出bad_alloc
  + dynamic_cast<T>(r): 如果不能将引用r转换为一个T，抛出bad_cast
  + typeid(): 如果不能获得一个type_info,抛出bad_typeid
  + thread: 抛出system_error
  + call_once(): 抛出system_error
  + mutex: 抛出system_error
  + condition_variable: 抛出system_error
  + async(): 抛出system_error
  + packaged_task: 抛出system_error
  + future和promise: 抛出system_error
+ 任何直接或间接使用这些组件的代码都可能遇到这些异常。
+ 除非你确认使用组件的方式不会令它们抛出异常，否则坚持在某处(例如main())捕获标准库异常类层次的某个根类(例如exception)和任何异常(...)是一个很好的编程习惯。

#### 30.4.1.1 标准库exception类层次

+ 不要抛出int，C风格字符串等内置类型，而应该抛出专门表示异常的类型的对象。

#### 30.4.1.2 异常传播

+ <exception>中提供了一些组件，令异常传播对程序员可见
+ 异常传播
  + exception_ptr: 非特定的异常指针类型
  + ep = current_exception() ep是一个exception_ptr,指向当前异常，若当前无活动异常则不指向任何异常；不抛出异常
  + rethrow_exception(ep): 重新抛出ep指向的异常；ep包含的不能是空指针nullptr；无返回值
  + ep = make_exception_ptr(e): ep是指向exception e的exception_ptr；不抛出异常。
+ 一个exception_ptr可以指向任何异常，不局限于exception类层次中的异常。可将exception_ptr看作一种智能指针(类似shared_ptr)--只要一个exception_ptr还指向其异常，那么这个异常就会保持活跃。这样，我们就可以通过exception_ptr将一个异常从捕获它的函数中传递出来，并在其他地方重新抛出。即，exception_ptr可用来实现在捕获线程之外的其他线程中重抛出异常，这是promise和future所需要的。对一个exception_ptr使用rethrow_exception(在不同线程中)不会引起数据竞争。
+ **异常不能从noexcept函数中传播出去**.

#### 30.4.1.3 terminate()

+ 在<exception>中，标准库提供了处理意外异常的组件
+ terminate
  + h = get_terminate(): h为当前终止处理程序；不抛出异常
  + h2 = set_terminate(): 当前终止处理程序被设定为h；h2为旧终止处理程序；不抛出异常
  + terminate(): 终止程序；无返回值；不抛出异常。
+ 除了极特殊的情况下使用set_terminate()和terminate()之外，其他情况应避免使用这些函数

### 30.4.2 断言

+ 标准库提供了断言机制
+ 断言
  + static_assert(e, s) 在编译时对e求职；若!e为假则将s作为编译器错误信息输出
  + assert(e): 若宏NOBUG未定义，则在运行时对e进行求职，若!e为假，向cerr输出一个消息并调用abort();若定义了NOBUG，则什么也不做。
  + assert()是一个宏，定义在<cassert>中，assert()生成什么错误信息由C++具体实现自己决定，但应该包含源文件名(__FILE__)和assert()所在的源码行号(__LINE__)
  + 断言常常用于产品级代码而非教材的小例子中(它也本应如此)
  + 函数名(__func__)也可能包含在消息中。

### 30.4.3 system_error

+ 在<system_error>中，标准库提供了一个能从操作系统和底层系统组件报告错误的框架。

#### 30.4.3.1 错误码

+ 当一个错误以错误码的形式从程序底层浮上来时，我们必须处理这个错误或将错误码转换为一个异常。

#### 30.4.3.2 错误类别

#### 30.4.3.3 system_error异常

+ system_error报告的错误都源自标准库中处理操作系统的部分。它传递一个error_code，并可传递一个错误消息字符串。
+ 自然的，system_error可用于标准库之外的程序。它传递一个系统相关的error_code，而不是一个可移植的error_condition

#### 30.4.3.4 可移植的错误状态

+ 可移植错误码(error_condition)的表现形式与系统相关的error_code几乎相同。总体思路是每个系统有一组特有的("原生的")错误码，可映射到潜在可移植的错误码，这样对于需要跨平台编程的程序员(通常是编写库的程序员)来说会更加方便。

### 30.5 建议

+ 使用标准库组件保持可移植性
+ 使用标准库组件尽量减少维护成本
+ 将标准库组件作为更广泛和更专门化的库的基础
+ 使用标准库组件作为灵活，广泛使用的软件的模型
+ 标准库组件定义在命名空间std中，都是在标准库头文件中定义的
+ 每个C标准库头文件X.h都有其C++标准库对应的版本<cX>
+ 必须#include相应的头文件才能使用标准库组件
+ 为了对内置数组使用范围for，需要 #include <iterator>
+ 优选基于异常的错误处理而非返回错误码方式的错误处理
+ 始终要捕获 exception&(对标准库和语言支持的异常)和...(对意料之外的异常)
+ 标准库exception层次可以(但不是必须支持)用于用户自定义异常
+ 如果发生严重错误，调用terminate()
+ 大量使用static_assert()和assert()
+ 不要假定assert()总是会被求值

## 第三十一章 STL容器

### 31.1 引言

+ STL包含标准库中的迭代器，容器，算法和函数对象几个部分。

### 31.2 容器概览

+ 一个容器保存着一个对象序列。容器可分类为
  + 顺序容器提供对元素(半开)序列的访问
  + 关联容器提供基于关键字的关联查询
+ 此外，标准库还提供了一些保存元素的对象类型，它们并未提供顺序容器或关联容器的全部功能
  + 容器适配器提供对底层容器的特殊访问
  + 拟容器保存元素序列，提供容器的大部分但非全部功能
+ STL容器都是资源句柄，都定了拷贝和移动操作。所有容器操作都提供了基本保证，确保与基于异常的错误处理机制能够正确协同工作。

+ 顺序容器
  + vector<T, A> 空间连续分配的T类型元素序列，默认选择容器
  + list<T, A> T类型元素双向链表，当需要插入/删除元素但不移动已有元素时选择它
  + forward_list<T, A> T类型元素单向链表，很短的或空序列的理想选择
  + deque<T, A> T类型元素双端队列，向量和链表的混合，对大多数应用而言，都比向量和链表其中之一要慢。
+ 这些容器都定义在<vector>,<list>和<deque>中。顺序容器为元素连续分配内存(例如vector)或将元素组织为链表(例如forward_list)，元素的类型是容器的成员value_type(或者是上表中的T)。deque(发音为 deck)采用链表和连续存储的混合方式。
+ 除非你有充足的理由，否则应该优选vector而不是其他顺序容器。注意，vector提供了添加，删除元素的操作，这些操作都允许vector按需增长或收缩。对于包含少量元素的序列而言，vector是一种完美的支持列表操作的数据结构。
+ 当在一个vector中插入，删除元素时，其他元素可能会移动。与之相反，链表或关联容器中的元素则不会因为插入新元素或删除其他元素而移动。
+ forward_list(单向链表)是一种专为空链表和极短链表优化过的数据结构。一个空forward_list只占用一个内存字。在实际应用中，有相当多的情况链表是空的(还有很多情况链表是非常短)

+ 有序关联容器
  + map<K,V,C,A> 从K到V的有序映射，一个(K,V)对序列
  + multimap<K,V,C,A> 从K到V的有序映射，允许重复关键字
  + set<K,C,A> K的有序集合
  + multiset<K,C,A> K的有序集合，允许重复关键字
+ 这些容器通常用平衡二叉树(通常是红黑树)实现
+ 关键字(K)的默认序标准是 std::less<K>
+ 类似顺序容器，模板参数A是分配器，容器用它来分配和释放内存。对映射，A的默认值是 std::allocator<std::pair<const K,T>>，对集合，A的默认值是std::allocator<K>

+ 无序关联容器
  + unordered_map<K,V,H,E,A> 从K到V 的无序映射
  + unordered_multimap<K,V,H,E,A> 从K到V 的无序映射，允许关键字重复
  + unordered_set<K,H,E,A> K的无序集合
  + unordered_multiset<K,H,E,A> 从K的无序集合，允许关键字重复
+ 这些容器都是采用溢出链表法的哈希表实现。关键字类型K的默认哈希函数类型H为 std::hash<K>。关键字类型K的默认相等判断函数类型E为 std::equal_to<K>；相等性判定函数用来判断哈希值相同的两个对象是否相等

+ 容器适配器是一类特殊容器，它们为其他容器提供了特殊的接口
  + priority_queue<T,C,Cmp> T的优先队列，Cmp是优先级函数类型
  + queue<T,C> T的队列，支持push()和pop()操作
  + stack<T,C> T的栈，支持push()和pop()操作
+ 一个priority_queue的默认优先级函数Cmp为std::less<T>.queue的默认容器类型C为 std::deque<T>,stack和priority_queue的默认容器类型C为std::vector<T>

+ 某些数据类型具有标准容器所应有的大部分特性，但又非全部。我们有时称这些数据类型为 拟容器。
  + T[N] 固定大小的内置数组；N个连续存储的类型为T的元素；没有size()或其他成员函数
  + array<T, N> 固定大小的数组，N个连续存储的类型为T的元素，类似内置数组，但解决了大部分问题。
  + basic_string<C, Tr, A> 一个连续分配空间的类型为C的字符序列，支持文本处理操作，例如连接(+, +=)；basic_string通常都经过了优化，短字符串无须使用自由存储空间。
  + string basic_string<char>
  + u16string basic_string<char16_t>
  + u32string basic_string<char32_t>
  + wstring basic_string<wchar_t>
  + valarray<T> 数值向量，支持向量运算，但有一些限制，这些限制是为了鼓励高性能实现；只在做大量向量运算时使用
  + bitset<N> N个二进制位的集合，支持集合操作，例如&和|
  + vector<bool> vector<T>的特例化版本，紧凑保存二进制位
+ 对basic_string，A是其分配器，Tr是字符萃取
+ 如果可以选择的话，应该有限选择vector,string或array这样的容器，而不是内置数组。内置数组有两个问题--**数组到指针的隐式类型转换和必须要记住大小**，它们都是错误的主要来源。
+ 还应该优先选择标准字符串，而不是其他字符串或C风格字符串。C风格字符串的指针语义意味着笨拙的符号表示和程序员的额外工作，它也是主要错误来源之一(例如内存泄漏)

#### 31.2.1

+ C++标准并未给标准容器规定特定的表示形式，而是指明了容器接口和一些复杂性要求。实现者会选择适当的(通常也是巧妙优化过的)实现方法来满足一般要求和常见用途。除了处理元素所需的一些内容之外，这类句柄还持有一个分配器。

+ 对于一个vector，其元素的数据结构很可能是一个数组。vector会保存指向一个元素组的指针，还会保存元素数目和向量容量(已分配的和尚未使用的位置数)或等价的一些信息
+ list很可能表示为一个指向元素的链接序列以及元素数目
+ forward_list很可能表示为一个指向元素的链接序列
+ map很可能实现为一颗平衡树，树节点指向(键，值)对
+ unorder_map很可能实现为一个哈希表
+ string的实现可能为：短string的字符保存在string句柄内，而长string的元素则保存在自由存储空间中的连续区域(类似vector的元素)。类似vector，一个string也会预留空闲空间，以便扩张时不必频繁的重新分配空间
+ 类似内置数组，array就是一个简单的元素序列，无句柄。这意味着一个局部array不会使用任何自由存储空间(除非它本身实在自由存储空间中分配的)，而且一个类的array成员也不会悄悄带来任何自由存储空间操作。

#### 31.2.2 对元素的要求

+ 若想作为一个容器的元素，对象类型必须允许容器拷贝，移动以及交换元素。如果容器使用拷贝构造函数或拷贝赋值操作拷贝一个元素，拷贝的结果必须是一个等价的对象。这大致意味着任何对象值相等性检测都必须得到副本和原值相等的结论。换句话说，元素拷贝必须能像int的普通拷贝一样正常工作。
+ 类似的，移动构造函数和移动赋值操作也必须具有常规定义和常规移动语义。此外，元素类型还必须允许按常规语义交换元素。如果一个类型定义了拷贝或移动操作，则标准库swap()就能正常工作。

+ 对元素类型的要求和细节散布在C++标准中，很难阅读，但基本上，如果一个类型具有常规的拷贝或移动操作，容器就能保存该类型元素。只要满足容器元素的基本要求和算法的特定要求(例如元素有序)，很多基本算法，例如copy(),find()和sort()都能正常运行。
+ 当无法拷贝对象时，一个替换方案是将对象指针而不是对象本身保存在容器中。最典型的例子就是多态类型。例如，**我们使用vector<unique_prt<Shape>>或vector<Shape*>，而不是vector<Shape>来保证多态性行为**。

##### 31.2.2.1 比较操作

+ 关联容器要求其元素能够排序，很多可以应用于容器的操作也有此要求。默认情况下，< 运算符被用来定义序。如果 < 不合适，程序员必须提供一个替代操作。
+ 排序标准必须定义一个严格弱序(strict weak ordering)。形式化地描述，即小于和相等关系(如果定义了的话)都必须是传递的。

### 31.3 操作概览

+ 常量，表示操作花费的时间不依赖于容器中的元素数目；常量时间(constant time)的另一种常见表示方式是O(1)。O(n)表示操作花费的时间与元素数目成正比
+ 所有容器的size()操作都是常量时间的。

#### 31.3.1 成员类型

+ 每个容器都定义了如下一组成员类型
  + value_type 元素类型
  + allocator_type 内存管理类型
  + size_type 容器下标，元素数目等无符号类型
  + difference_type 迭代器差异的带符号类型
  + iterator 行为类似value_type*
  + const_iterator 行为类似 const_value_type*
  + reverse_iterator 行为类似 value_type*
  + const_reverse_iterator 行为类似 const_value_type*
  + reference const_value_type&
  + const_reference 行为类似value_type*
  + pointer 行为类似 value_type*
  + const_pointer 行为类似 const_value_type*
  + kep_type 关键字类型；仅关联容器具有
  + mapped_type 映射值类型；仅关联容器具有
  + key_compare 比较标准类型；仅有序容器具有
  + hasher 哈希函数类型: 仅无序容器具有
  + key_euqal 等价性检验函数类型；仅无需容器具有
  + local_iterator 桶迭代器类型；仅无需容器具有
  + const_local_iterator 桶迭代器类型；仅无需容器具有
+ 每个容器和 拟容器 都提供了上表中大多数成员类型，但是不会提供无意义的类型

#### 31.3.2 构造函数，析构函数和赋值操作

+ 赋值操作并不拷贝或移动分配器，目标容器获得了一组新的元素，但会保留其旧分配器，新元素(如果有的话)的空间也是用此分配器分配的。
+ 谨记，一个构造函数或是一次元素拷贝可能会抛出异常，来指出它无法完成这个任务
+ 紧急，**对大小初始化器使用 (),而对其他所有初始化器都是用 {}**